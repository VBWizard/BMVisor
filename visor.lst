   1              		.file	"0-visor_main.c"
   2              		.intel_syntax noprefix
   3              		.text
   4              	.Ltext0:
   5              	#APP
   6 0000 EB00     		jmp main
   7              	#NO_APP
   8              		.comm	_exception_number,2,2
   9              		.comm	_exc_CS,2,2
  10              		.comm	_exc_IP,2,2
  11              		.comm	vhost,68,32
  12              		.comm	guest,28,4
  13              		.comm	GuestRegisters,56,32
  14              		.comm	host,8,4
  15              		.globl	fatalErrorNum
  16              		.bss
  17              		.align 4
  20              	fatalErrorNum:
  21 0000 00000000 		.zero	4
  22              		.section	.rodata
  23              	.LC0:
  24 0000 41626F75 		.string	"About to enable A20"
  24      7420746F 
  24      20656E61 
  24      626C6520 
  24      41323000 
  25              	.LC1:
  26 0014 5669736F 		.string	"Visor Loaded"
  26      72204C6F 
  26      61646564 
  26      00
  27              	.LC2:
  28 0021 53564D20 		.string	"SVM is available"
  28      69732061 
  28      7661696C 
  28      61626C65 
  28      00
  29 0032 00       		.string	""
  30 0033 00       		.align 4
  31              	.LC3:
  32 0034 53564D20 		.string	"SVM is not available on this machine."
  32      6973206E 
  32      6F742061 
  32      7661696C 
  32      61626C65 
  33 005a 00       		.string	""
  34 005b 00       		.align 4
  35              	.LC4:
  36 005c 53564D20 		.string	"SVM is disabled in the BIOS and is not unlockable"
  36      69732064 
  36      69736162 
  36      6C656420 
  36      696E2074 
  37 008e 00       		.string	""
  38              	.LC5:
  39 008f 53564D20 		.string	"SVM is disabled with key"
  39      69732064 
  39      69736162 
  39      6C656420 
  39      77697468 
  40 00a8 00       		.string	""
  41 00a9 000000   		.align 4
  42              	.LC6:
  43 00ac 556E6B6E 		.string	"Unknown error detecting SVM availability"
  43      6F776E20 
  43      6572726F 
  43      72206465 
  43      74656374 
  44 00d5 00       		.string	""
  45              		.text
  46              		.globl	main
  48              	main:
  49              	.LFB0:
  50              		.file 1 "0-visor_main.c"
   1:0-visor_main.c **** __asm__("jmp main");
   2:0-visor_main.c **** 
   3:0-visor_main.c **** #include "visor_main.h"
   4:0-visor_main.c **** #include "BMVisor.h"
   5:0-visor_main.c **** #include "vmcb.h"
   6:0-visor_main.c **** #include "x86_architecture.h"
   7:0-visor_main.c **** #include "utility.h"
   8:0-visor_main.c **** #include "x86.h"
   9:0-visor_main.c **** #include "pmode.h"
  10:0-visor_main.c **** #include "pmode_screen.h"
  11:0-visor_main.c **** #include "guest.h"
  12:0-visor_main.c **** #include "host.h"
  13:0-visor_main.c **** 
  14:0-visor_main.c **** 
  15:0-visor_main.c **** DWORD fatalErrorNum = 0;
  16:0-visor_main.c **** 
  17:0-visor_main.c **** void main(void)
  18:0-visor_main.c **** {
  51              		.loc 1 18 0
  52              		.cfi_startproc
  53 0002 8D4C2404 		lea	ecx, [esp+4]
  54              		.cfi_def_cfa 1, 0
  55 0006 83E4F0   		and	esp, -16
  56 0009 FF71FC   		push	DWORD PTR [ecx-4]
  57 000c 55       		push	ebp
  58              		.cfi_escape 0x10,0x5,0x2,0x75,0
  59 000d 89E5     		mov	ebp, esp
  60 000f 53       		push	ebx
  61 0010 51       		push	ecx
  62              		.cfi_escape 0xf,0x3,0x75,0x78,0x6
  63              		.cfi_escape 0x10,0x3,0x2,0x75,0x7c
  64 0011 83EC10   		sub	esp, 16
  19:0-visor_main.c ****     setHostSegReg(FS, SELECTOR_ALL_MEM);
  65              		.loc 1 19 0
  66 0014 83EC08   		sub	esp, 8
  67 0017 6A10     		push	16
  68 0019 6A0B     		push	11
  69 001b E8FCFFFF 		call	setHostSegReg
  69      FF
  70 0020 83C410   		add	esp, 16
  20:0-visor_main.c ****     setHostSegReg(DS, SELECTOR_VISOR_DATA);
  71              		.loc 1 20 0
  72 0023 83EC08   		sub	esp, 8
  73 0026 6A38     		push	56
  74 0028 6A09     		push	9
  75 002a E8FCFFFF 		call	setHostSegReg
  75      FF
  76 002f 83C410   		add	esp, 16
  21:0-visor_main.c ****     setHostSegReg(ES, SELECTOR_ALL_MEM);
  77              		.loc 1 21 0
  78 0032 83EC08   		sub	esp, 8
  79 0035 6A10     		push	16
  80 0037 6A0A     		push	10
  81 0039 E8FCFFFF 		call	setHostSegReg
  81      FF
  82 003e 83C410   		add	esp, 16
  22:0-visor_main.c ****     setHostSegReg(GS, SELECTOR_VISOR_DATA);
  83              		.loc 1 22 0
  84 0041 83EC08   		sub	esp, 8
  85 0044 6A38     		push	56
  86 0046 6A0C     		push	12
  87 0048 E8FCFFFF 		call	setHostSegReg
  87      FF
  88 004d 83C410   		add	esp, 16
  23:0-visor_main.c **** 
  24:0-visor_main.c ****     vhost.memSize = 0x15000000;
  89              		.loc 1 24 0
  90 0050 C7053000 		mov	DWORD PTR vhost+48, 352321536
  90      00000000 
  90      0015
  25:0-visor_main.c ****     guest.memSize = 3*1024*1024; //0x3000000;
  91              		.loc 1 25 0
  92 005a C7050000 		mov	DWORD PTR guest, 3145728
  92      00000000 
  92      3000
  26:0-visor_main.c ****     guest.GuestMemStartAddress = 0x0;
  93              		.loc 1 26 0
  94 0064 C7050800 		mov	DWORD PTR guest+8, 0
  94      00000000 
  94      0000
  27:0-visor_main.c ****     vhost.CodeBase = guest.memSize + guest.GuestMemStartAddress + (1024*1024*1);    
  95              		.loc 1 27 0
  96 006e 8B150000 		mov	edx, DWORD PTR guest
  96      0000
  97 0074 A1080000 		mov	eax, DWORD PTR guest+8
  97      00
  98 0079 01D0     		add	eax, edx
  99 007b 05000010 		add	eax, 1048576
  99      00
 100 0080 A3000000 		mov	DWORD PTR vhost, eax
 100      00
  28:0-visor_main.c ****     vhost.StackBase = vhost.CodeBase;
 101              		.loc 1 28 0
 102 0085 A1000000 		mov	eax, DWORD PTR vhost
 102      00
 103 008a A3040000 		mov	DWORD PTR vhost+4, eax
 103      00
  29:0-visor_main.c ****     vhost.VMCBOffset = 0x30000;
 104              		.loc 1 29 0
 105 008f C7050800 		mov	DWORD PTR vhost+8, 196608
 105      00000000 
 105      0300
  30:0-visor_main.c ****     vhost.VMCBIoioOffset = vhost.VMCBOffset + sizeof(struct vmcb_struct);
 106              		.loc 1 30 0
 107 0099 A1080000 		mov	eax, DWORD PTR vhost+8
 107      00
 108 009e 05001000 		add	eax, 4096
 108      00
 109 00a3 A30C0000 		mov	DWORD PTR vhost+12, eax
 109      00
  31:0-visor_main.c ****     vhost.CR3 = vhost.VMCBIoioOffset + 0x3000;
 110              		.loc 1 31 0
 111 00a8 A10C0000 		mov	eax, DWORD PTR vhost+12
 111      00
 112 00ad 05003000 		add	eax, 12288
 112      00
 113 00b2 A33C0000 		mov	DWORD PTR vhost+60, eax
 113      00
  32:0-visor_main.c ****     vhost.IDTOffset = vhost.CR3 + 0x1000 /*PDE*/ + (vhost.memSize / 0x1000) * 4 /*PTE*/;
 114              		.loc 1 32 0
 115 00b7 A13C0000 		mov	eax, DWORD PTR vhost+60
 115      00
 116 00bc 8B153000 		mov	edx, DWORD PTR vhost+48
 116      0000
 117 00c2 C1EA0C   		shr	edx, 12
 118 00c5 C1E202   		sal	edx, 2
 119 00c8 01D0     		add	eax, edx
 120 00ca 05001000 		add	eax, 4096
 120      00
 121 00cf A3100000 		mov	DWORD PTR vhost+16, eax
 121      00
  33:0-visor_main.c ****     vhost.GDTOffset = vhost.IDTOffset + 0x1000;
 122              		.loc 1 33 0
 123 00d4 A1100000 		mov	eax, DWORD PTR vhost+16
 123      00
 124 00d9 05001000 		add	eax, 4096
 124      00
 125 00de A3140000 		mov	DWORD PTR vhost+20, eax
 125      00
  34:0-visor_main.c ****     vhost.HostSaveArea = (vhost.GDTOffset + 0x1000 + 0x10000) & 0xFFFF0000; //Bottom 12 bits of HSA
 126              		.loc 1 34 0
 127 00e3 A1140000 		mov	eax, DWORD PTR vhost+20
 127      00
 128 00e8 05001001 		add	eax, 69632
 128      00
 129 00ed 66B80000 		mov	ax, 0
 130 00f1 A3180000 		mov	DWORD PTR vhost+24, eax
 130      00
  35:0-visor_main.c ****     vhost.BIOSSave = vhost.HostSaveArea + 0x4000 /*Size of HSA*/;  //BIOSSave is 128k
 131              		.loc 1 35 0
 132 00f6 A1180000 		mov	eax, DWORD PTR vhost+24
 132      00
 133 00fb 05004000 		add	eax, 16384
 133      00
 134 0100 A31C0000 		mov	DWORD PTR vhost+28, eax
 134      00
  36:0-visor_main.c ****     vhost.VIDEOSave = vhost.BIOSSave + 0x20000; //VIDEOSave is 64k
 135              		.loc 1 36 0
 136 0105 A11C0000 		mov	eax, DWORD PTR vhost+28
 136      00
 137 010a 05000002 		add	eax, 131072
 137      00
 138 010f A3200000 		mov	DWORD PTR vhost+32, eax
 138      00
  37:0-visor_main.c ****     vhost.NestedCR3 = vhost.VIDEOSave + 0x10000;  //Vid Bios is 0xFFFF bytes
 139              		.loc 1 37 0
 140 0114 A1200000 		mov	eax, DWORD PTR vhost+32
 140      00
 141 0119 05000001 		add	eax, 65536
 141      00
 142 011e A3240000 		mov	DWORD PTR vhost+36, eax
 142      00
  38:0-visor_main.c ****     vhost.NestedCR3Backup = vhost.NestedCR3 + 0x1000 /*PDE*/ + (guest.memSize / 0x1000) * 4 /*PTE*/
 143              		.loc 1 38 0
 144 0123 A1240000 		mov	eax, DWORD PTR vhost+36
 144      00
 145 0128 8B150000 		mov	edx, DWORD PTR guest
 145      0000
 146 012e C1EA0C   		shr	edx, 12
 147 0131 C1E202   		sal	edx, 2
 148 0134 01D0     		add	eax, edx
 149 0136 05001000 		add	eax, 4096
 149      00
 150 013b A3280000 		mov	DWORD PTR vhost+40, eax
 150      00
  39:0-visor_main.c ****     vhost.BootSectorSave = vhost.NestedCR3Backup + 0x1000 /*PDE*/ + (guest.memSize / 0x1000) * 4 /*
 151              		.loc 1 39 0
 152 0140 A1280000 		mov	eax, DWORD PTR vhost+40
 152      00
 153 0145 8B150000 		mov	edx, DWORD PTR guest
 153      0000
 154 014b C1EA0C   		shr	edx, 12
 155 014e C1E202   		sal	edx, 2
 156 0151 01D0     		add	eax, edx
 157 0153 05001000 		add	eax, 4096
 157      00
 158 0158 A32C0000 		mov	DWORD PTR vhost+44, eax
 158      00
  40:0-visor_main.c ****     vhost.e820MemMap = vhost.BootSectorSave + 0x200;
 159              		.loc 1 40 0
 160 015d A12C0000 		mov	eax, DWORD PTR vhost+44
 160      00
 161 0162 05000200 		add	eax, 512
 161      00
 162 0167 A3400000 		mov	DWORD PTR vhost+64, eax
 162      00
  41:0-visor_main.c ****     
  42:0-visor_main.c ****     println("About to enable A20");
 163              		.loc 1 42 0
 164 016c 83EC0C   		sub	esp, 12
 165 016f 68000000 		push	OFFSET FLAT:.LC0
 165      00
 166 0174 E8FCFFFF 		call	println
 166      FF
 167 0179 83C410   		add	esp, 16
  43:0-visor_main.c ****     if ( (inb(0x92) & 0x2) != 0x2)
 168              		.loc 1 43 0
 169 017c 83EC0C   		sub	esp, 12
 170 017f 68920000 		push	146
 170      00
 171 0184 E8FCFFFF 		call	inb
 171      FF
 172 0189 83C410   		add	esp, 16
 173 018c 0FB6C0   		movzx	eax, al
 174 018f 83E002   		and	eax, 2
 175 0192 85C0     		test	eax, eax
 176 0194 752B     		jne	.L2
  44:0-visor_main.c ****         ENABLE_A20
 177              		.loc 1 44 0
 178 0196 83EC08   		sub	esp, 8
 179 0199 68D10000 		push	209
 179      00
 180 019e 6A64     		push	100
 181 01a0 E8FCFFFF 		call	outb
 181      FF
 182 01a5 83C410   		add	esp, 16
 183 01a8 83EC08   		sub	esp, 8
 184 01ab 68DF0000 		push	223
 184      00
 185 01b0 6A60     		push	96
 186 01b2 E8FCFFFF 		call	outb
 186      FF
 187 01b7 83C410   		add	esp, 16
 188 01ba C6051800 		mov	BYTE PTR guest+24, 1
 188      000001
 189              	.L2:
  45:0-visor_main.c ****         guest.port92Value = inb(0x92);
 190              		.loc 1 45 0
 191 01c1 83EC0C   		sub	esp, 12
 192 01c4 68920000 		push	146
 192      00
 193 01c9 E8FCFFFF 		call	inb
 193      FF
 194 01ce 83C410   		add	esp, 16
 195 01d1 A2190000 		mov	BYTE PTR guest+25, al
 195      00
  46:0-visor_main.c ****     DWORD lAddy = vhost.CodeBase + vhost.GDTOffset;
 196              		.loc 1 46 0
 197 01d6 8B150000 		mov	edx, DWORD PTR vhost
 197      0000
 198 01dc A1140000 		mov	eax, DWORD PTR vhost+20
 198      00
 199 01e1 01D0     		add	eax, edx
 200 01e3 8945F4   		mov	DWORD PTR [ebp-12], eax
  47:0-visor_main.c ****     CopyMemory(HOST_START_GDT, vhost.CodeBase + vhost.GDTOffset, 0x400);
 201              		.loc 1 47 0
 202 01e6 8B150000 		mov	edx, DWORD PTR vhost
 202      0000
 203 01ec A1140000 		mov	eax, DWORD PTR vhost+20
 203      00
 204 01f1 01D0     		add	eax, edx
 205 01f3 83EC04   		sub	esp, 4
 206 01f6 68000400 		push	1024
 206      00
 207 01fb 50       		push	eax
 208 01fc 68000006 		push	393216
 208      00
 209 0201 E8FCFFFF 		call	CopyMemory
 209      FF
 210 0206 83C410   		add	esp, 16
  48:0-visor_main.c ****     CopyMemory(INT15_MEMORY_MAP << 4, vhost.CodeBase + vhost.e820MemMap, 0x1024);
 211              		.loc 1 48 0
 212 0209 8B150000 		mov	edx, DWORD PTR vhost
 212      0000
 213 020f A1400000 		mov	eax, DWORD PTR vhost+64
 213      00
 214 0214 01D0     		add	eax, edx
 215 0216 83EC04   		sub	esp, 4
 216 0219 68241000 		push	4132
 216      00
 217 021e 50       		push	eax
 218 021f 6800C003 		push	245760
 218      00
 219 0224 E8FCFFFF 		call	CopyMemory
 219      FF
 220 0229 83C410   		add	esp, 16
  49:0-visor_main.c ****     OPEN_UP_DS
 221              		.loc 1 49 0
 222              	#APP
 223              	# 49 "0-visor_main.c" 1
  50 022d B8100000 	    GDTR *gdtP = (GDTR*)vhost.CodeBase + vhost.GDTOffset + (11*8)+4; //Temporary GDTR load address,
  50      00
  51 0232 50       	    gdtP->base = lAddy;
  52 0233 1F       	    gdtP->limit = (11*8)-1;
  53 0234 58       	    __asm__(	"mov ebx,%[gdtr]\n lgdt [ebx]\n"
  54              	    :
  55              	    : [gdtr] "r" (gdtP));
  50:0-visor_main.c ****     gdtP->base = lAddy;
 224              		push eax
 225              	 mov eax, 0x10
 226              	 push eax
 227              	 pop ds
 228              	 pop eax
 229              	
 230              	# 0 "" 2
 231              		.loc 1 50 0
 232              	#NO_APP
 233 0235 8B151400 		mov	edx, DWORD PTR vhost+20
 233      0000
 234 023b 89D0     		mov	eax, edx
 235 023d 01C0     		add	eax, eax
 236 023f 01D0     		add	eax, edx
 237 0241 01C0     		add	eax, eax
 238 0243 89C2     		mov	edx, eax
 239 0245 A1000000 		mov	eax, DWORD PTR vhost
 239      00
 240 024a 01D0     		add	eax, edx
 241 024c 05280200 		add	eax, 552
 241      00
 242 0251 8945F0   		mov	DWORD PTR [ebp-16], eax
  51:0-visor_main.c ****     gdtP->limit = (11*8)-1;
 243              		.loc 1 51 0
 244 0254 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 245 0257 8B55F4   		mov	edx, DWORD PTR [ebp-12]
 246 025a 895002   		mov	DWORD PTR [eax+2], edx
  52:0-visor_main.c ****     __asm__(	"mov ebx,%[gdtr]\n lgdt [ebx]\n"
 247              		.loc 1 52 0
 248 025d 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 249 0260 66C70057 		mov	WORD PTR [eax], 87
 249      00
  53:0-visor_main.c ****     :
 250              		.loc 1 53 0
 251 0265 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 252              	#APP
 253              	# 53 "0-visor_main.c" 1
  56              	    RESTORE_DS
 254              		mov ebx,eax
 255              	 lgdt [ebx]
 256              	
 257              	# 0 "" 2
 258              		.loc 1 56 0
 259              	#NO_APP
 260 026d B8380000 		mov	eax, 56
 260      00
 261              	#APP
 262              	# 56 "0-visor_main.c" 1
  57 0273 89C0     	    /*Create our host stack segment*/
  58 0275 50       	    DESCR_SEG *item = (DESCR_SEG*)lAddy;
  59 0276 1F       	    setup_GDT32_entry_gcc(item+3, vhost.StackBase, 0xFFFFFFFF, 0X93, 0xC);
  60 0277 58       	    asm("mov ebx,0x18\n push ebx\n pop ss\n mov esp,%[lESP]" :: [lESP] "r" ((DWORD)(vhost.memSize -
  61              	    RelocateMyself();
  62              	    RetrieveStartModuleDiskCHSValues((WORD*) &host.RealSectors, (WORD*) &host.RealHeads, (DWORD*) &
  58:0-visor_main.c ****     setup_GDT32_entry_gcc(item+3, vhost.StackBase, 0xFFFFFFFF, 0X93, 0xC);
 263              		push eax
 264              	 mov eax, eax
 265              	 push eax
 266              	 pop ds
 267              	 pop eax
 268              	
 269              	# 0 "" 2
 270              		.loc 1 58 0
 271              	#NO_APP
 272 0278 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 273 027b 8945EC   		mov	DWORD PTR [ebp-20], eax
  59:0-visor_main.c ****     asm("mov ebx,0x18\n push ebx\n pop ss\n mov esp,%[lESP]" :: [lESP] "r" ((DWORD)(vhost.memSize -
 274              		.loc 1 59 0
 275 027e A1040000 		mov	eax, DWORD PTR vhost+4
 275      00
 276 0283 8B55EC   		mov	edx, DWORD PTR [ebp-20]
 277 0286 83C218   		add	edx, 24
 278 0289 83EC0C   		sub	esp, 12
 279 028c 6A0C     		push	12
 280 028e 68930000 		push	147
 280      00
 281 0293 6AFF     		push	-1
 282 0295 50       		push	eax
 283 0296 52       		push	edx
 284 0297 E8FCFFFF 		call	setup_GDT32_entry_gcc
 284      FF
 285 029c 83C420   		add	esp, 32
  60:0-visor_main.c ****     RelocateMyself();
 286              		.loc 1 60 0
 287 029f 8B153000 		mov	edx, DWORD PTR vhost+48
 287      0000
 288 02a5 A1000000 		mov	eax, DWORD PTR vhost
 288      00
 289 02aa 29C2     		sub	edx, eax
 290 02ac 89D0     		mov	eax, edx
 291 02ae 83E864   		sub	eax, 100
 292              	#APP
 293              	# 60 "0-visor_main.c" 1
  63 02b8 89C4     	    ZeroMemory(vhost.CodeBase + vhost.VMCBOffset, sizeof(struct vmcb_struct));
  64              	    InitializeGuest();
  61:0-visor_main.c ****     RetrieveStartModuleDiskCHSValues((WORD*) &host.RealSectors, (WORD*) &host.RealHeads, (DWORD*) &
 294              		mov ebx,0x18
 295              	 push ebx
 296              	 pop ss
 297              	 mov esp,eax
 298              	# 0 "" 2
 299              		.loc 1 61 0
 300              	#NO_APP
 301 02ba E8FCFFFF 		call	RelocateMyself
 301      FF
  62:0-visor_main.c ****     ZeroMemory(vhost.CodeBase + vhost.VMCBOffset, sizeof(struct vmcb_struct));
 302              		.loc 1 62 0
 303 02bf 83EC04   		sub	esp, 4
 304 02c2 68040000 		push	OFFSET FLAT:host+4
 304      00
 305 02c7 68020000 		push	OFFSET FLAT:host+2
 305      00
 306 02cc 68000000 		push	OFFSET FLAT:host
 306      00
 307 02d1 E8FCFFFF 		call	RetrieveStartModuleDiskCHSValues
 307      FF
 308 02d6 83C410   		add	esp, 16
  63:0-visor_main.c ****     InitializeGuest();
 309              		.loc 1 63 0
 310 02d9 8B150000 		mov	edx, DWORD PTR vhost
 310      0000
 311 02df A1080000 		mov	eax, DWORD PTR vhost+8
 311      00
 312 02e4 01D0     		add	eax, edx
 313 02e6 83EC08   		sub	esp, 8
 314 02e9 68001000 		push	4096
 314      00
 315 02ee 50       		push	eax
 316 02ef E8FCFFFF 		call	ZeroMemory
 316      FF
 317 02f4 83C410   		add	esp, 16
 318              		.loc 1 64 0
 319 02f7 E8FCFFFF 		call	InitializeGuest
 319      FF
  65:0-visor_main.c **** //Looper:
  66:0-visor_main.c **** //goto Looper;
  67:0-visor_main.c ****     SetupHostPaging();
 320              		.loc 1 67 0
 321 02fc E8FCFFFF 		call	SetupHostPaging
 321      FF
  68:0-visor_main.c ****     asm volatile("mov cr3, %0":: "b"(vhost.CodeBase + vhost.CR3));
 322              		.loc 1 68 0
 323 0301 8B150000 		mov	edx, DWORD PTR vhost
 323      0000
 324 0307 A13C0000 		mov	eax, DWORD PTR vhost+60
 324      00
 325 030c 01D0     		add	eax, edx
 326 030e 89C3     		mov	ebx, eax
 327              	#APP
 328              	# 68 "0-visor_main.c" 1
  69              	    asm volatile("mov eax, CR0\n or eax,0x80000000\nmov CR0,eax\n"
 329              		mov cr3, ebx
 330              	# 0 "" 2
 331              		.loc 1 69 0
 332              	# 69 "0-visor_main.c" 1
  70 0316 0D000000 	            ::);
  70      80
  71 031b 0F22C0   	    printAt("Visor Loaded",0,20);
  72              	
  73              	    switch (SVMCanBeEnabled())
  71:0-visor_main.c **** 
 333              		mov eax, CR0
 334              	 or eax,0x80000000
 335              	mov CR0,eax
 336              	
 337              	# 0 "" 2
 338              		.loc 1 71 0
 339              	#NO_APP
 340 031e 83EC04   		sub	esp, 4
 341 0321 6A14     		push	20
 342 0323 6A00     		push	0
 343 0325 68140000 		push	OFFSET FLAT:.LC1
 343      00
 344 032a E8FCFFFF 		call	printAt
 344      FF
 345 032f 83C410   		add	esp, 16
 346              		.loc 1 73 0
 347 0332 E8FCFFFF 		call	SVMCanBeEnabled
 347      FF
 348 0337 0FB7C0   		movzx	eax, ax
 349 033a 83F801   		cmp	eax, 1
 350 033d 7429     		je	.L4
 351 033f 83F801   		cmp	eax, 1
 352 0342 7F06     		jg	.L5
 353 0344 85C0     		test	eax, eax
 354 0346 740E     		je	.L6
 355 0348 EB7B     		jmp	.L3
 356              	.L5:
 357 034a 83F802   		cmp	eax, 2
 358 034d 7438     		je	.L7
 359 034f 83F803   		cmp	eax, 3
 360 0352 7452     		je	.L8
 361 0354 EB6F     		jmp	.L3
 362              	.L6:
  74:0-visor_main.c ****     {
  75:0-visor_main.c ****             case SVM_ALLOWED:
  76:0-visor_main.c ****             print("SVM is available\0");
 363              		.loc 1 76 0
 364 0356 83EC0C   		sub	esp, 12
 365 0359 68210000 		push	OFFSET FLAT:.LC2
 365      00
 366 035e E8FCFFFF 		call	print
 366      FF
 367 0363 83C410   		add	esp, 16
  77:0-visor_main.c ****             break;
 368              		.loc 1 77 0
 369 0366 EB7B     		jmp	.L9
 370              	.L4:
  78:0-visor_main.c ****             case SVM_NOT_AVAIL:
  79:0-visor_main.c ****             print("SVM is not available on this machine.\0");
 371              		.loc 1 79 0
 372 0368 83EC0C   		sub	esp, 12
 373 036b 68340000 		push	OFFSET FLAT:.LC3
 373      00
 374 0370 E8FCFFFF 		call	print
 374      FF
 375 0375 83C410   		add	esp, 16
  80:0-visor_main.c ****             FatalError(-1);
 376              		.loc 1 80 0
 377 0378 83EC0C   		sub	esp, 12
 378 037b 6AFF     		push	-1
 379 037d E8FCFFFF 		call	FatalError
 379      FF
 380 0382 83C410   		add	esp, 16
  81:0-visor_main.c ****             break;
 381              		.loc 1 81 0
 382 0385 EB5C     		jmp	.L9
 383              	.L7:
  82:0-visor_main.c ****             case SVM_DISABLED_AT_BIOS_NOT_UNLOCKABLE:
  83:0-visor_main.c ****             print("SVM is disabled in the BIOS and is not unlockable\0");
 384              		.loc 1 83 0
 385 0387 83EC0C   		sub	esp, 12
 386 038a 685C0000 		push	OFFSET FLAT:.LC4
 386      00
 387 038f E8FCFFFF 		call	print
 387      FF
 388 0394 83C410   		add	esp, 16
  84:0-visor_main.c ****             FatalError(-2);
 389              		.loc 1 84 0
 390 0397 83EC0C   		sub	esp, 12
 391 039a 6AFE     		push	-2
 392 039c E8FCFFFF 		call	FatalError
 392      FF
 393 03a1 83C410   		add	esp, 16
  85:0-visor_main.c ****             break;
 394              		.loc 1 85 0
 395 03a4 EB3D     		jmp	.L9
 396              	.L8:
  86:0-visor_main.c ****             case SVM_DISABLED_WITH_KEY:
  87:0-visor_main.c ****             print("SVM is disabled with key\0");
 397              		.loc 1 87 0
 398 03a6 83EC0C   		sub	esp, 12
 399 03a9 688F0000 		push	OFFSET FLAT:.LC5
 399      00
 400 03ae E8FCFFFF 		call	print
 400      FF
 401 03b3 83C410   		add	esp, 16
  88:0-visor_main.c ****             FatalError(-3);
 402              		.loc 1 88 0
 403 03b6 83EC0C   		sub	esp, 12
 404 03b9 6AFD     		push	-3
 405 03bb E8FCFFFF 		call	FatalError
 405      FF
 406 03c0 83C410   		add	esp, 16
  89:0-visor_main.c ****             break;
 407              		.loc 1 89 0
 408 03c3 EB1E     		jmp	.L9
 409              	.L3:
  90:0-visor_main.c ****             default:
  91:0-visor_main.c ****             print("Unknown error detecting SVM availability\0");
 410              		.loc 1 91 0
 411 03c5 83EC0C   		sub	esp, 12
 412 03c8 68AC0000 		push	OFFSET FLAT:.LC6
 412      00
 413 03cd E8FCFFFF 		call	print
 413      FF
 414 03d2 83C410   		add	esp, 16
  92:0-visor_main.c ****             FatalError(-4);
 415              		.loc 1 92 0
 416 03d5 83EC0C   		sub	esp, 12
 417 03d8 6AFC     		push	-4
 418 03da E8FCFFFF 		call	FatalError
 418      FF
 419 03df 83C410   		add	esp, 16
  93:0-visor_main.c ****             break;
 420              		.loc 1 93 0
 421 03e2 90       		nop
 422              	.L9:
  94:0-visor_main.c ****     }
  95:0-visor_main.c ****     
  96:0-visor_main.c ****         
  97:0-visor_main.c ****     ZeroMemory(vhost.CodeBase + vhost.VMCBIoioOffset,0x400 * 12); //IOIO Map is 12k
 423              		.loc 1 97 0
 424 03e3 8B150000 		mov	edx, DWORD PTR vhost
 424      0000
 425 03e9 A10C0000 		mov	eax, DWORD PTR vhost+12
 425      00
 426 03ee 01D0     		add	eax, edx
 427 03f0 83EC08   		sub	esp, 8
 428 03f3 68003000 		push	12288
 428      00
 429 03f8 50       		push	eax
 430 03f9 E8FCFFFF 		call	ZeroMemory
 430      FF
 431 03fe 83C410   		add	esp, 16
  98:0-visor_main.c ****     guest.vmcb->iopm_base_pa = vhost.CodeBase + vhost.VMCBIoioOffset;
 432              		.loc 1 98 0
 433 0401 8B0D0400 		mov	ecx, DWORD PTR guest+4
 433      0000
 434 0407 8B150000 		mov	edx, DWORD PTR vhost
 434      0000
 435 040d A10C0000 		mov	eax, DWORD PTR vhost+12
 435      00
 436 0412 01D0     		add	eax, edx
 437 0414 BA000000 		mov	edx, 0
 437      00
 438 0419 894140   		mov	DWORD PTR [ecx+64], eax
 439 041c 895144   		mov	DWORD PTR [ecx+68], edx
  99:0-visor_main.c ****     
 100:0-visor_main.c ****     //Create my PMode IDT (its about time!)
 101:0-visor_main.c ****     SetupHostIDT();
 440              		.loc 1 101 0
 441 041f E8FCFFFF 		call	SetupHostIDT
 441      FF
 102:0-visor_main.c **** //    asm("xchg bx,bx\n");
 103:0-visor_main.c ****     asm ("mov ebx,%[idtr_addr]\n"
 104:0-visor_main.c ****     "mov fs:[ebx+2],%[base] \n"
 105:0-visor_main.c ****     "movw fs:[ebx], %[limit]\n"
 106:0-visor_main.c ****     "lidt fs:[ebx]\n"
 107:0-visor_main.c ****     ::[idtr_addr] "r" (vhost.CodeBase + vhost.IDTOffset + 0x900),
 442              		.loc 1 107 0
 443 0424 8B150000 		mov	edx, DWORD PTR vhost
 443      0000
 444 042a A1100000 		mov	eax, DWORD PTR vhost+16
 444      00
 445 042f 01D0     		add	eax, edx
 446 0431 05000900 		add	eax, 2304
 446      00
 108:0-visor_main.c ****       [base] "r" (vhost.CodeBase + vhost.IDTOffset),
 447              		.loc 1 108 0
 448 0436 8B0D0000 		mov	ecx, DWORD PTR vhost
 448      0000
 449 043c 8B151000 		mov	edx, DWORD PTR vhost+16
 449      0000
 450 0442 01CA     		add	edx, ecx
 103:0-visor_main.c ****     "mov fs:[ebx+2],%[base] \n"
 451              		.loc 1 103 0
 452 0444 B9070100 		mov	ecx, 263
 452      00
 453              	#APP
 454              	# 103 "0-visor_main.c" 1
 109:0-visor_main.c ****       [limit] "r" ( (WORD)((0x21*8)-1))
 110:0-visor_main.c ****     ); //011a8000
 111:0-visor_main.c ****     SaveHostBIOS();
 455              		mov ebx,eax
 456              	mov fs:[ebx+2],edx 
 457              	movw fs:[ebx], cx
 458              	lidt fs:[ebx]
 459              	
 460              	# 0 "" 2
 461              		.loc 1 111 0
 462              	#NO_APP
 463 0457 E8FCFFFF 		call	SaveHostBIOS
 463      FF
 112:0-visor_main.c ****     SetupGuestBootMemory();
 464              		.loc 1 112 0
 465 045c E8FCFFFF 		call	SetupGuestBootMemory
 465      FF
 113:0-visor_main.c ****     //We remap 0x0:0x0 so need to back up the Nested paging tables again
 114:0-visor_main.c ****     CopyMemory(vhost.CodeBase + vhost.NestedCR3, vhost.CodeBase + vhost.NestedCR3Backup, 0x1000 /*P
 466              		.loc 1 114 0
 467 0461 A1000000 		mov	eax, DWORD PTR guest
 467      00
 468 0466 C1E80C   		shr	eax, 12
 469 0469 05000400 		add	eax, 1024
 469      00
 470 046e 8D0C8500 		lea	ecx, [0+eax*4]
 470      000000
 471 0475 8B150000 		mov	edx, DWORD PTR vhost
 471      0000
 472 047b A1280000 		mov	eax, DWORD PTR vhost+40
 472      00
 473 0480 01C2     		add	edx, eax
 474 0482 8B1D0000 		mov	ebx, DWORD PTR vhost
 474      0000
 475 0488 A1240000 		mov	eax, DWORD PTR vhost+36
 475      00
 476 048d 01D8     		add	eax, ebx
 477 048f 83EC04   		sub	esp, 4
 478 0492 51       		push	ecx
 479 0493 52       		push	edx
 480 0494 50       		push	eax
 481 0495 E8FCFFFF 		call	CopyMemory
 481      FF
 482 049a 83C410   		add	esp, 16
 115:0-visor_main.c **** 
 116:0-visor_main.c ****     //SetIOIOPort(0x70,true);
 117:0-visor_main.c ****     //SetIOIOPort(0x92,true);
 118:0-visor_main.c **** 
 119:0-visor_main.c ****     //Now that we have an IDT, setup the PIT channel 0
 120:0-visor_main.c ****     //56 interrupts per second, one approximately every 18.2 ms.
 121:0-visor_main.c ****     setup_pit_channel_0( 56 );
 483              		.loc 1 121 0
 484 049d 83EC0C   		sub	esp, 12
 485 04a0 6A38     		push	56
 486 04a2 E8FCFFFF 		call	setup_pit_channel_0
 486      FF
 487 04a7 83C410   		add	esp, 16
 122:0-visor_main.c **** 
 123:0-visor_main.c ****     //And now that we have the PIT running, enable interrupts
 124:0-visor_main.c ****     asm("STI\n");
 488              		.loc 1 124 0
 489              	#APP
 490              	# 124 "0-visor_main.c" 1
 125              	#ifdef DEBUG_BASIC
 126              	    PrintHostInformation();
 491              		STI
 492              	
 493              	# 0 "" 2
 494              		.loc 1 126 0
 495              	#NO_APP
 496 04ab E8FCFFFF 		call	PrintHostInformation
 496      FF
 127:0-visor_main.c ****     PrintE820Data();
 497              		.loc 1 127 0
 498 04b0 E8FCFFFF 		call	PrintE820Data
 498      FF
 128:0-visor_main.c **** #ifdef DEBUG
 129:0-visor_main.c ****     DumpVMCB();
 499              		.loc 1 129 0
 500 04b5 E8FCFFFF 		call	DumpVMCB
 500      FF
 130:0-visor_main.c **** #endif
 131:0-visor_main.c **** #endif
 132:0-visor_main.c ****     DoVisor();
 501              		.loc 1 132 0
 502 04ba E8FCFFFF 		call	DoVisor
 502      FF
 133:0-visor_main.c **** }
 503              		.loc 1 133 0
 504 04bf 90       		nop
 505 04c0 8D65F8   		lea	esp, [ebp-8]
 506 04c3 59       		pop	ecx
 507              		.cfi_restore 1
 508              		.cfi_def_cfa 1, 0
 509 04c4 5B       		pop	ebx
 510              		.cfi_restore 3
 511 04c5 5D       		pop	ebp
 512              		.cfi_restore 5
 513 04c6 8D61FC   		lea	esp, [ecx-4]
 514              		.cfi_def_cfa 4, 4
 515 04c9 C3       		ret
 516              		.cfi_endproc
 517              	.LFE0:
 519              	.Letext0:
 520              		.file 2 "types.h"
 521              		.file 3 "xen_types.h"
 522              		.file 4 "x86_architecture.h"
 523              		.file 5 "vmcb.h"
 524              		.file 6 "pmode.h"
 525              		.file 7 "host.h"
 526              		.file 8 "guest.h"
 527              		.file 9 "visor_main.h"
 528              		.file 10 "isr_wrapper.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 0-visor_main.c
     /tmp/ccb2vt7W.s:4      .text:0000000000000000 .Ltext0
     /tmp/ccb2vt7W.s:48     .text:0000000000000002 main
                            *COM*:0000000000000002 _exception_number
                            *COM*:0000000000000002 _exc_CS
                            *COM*:0000000000000002 _exc_IP
                            *COM*:0000000000000044 vhost
                            *COM*:000000000000001c guest
                            *COM*:0000000000000038 GuestRegisters
                            *COM*:0000000000000008 host
     /tmp/ccb2vt7W.s:20     .bss:0000000000000000 fatalErrorNum
     /tmp/ccb2vt7W.s:23     .rodata:0000000000000000 .LC0
     /tmp/ccb2vt7W.s:25     .rodata:0000000000000014 .LC1
     /tmp/ccb2vt7W.s:27     .rodata:0000000000000021 .LC2
     /tmp/ccb2vt7W.s:31     .rodata:0000000000000034 .LC3
     /tmp/ccb2vt7W.s:35     .rodata:000000000000005c .LC4
     /tmp/ccb2vt7W.s:38     .rodata:000000000000008f .LC5
     /tmp/ccb2vt7W.s:42     .rodata:00000000000000ac .LC6
     /tmp/ccb2vt7W.s:49     .text:0000000000000002 .LFB0
     /tmp/ccb2vt7W.s:189    .text:00000000000001c1 .L2
     /tmp/ccb2vt7W.s:370    .text:0000000000000368 .L4
     /tmp/ccb2vt7W.s:356    .text:000000000000034a .L5
     /tmp/ccb2vt7W.s:362    .text:0000000000000356 .L6
     /tmp/ccb2vt7W.s:409    .text:00000000000003c5 .L3
     /tmp/ccb2vt7W.s:383    .text:0000000000000387 .L7
     /tmp/ccb2vt7W.s:396    .text:00000000000003a6 .L8
     /tmp/ccb2vt7W.s:422    .text:00000000000003e3 .L9
     /tmp/ccb2vt7W.s:517    .text:00000000000004ca .LFE0
     /tmp/ccb2vt7W.s:519    .text:00000000000004ca .Letext0
     /tmp/ccb2vt7W.s:530    .debug_info:0000000000000000 .Ldebug_info0
     /tmp/ccb2vt7W.s:1994   .debug_abbrev:0000000000000000 .Ldebug_abbrev0
     /tmp/ccb2vt7W.s:2602   .debug_str:00000000000003be .LASF152
     /tmp/ccb2vt7W.s:2670   .debug_str:000000000000057f .LASF153
     /tmp/ccb2vt7W.s:2516   .debug_str:0000000000000209 .LASF154
     /tmp/ccb2vt7W.s:2394   .debug_line:0000000000000000 .Ldebug_line0
     /tmp/ccb2vt7W.s:2568   .debug_str:0000000000000315 .LASF0
     /tmp/ccb2vt7W.s:2664   .debug_str:000000000000054f .LASF2
     /tmp/ccb2vt7W.s:2574   .debug_str:000000000000032a .LASF1
     /tmp/ccb2vt7W.s:2688   .debug_str:00000000000005cd .LASF3
     /tmp/ccb2vt7W.s:2480   .debug_str:000000000000017d .LASF4
     /tmp/ccb2vt7W.s:2652   .debug_str:00000000000004fb .LASF5
     /tmp/ccb2vt7W.s:2484   .debug_str:000000000000018d .LASF6
     /tmp/ccb2vt7W.s:2686   .debug_str:00000000000005c1 .LASF7
     /tmp/ccb2vt7W.s:2612   .debug_str:0000000000000437 .LASF8
     /tmp/ccb2vt7W.s:2518   .debug_str:000000000000022d .LASF9
     /tmp/ccb2vt7W.s:2556   .debug_str:00000000000002ca .LASF10
     /tmp/ccb2vt7W.s:2410   .debug_str:000000000000004a .LASF11
     /tmp/ccb2vt7W.s:2560   .debug_str:00000000000002df .LASF12
     /tmp/ccb2vt7W.s:2606   .debug_str:0000000000000420 .LASF13
     /tmp/ccb2vt7W.s:2552   .debug_str:00000000000002be .LASF14
     /tmp/ccb2vt7W.s:2592   .debug_str:0000000000000384 .LASF15
     /tmp/ccb2vt7W.s:2450   .debug_str:000000000000010f .LASF16
     /tmp/ccb2vt7W.s:2632   .debug_str:0000000000000489 .LASF17
     /tmp/ccb2vt7W.s:2662   .debug_str:000000000000054a .LASF18
     /tmp/ccb2vt7W.s:2432   .debug_str:00000000000000bd .LASF19
     /tmp/ccb2vt7W.s:2618   .debug_str:0000000000000451 .LASF20
     /tmp/ccb2vt7W.s:2534   .debug_str:000000000000026d .LASF21
     /tmp/ccb2vt7W.s:2554   .debug_str:00000000000002c3 .LASF22
     /tmp/ccb2vt7W.s:2566   .debug_str:0000000000000300 .LASF23
     /tmp/ccb2vt7W.s:2544   .debug_str:000000000000029a .LASF41
     /tmp/ccb2vt7W.s:2496   .debug_str:00000000000001c1 .LASF24
     /tmp/ccb2vt7W.s:2430   .debug_str:00000000000000b7 .LASF25
     /tmp/ccb2vt7W.s:2474   .debug_str:0000000000000165 .LASF26
     /tmp/ccb2vt7W.s:2460   .debug_str:0000000000000130 .LASF27
     /tmp/ccb2vt7W.s:2404   .debug_str:0000000000000029 .LASF28
     /tmp/ccb2vt7W.s:2482   .debug_str:0000000000000183 .LASF29
     /tmp/ccb2vt7W.s:2572   .debug_str:000000000000031f .LASF30
     /tmp/ccb2vt7W.s:2672   .debug_str:000000000000058e .LASF31
     /tmp/ccb2vt7W.s:2546   .debug_str:00000000000002a6 .LASF32
     /tmp/ccb2vt7W.s:2512   .debug_str:00000000000001f7 .LASF33
     /tmp/ccb2vt7W.s:2674   .debug_str:0000000000000594 .LASF34
     /tmp/ccb2vt7W.s:2636   .debug_str:0000000000000499 .LASF35
     /tmp/ccb2vt7W.s:2676   .debug_str:000000000000059a .LASF36
     /tmp/ccb2vt7W.s:2678   .debug_str:00000000000005a0 .LASF37
     /tmp/ccb2vt7W.s:2400   .debug_str:000000000000001c .LASF38
     /tmp/ccb2vt7W.s:2506   .debug_str:00000000000001e4 .LASF39
     /tmp/ccb2vt7W.s:2610   .debug_str:000000000000042d .LASF40
     /tmp/ccb2vt7W.s:2442   .debug_str:00000000000000eb .LASF42
     /tmp/ccb2vt7W.s:2622   .debug_str:0000000000000463 .LASF43
     /tmp/ccb2vt7W.s:2424   .debug_str:0000000000000097 .LASF44
     /tmp/ccb2vt7W.s:2540   .debug_str:0000000000000280 .LASF45
     /tmp/ccb2vt7W.s:2578   .debug_str:000000000000033b .LASF46
     /tmp/ccb2vt7W.s:2398   .debug_str:0000000000000008 .LASF47
     /tmp/ccb2vt7W.s:2446   .debug_str:0000000000000103 .LASF48
     /tmp/ccb2vt7W.s:2448   .debug_str:0000000000000109 .LASF49
     /tmp/ccb2vt7W.s:2466   .debug_str:0000000000000147 .LASF50
     /tmp/ccb2vt7W.s:2452   .debug_str:0000000000000118 .LASF51
     /tmp/ccb2vt7W.s:2454   .debug_str:000000000000011e .LASF52
     /tmp/ccb2vt7W.s:2456   .debug_str:0000000000000124 .LASF53
     /tmp/ccb2vt7W.s:2642   .debug_str:00000000000004b9 .LASF54
     /tmp/ccb2vt7W.s:2660   .debug_str:000000000000053c .LASF55
     /tmp/ccb2vt7W.s:2414   .debug_str:0000000000000064 .LASF56
     /tmp/ccb2vt7W.s:2600   .debug_str:00000000000003b3 .LASF57
     /tmp/ccb2vt7W.s:2576   .debug_str:000000000000032f .LASF58
     /tmp/ccb2vt7W.s:2458   .debug_str:000000000000012a .LASF59
     /tmp/ccb2vt7W.s:2604   .debug_str:000000000000041a .LASF60
     /tmp/ccb2vt7W.s:2416   .debug_str:000000000000006f .LASF61
     /tmp/ccb2vt7W.s:2704   .debug_str:0000000000000623 .LASF62
     /tmp/ccb2vt7W.s:2702   .debug_str:0000000000000619 .LASF63
     /tmp/ccb2vt7W.s:2530   .debug_str:0000000000000258 .LASF64
     /tmp/ccb2vt7W.s:2644   .debug_str:00000000000004c6 .LASF65
     /tmp/ccb2vt7W.s:2422   .debug_str:000000000000008d .LASF66
     /tmp/ccb2vt7W.s:2468   .debug_str:000000000000014d .LASF67
     /tmp/ccb2vt7W.s:2582   .debug_str:0000000000000356 .LASF68
     /tmp/ccb2vt7W.s:2616   .debug_str:0000000000000446 .LASF69
     /tmp/ccb2vt7W.s:2426   .debug_str:00000000000000a5 .LASF70
     /tmp/ccb2vt7W.s:2684   .debug_str:00000000000005b6 .LASF71
     /tmp/ccb2vt7W.s:2462   .debug_str:0000000000000137 .LASF72
     /tmp/ccb2vt7W.s:2476   .debug_str:000000000000016a .LASF73
     /tmp/ccb2vt7W.s:2510   .debug_str:00000000000001f0 .LASF74
     /tmp/ccb2vt7W.s:2542   .debug_str:0000000000000295 .LASF75
     /tmp/ccb2vt7W.s:2494   .debug_str:00000000000001bc .LASF76
     /tmp/ccb2vt7W.s:2570   .debug_str:000000000000031a .LASF77
     /tmp/ccb2vt7W.s:2486   .debug_str:00000000000001a4 .LASF78
     /tmp/ccb2vt7W.s:2488   .debug_str:00000000000001aa .LASF79
     /tmp/ccb2vt7W.s:2490   .debug_str:00000000000001b0 .LASF80
     /tmp/ccb2vt7W.s:2402   .debug_str:0000000000000024 .LASF81
     /tmp/ccb2vt7W.s:2492   .debug_str:00000000000001b6 .LASF82
     /tmp/ccb2vt7W.s:2584   .debug_str:000000000000035f .LASF83
     /tmp/ccb2vt7W.s:2522   .debug_str:0000000000000241 .LASF84
     /tmp/ccb2vt7W.s:2524   .debug_str:0000000000000247 .LASF85
     /tmp/ccb2vt7W.s:2508   .debug_str:00000000000001eb .LASF86
     /tmp/ccb2vt7W.s:2434   .debug_str:00000000000000c2 .LASF87
     /tmp/ccb2vt7W.s:2504   .debug_str:00000000000001de .LASF88
     /tmp/ccb2vt7W.s:2580   .debug_str:000000000000034f .LASF89
     /tmp/ccb2vt7W.s:2478   .debug_str:0000000000000172 .LASF90
     /tmp/ccb2vt7W.s:2598   .debug_str:00000000000003a7 .LASF91
     /tmp/ccb2vt7W.s:2548   .debug_str:00000000000002ab .LASF92
     /tmp/ccb2vt7W.s:2440   .debug_str:00000000000000de .LASF93
     /tmp/ccb2vt7W.s:2624   .debug_str:0000000000000471 .LASF94
     /tmp/ccb2vt7W.s:2626   .debug_str:0000000000000477 .LASF95
     /tmp/ccb2vt7W.s:2628   .debug_str:000000000000047d .LASF96
     /tmp/ccb2vt7W.s:2630   .debug_str:0000000000000483 .LASF97
     /tmp/ccb2vt7W.s:2428   .debug_str:00000000000000b1 .LASF98
     /tmp/ccb2vt7W.s:2444   .debug_str:00000000000000f7 .LASF99
     /tmp/ccb2vt7W.s:2648   .debug_str:00000000000004e1 .LASF100
     /tmp/ccb2vt7W.s:2654   .debug_str:000000000000050d .LASF101
     /tmp/ccb2vt7W.s:2520   .debug_str:0000000000000233 .LASF102
     /tmp/ccb2vt7W.s:2638   .debug_str:00000000000004a6 .LASF103
     /tmp/ccb2vt7W.s:2498   .debug_str:00000000000001c6 .LASF104
     /tmp/ccb2vt7W.s:2650   .debug_str:00000000000004f2 .LASF105
     /tmp/ccb2vt7W.s:2608   .debug_str:0000000000000426 .LASF106
     /tmp/ccb2vt7W.s:2640   .debug_str:00000000000004b2 .LASF107
     /tmp/ccb2vt7W.s:2586   .debug_str:0000000000000366 .LASF108
     /tmp/ccb2vt7W.s:2538   .debug_str:0000000000000278 .LASF109
     /tmp/ccb2vt7W.s:2634   .debug_str:0000000000000492 .LASF110
     /tmp/ccb2vt7W.s:2464   .debug_str:000000000000013d .LASF111
     /tmp/ccb2vt7W.s:2418   .debug_str:0000000000000080 .LASF112
     /tmp/ccb2vt7W.s:2594   .debug_str:000000000000038d .LASF113
     /tmp/ccb2vt7W.s:2470   .debug_str:0000000000000153 .LASF114
     /tmp/ccb2vt7W.s:2692   .debug_str:00000000000005e5 .LASF115
     /tmp/ccb2vt7W.s:2532   .debug_str:0000000000000262 .LASF116
     /tmp/ccb2vt7W.s:2596   .debug_str:0000000000000398 .LASF117
     /tmp/ccb2vt7W.s:2700   .debug_str:000000000000060f .LASF118
     /tmp/ccb2vt7W.s:2514   .debug_str:00000000000001ff .LASF119
     /tmp/ccb2vt7W.s:2620   .debug_str:0000000000000456 .LASF120
     /tmp/ccb2vt7W.s:2472   .debug_str:000000000000015c .LASF121
     /tmp/ccb2vt7W.s:2590   .debug_str:000000000000037a .LASF122
     /tmp/ccb2vt7W.s:2694   .debug_str:00000000000005ef .LASF123
     /tmp/ccb2vt7W.s:2436   .debug_str:00000000000000c8 .LASF124
     /tmp/ccb2vt7W.s:2646   .debug_str:00000000000004d2 .LASF125
     /tmp/ccb2vt7W.s:2420   .debug_str:0000000000000085 .LASF126
     /tmp/ccb2vt7W.s:2562   .debug_str:00000000000002ed .LASF127
     /tmp/ccb2vt7W.s:2698   .debug_str:0000000000000603 .LASF128
     /tmp/ccb2vt7W.s:2536   .debug_str:0000000000000273 .LASF129
     /tmp/ccb2vt7W.s:2666   .debug_str:000000000000055d .LASF130
     /tmp/ccb2vt7W.s:2588   .debug_str:000000000000036d .LASF131
     /tmp/ccb2vt7W.s:2668   .debug_str:0000000000000572 .LASF132
     /tmp/ccb2vt7W.s:2412   .debug_str:0000000000000057 .LASF133
     /tmp/ccb2vt7W.s:2680   .debug_str:00000000000005a6 .LASF134
     /tmp/ccb2vt7W.s:2500   .debug_str:00000000000001cc .LASF135
     /tmp/ccb2vt7W.s:2526   .debug_str:000000000000024d .LASF136
     /tmp/ccb2vt7W.s:2706   .debug_str:000000000000062c .LASF137
     /tmp/ccb2vt7W.s:2408   .debug_str:000000000000003e .LASF138
     /tmp/ccb2vt7W.s:2696   .debug_str:00000000000005f9 .LASF139
     /tmp/ccb2vt7W.s:2406   .debug_str:0000000000000030 .LASF140
     /tmp/ccb2vt7W.s:2690   .debug_str:00000000000005e0 .LASF155
     /tmp/ccb2vt7W.s:2438   .debug_str:00000000000000d8 .LASF141
     /tmp/ccb2vt7W.s:2528   .debug_str:0000000000000253 .LASF142
     /tmp/ccb2vt7W.s:2682   .debug_str:00000000000005b1 .LASF143
     /tmp/ccb2vt7W.s:2658   .debug_str:000000000000052a .LASF144
     /tmp/ccb2vt7W.s:2396   .debug_str:0000000000000000 .LASF145
     /tmp/ccb2vt7W.s:2564   .debug_str:00000000000002f8 .LASF146
     /tmp/ccb2vt7W.s:2550   .debug_str:00000000000002b8 .LASF147
     /tmp/ccb2vt7W.s:2502   .debug_str:00000000000001d8 .LASF148
     /tmp/ccb2vt7W.s:2558   .debug_str:00000000000002d0 .LASF149
     /tmp/ccb2vt7W.s:2614   .debug_str:0000000000000441 .LASF150
     /tmp/ccb2vt7W.s:2656   .debug_str:000000000000051c .LASF151

UNDEFINED SYMBOLS
setHostSegReg
println
inb
outb
CopyMemory
setup_GDT32_entry_gcc
RelocateMyself
RetrieveStartModuleDiskCHSValues
ZeroMemory
InitializeGuest
SetupHostPaging
printAt
SVMCanBeEnabled
print
FatalError
SetupHostIDT
SaveHostBIOS
SetupGuestBootMemory
setup_pit_channel_0
PrintHostInformation
PrintE820Data
DumpVMCB
DoVisor
   1              		.file	"guest.c"
   2              		.intel_syntax noprefix
   3              		.text
   4              	.Ltext0:
   5              		.comm	_exception_number,2,2
   6              		.comm	_exc_CS,2,2
   7              		.comm	_exc_IP,2,2
   8              		.comm	vhost,68,32
   9              		.comm	guest,28,4
  10              		.comm	GuestRegisters,56,32
  11              		.comm	lTempDest,4,4
  12              		.comm	lTempSource,4,4
  13              		.globl	IntDetails
  14              		.data
  15              		.align 4
  18              	IntDetails:
  19 0000 00004000 		.long	4194304
  20              		.globl	IntDetailsPtr
  21              		.bss
  22              		.align 4
  25              	IntDetailsPtr:
  26 0000 00000000 		.zero	4
  27              		.local	IOPortInValue
  28              		.comm	IOPortInValue,4,4
  29              		.local	IOPortInValueSet
  30              		.comm	IOPortInValueSet,4,4
  31              		.text
  32              		.globl	GetCSIp
  34              	GetCSIp:
  35              	.LFB0:
  36              		.file 1 "guest.c"
   1:guest.c       **** #include "guest.h"
   2:guest.c       **** 
   3:guest.c       **** DWORD lTempDest, lTempSource;
   4:guest.c       **** volatile struct sIntDetails* IntDetails = (volatile struct sIntDetails*)SW_INT_DETAILS_ADDRESS;;
   5:guest.c       **** DWORD IntDetailsPtr = 0;
   6:guest.c       **** static DWORD IOPortInValue = 0;
   7:guest.c       **** static DWORD IOPortInValueSet = false;
   8:guest.c       **** 
   9:guest.c       **** DWORD GetGuestMODRegGenRegValue(BYTE RegOffsetFromCurrIns, bool DW, bool W);
  10:guest.c       **** void SetGuestMODRegGenRegValue(BYTE RegOffsetFromCurrIns, DWORD Value, bool DW, bool W);
  11:guest.c       **** 
  12:guest.c       **** DWORD GetCSIp()
  13:guest.c       **** {
  37              		.loc 1 13 0
  38              		.cfi_startproc
  39 0000 55       		push	ebp
  40              		.cfi_def_cfa_offset 8
  41              		.cfi_offset 5, -8
  42 0001 89E5     		mov	ebp, esp
  43              		.cfi_def_cfa_register 5
  14:guest.c       **** 	//NOTE: Regardless of prot or real mode, in the VMCB CS is always saved in the prot mode format so
  15:guest.c       **** 	return guest.vmcb->cs.base + guest.vmcb->rip;
  44              		.loc 1 15 0
  45 0003 A1040000 		mov	eax, DWORD PTR guest+4
  45      00
  46 0008 8B901C04 		mov	edx, DWORD PTR [eax+1052]
  46      0000
  47 000e 8B801804 		mov	eax, DWORD PTR [eax+1048]
  47      0000
  48 0014 89C1     		mov	ecx, eax
  49 0016 A1040000 		mov	eax, DWORD PTR guest+4
  49      00
  50 001b 8B907C05 		mov	edx, DWORD PTR [eax+1404]
  50      0000
  51 0021 8B807805 		mov	eax, DWORD PTR [eax+1400]
  51      0000
  52 0027 01C8     		add	eax, ecx
  16:guest.c       **** }
  53              		.loc 1 16 0
  54 0029 5D       		pop	ebp
  55              		.cfi_restore 5
  56              		.cfi_def_cfa 4, 4
  57 002a C3       		ret
  58              		.cfi_endproc
  59              	.LFE0:
  61              		.globl	IncrementGuestIP
  63              	IncrementGuestIP:
  64              	.LFB1:
  17:guest.c       **** 
  18:guest.c       **** void IncrementGuestIP(BYTE Count)
  19:guest.c       **** {
  65              		.loc 1 19 0
  66              		.cfi_startproc
  67 002b 55       		push	ebp
  68              		.cfi_def_cfa_offset 8
  69              		.cfi_offset 5, -8
  70 002c 89E5     		mov	ebp, esp
  71              		.cfi_def_cfa_register 5
  72 002e 56       		push	esi
  73 002f 53       		push	ebx
  74 0030 83EC08   		sub	esp, 8
  75              		.cfi_offset 6, -12
  76              		.cfi_offset 3, -16
  77 0033 8B4508   		mov	eax, DWORD PTR [ebp+8]
  78 0036 8845F4   		mov	BYTE PTR [ebp-12], al
  20:guest.c       ****     guest.vmcb->rip = guest.vmcb->rip + Count;
  79              		.loc 1 20 0
  80 0039 8B0D0400 		mov	ecx, DWORD PTR guest+4
  80      0000
  81 003f A1040000 		mov	eax, DWORD PTR guest+4
  81      00
  82 0044 8B907C05 		mov	edx, DWORD PTR [eax+1404]
  82      0000
  83 004a 8B807805 		mov	eax, DWORD PTR [eax+1400]
  83      0000
  84 0050 0FB65DF4 		movzx	ebx, BYTE PTR [ebp-12]
  85 0054 BE000000 		mov	esi, 0
  85      00
  86 0059 01D8     		add	eax, ebx
  87 005b 11F2     		adc	edx, esi
  88 005d 89817805 		mov	DWORD PTR [ecx+1400], eax
  88      0000
  89 0063 89917C05 		mov	DWORD PTR [ecx+1404], edx
  89      0000
  21:guest.c       **** }
  90              		.loc 1 21 0
  91 0069 90       		nop
  92 006a 83C408   		add	esp, 8
  93 006d 5B       		pop	ebx
  94              		.cfi_restore 3
  95 006e 5E       		pop	esi
  96              		.cfi_restore 6
  97 006f 5D       		pop	ebp
  98              		.cfi_restore 5
  99              		.cfi_def_cfa 4, 4
 100 0070 C3       		ret
 101              		.cfi_endproc
 102              	.LFE1:
 104              		.globl	SetupGuestBootMemory
 106              	SetupGuestBootMemory:
 107              	.LFB2:
  22:guest.c       **** 
  23:guest.c       **** /*
  24:guest.c       ****  * Set up memory for the guest boot, copying original MBR, BIOS & VIDEO to 
  25:guest.c       ****  * appropriate guest memory locations.
  26:guest.c       ****  * NOTE: If guest memory offset is 0 then the BIOS & VIDEO aren't copied as
  27:guest.c       ****  *       they are already where they need to be
  28:guest.c       ****  */
  29:guest.c       **** void SetupGuestBootMemory()
  30:guest.c       **** {
 108              		.loc 1 30 0
 109              		.cfi_startproc
 110 0071 55       		push	ebp
 111              		.cfi_def_cfa_offset 8
 112              		.cfi_offset 5, -8
 113 0072 89E5     		mov	ebp, esp
 114              		.cfi_def_cfa_register 5
 115 0074 83EC10   		sub	esp, 16
  31:guest.c       ****    DWORD hnCR3 = (DWORD)guest.vmcb->nested_cr3;
 116              		.loc 1 31 0
 117 0077 A1040000 		mov	eax, DWORD PTR guest+4
 117      00
 118 007c 8B90B400 		mov	edx, DWORD PTR [eax+180]
 118      0000
 119 0082 8B80B000 		mov	eax, DWORD PTR [eax+176]
 119      0000
 120 0088 8945F8   		mov	DWORD PTR [ebp-8], eax
  32:guest.c       ****    int cnt = 0;
 121              		.loc 1 32 0
 122 008b C745FC00 		mov	DWORD PTR [ebp-4], 0
 122      000000
  33:guest.c       ****     //Move original MBR to guest's normal x86 boot memory location
  34:guest.c       ****     lTempDest = 0x7c00 + guest.GuestMemStartAddress;
 123              		.loc 1 34 0
 124 0092 A1080000 		mov	eax, DWORD PTR guest+8
 124      00
 125 0097 05007C00 		add	eax, 31744
 125      00
 126 009c A3000000 		mov	DWORD PTR lTempDest, eax
 126      00
  35:guest.c       ****     lTempSource = BOOT_SECTOR_TEMP_LOCATION;
 127              		.loc 1 35 0
 128 00a1 C7050000 		mov	DWORD PTR lTempSource, 424960
 128      0000007C 
 128      0600
  36:guest.c       ****     asm(            "	mov		esi, %[Source]\n"
 129              		.loc 1 36 0
 130 00ab A1000000 		mov	eax, DWORD PTR lTempDest
 130      00
 131 00b0 8B150000 		mov	edx, DWORD PTR lTempSource
 131      0000
 132              	#APP
 133              	# 36 "guest.c" 1
  37 00b8 89C7     	                    "	mov		edi, %[Dest]\n"
  38 00ba B9000200 	                    "	mov		ecx, 0x200\n"
  38      00
  39 00bf FC       	                    "	cld\n"
  40 00c0 64F3A4   	        	    "   rep movsb es:[edi], fs:[esi]\n"
  41              	                    :
  42              	                    : [Dest] "r" (lTempDest), [Source] "r" (lTempSource));
  43:guest.c       ****     //Bail if guest memory starts at address 0x0 in which case BIOS and VIDEO segments are
  44:guest.c       ****     //already where they need to be.
  45:guest.c       **** /*    if (guest.GuestMemStartAddress != 0x0)
  46:guest.c       ****     {
  47:guest.c       ****         //Copy BIOS segment ... 0xE0000-0xFFFFF
  48:guest.c       ****         lTempDest = 0xE0000 + guest.GuestMemStartAddress;
  49:guest.c       ****         lTempSource = vhost.CodeBase + vhost.BIOSSave;
  50:guest.c       ****         asm(            "	mov	esi,%[Source]\n"	
  51:guest.c       ****                         "	mov edi,%[Dest]\n"
  52:guest.c       ****                         "	mov	ecx, 0x20000\n"
  53:guest.c       ****                         "   rep movsb es:[edi], fs:[esi]\n"
  54:guest.c       ****                         :
  55:guest.c       ****                         : [Dest] "r" (lTempDest), [Source] "r" (lTempSource));
  56:guest.c       **** 
  57:guest.c       ****         //Copy VIDEO segment ... 0xE0000-0xFFFFF
  58:guest.c       ****         lTempDest = 0xC0000 + guest.GuestMemStartAddress;
  59:guest.c       ****         lTempSource = vhost.CodeBase + vhost.VIDEOSave;
  60:guest.c       ****         asm(            "	mov	esi,%[Source]\n"	
  61:guest.c       ****                         "	mov edi,%[Dest]\n"
  62:guest.c       ****                         "	mov	ecx, 0x10000\n"
  63:guest.c       ****                         "   rep movsb es:[edi], fs:[esi]\n"
  64:guest.c       ****                         :
  65:guest.c       ****                         : [Dest] "r" (lTempDest), [Source] "r" (lTempSource));  
  66:guest.c       ****     }
  67:guest.c       **** */    //map the first k of guest memory to the first k of physical memory
  68:guest.c       ****     OPEN_UP_DS
 134              			mov		esi, edx
 135              		mov		edi, eax
 136              		mov		ecx, 0x200
 137              		cld
 138              	   rep movsb es:[edi], fs:[esi]
 139              	
 140              	# 0 "" 2
 141              		.loc 1 68 0
 142              	# 68 "guest.c" 1
  69 00c4 B8100000 	    DWORD *ptrT = (DWORD*)hnCR3 +0x400;
  69      00
  70 00c9 50       	    ptrT[0] = 0x00000007;
  71 00ca 1F       	    //map 0xA000-0xFFFF segment for ROM access
  72 00cb 58       	    for (cnt=0xa0000;cnt<=0xfffff;cnt+=0x1000)
  73              	        ptrT[cnt/0x400/4] = cnt | 7;
  74              	    RESTORE_DS
  69:guest.c       ****     ptrT[0] = 0x00000007;
 143              		push eax
 144              	 mov eax, 0x10
 145              	 push eax
 146              	 pop ds
 147              	 pop eax
 148              	
 149              	# 0 "" 2
 150              		.loc 1 69 0
 151              	#NO_APP
 152 00cc 8B45F8   		mov	eax, DWORD PTR [ebp-8]
 153 00cf 05001000 		add	eax, 4096
 153      00
 154 00d4 8945F4   		mov	DWORD PTR [ebp-12], eax
  70:guest.c       ****     //map 0xA000-0xFFFF segment for ROM access
 155              		.loc 1 70 0
 156 00d7 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 157 00da C7000700 		mov	DWORD PTR [eax], 7
 157      0000
  72:guest.c       ****         ptrT[cnt/0x400/4] = cnt | 7;
 158              		.loc 1 72 0
 159 00e0 C745FC00 		mov	DWORD PTR [ebp-4], 655360
 159      000A00
 160 00e7 EB2C     		jmp	.L5
 161              	.L6:
  73:guest.c       ****     RESTORE_DS
 162              		.loc 1 73 0 discriminator 3
 163 00e9 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 164 00ec 8D90FF0F 		lea	edx, [eax+4095]
 164      0000
 165 00f2 85C0     		test	eax, eax
 166 00f4 0F48C2   		cmovs	eax, edx
 167 00f7 C1F80C   		sar	eax, 12
 168 00fa 8D148500 		lea	edx, [0+eax*4]
 168      000000
 169 0101 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 170 0104 01D0     		add	eax, edx
 171 0106 8B55FC   		mov	edx, DWORD PTR [ebp-4]
 172 0109 83CA07   		or	edx, 7
 173 010c 8910     		mov	DWORD PTR [eax], edx
  72:guest.c       ****         ptrT[cnt/0x400/4] = cnt | 7;
 174              		.loc 1 72 0 discriminator 3
 175 010e 8145FC00 		add	DWORD PTR [ebp-4], 4096
 175      100000
 176              	.L5:
  72:guest.c       ****         ptrT[cnt/0x400/4] = cnt | 7;
 177              		.loc 1 72 0 is_stmt 0 discriminator 1
 178 0115 817DFCFF 		cmp	DWORD PTR [ebp-4], 1048575
 178      FF0F00
 179 011c 7ECB     		jle	.L6
 180              		.loc 1 74 0 is_stmt 1
 181 011e B8380000 		mov	eax, 56
 181      00
 182              	#APP
 183              	# 74 "guest.c" 1
  75 0124 89C0     	    //Don't use CodeBase +, because we'll be using the program's DS to reference the map
  76 0126 50       	//    struct e820entry* e820 = (struct e820entry*)(vhost.e820MemMap);
  77 0127 1F       	//    for (cnt=0;cnt<10;cnt++)
  78 0128 58       	//    {
  79              	//        if (e820[cnt].addr > guest.memSize)
  80              	//            break;
  81:guest.c       **** //        if ( e820[cnt].addr + e820[cnt].size > guest.memSize)
  82:guest.c       **** //            e820[cnt].size = guest.memSize - e820[cnt].addr;
  83:guest.c       **** //        if (e820[cnt].type != 0x1 && e820[cnt].addr > 0x100000)
  84:guest.c       **** //        {
  85:guest.c       **** //            for (cnt2=e820[cnt].addr; cnt2<e820[cnt].addr + e820[cnt].size;cnt2+=0x1000)
  86:guest.c       **** //            {
  87:guest.c       **** //                mapArea = cnt2 & 0xFFFFF000;
  88:guest.c       **** //                OPEN_UP_DS
  89:guest.c       **** //                ptrT[mapArea/0x400/4] = (ptrT[mapArea/0x400/4] & 0xFFFFFF00) | 5;
  90:guest.c       **** //                RESTORE_DS
  91:guest.c       **** //            }
  92:guest.c       **** //        }
  93:guest.c       **** //    }
  94:guest.c       **** }
 184              		push eax
 185              	 mov eax, eax
 186              	 push eax
 187              	 pop ds
 188              	 pop eax
 189              	
 190              	# 0 "" 2
 191              		.loc 1 94 0
 192              	#NO_APP
 193 0129 90       		nop
 194 012a C9       		leave
 195              		.cfi_restore 5
 196              		.cfi_def_cfa 4, 4
 197 012b C3       		ret
 198              		.cfi_endproc
 199              	.LFE2:
 201              		.globl	DoGuestPageLookup
 203              	DoGuestPageLookup:
 204              	.LFB3:
  95:guest.c       **** 
  96:guest.c       **** DWORD DoGuestPageLookup(DWORD GAddress)
  97:guest.c       **** {
 205              		.loc 1 97 0
 206              		.cfi_startproc
 207 012c 55       		push	ebp
 208              		.cfi_def_cfa_offset 8
 209              		.cfi_offset 5, -8
 210 012d 89E5     		mov	ebp, esp
 211              		.cfi_def_cfa_register 5
 212 012f 57       		push	edi
 213 0130 56       		push	esi
 214 0131 53       		push	ebx
 215 0132 83EC3C   		sub	esp, 60
 216              		.cfi_offset 7, -12
 217              		.cfi_offset 6, -16
 218              		.cfi_offset 3, -20
  98:guest.c       ****     //If the guest is doing paging on its own (not nested paging) then we have to add the offset to
  99:guest.c       ****     DWORD guestMemOffset = (guest.vmcb->cr3 == guest.nonPagingCR3?0:guest.GuestMemStartAddress);
 219              		.loc 1 99 0
 220 0135 8B0D0400 		mov	ecx, DWORD PTR guest+4
 220      0000
 221 013b 8B995405 		mov	ebx, DWORD PTR [ecx+1364]
 221      0000
 222 0141 8B895005 		mov	ecx, DWORD PTR [ecx+1360]
 222      0000
 223 0147 8B351000 		mov	esi, DWORD PTR guest+16
 223      0000
 224 014d BF000000 		mov	edi, 0
 224      00
 225 0152 89D8     		mov	eax, ebx
 226 0154 31F8     		xor	eax, edi
 227 0156 31F1     		xor	ecx, esi
 228 0158 09C1     		or	ecx, eax
 229 015a 85C9     		test	ecx, ecx
 230 015c 7408     		je	.L8
 231              		.loc 1 99 0 is_stmt 0 discriminator 1
 232 015e 8B0D0800 		mov	ecx, DWORD PTR guest+8
 232      0000
 233 0164 EB05     		jmp	.L9
 234              	.L8:
 235              		.loc 1 99 0 discriminator 2
 236 0166 B9000000 		mov	ecx, 0
 236      00
 237              	.L9:
 238              		.loc 1 99 0 discriminator 4
 239 016b 894DE4   		mov	DWORD PTR [ebp-28], ecx
 100:guest.c       ****     if ((guest.vmcb->cr0 & 0x80000000) != 0x80000000)
 240              		.loc 1 100 0 is_stmt 1 discriminator 4
 241 016e 8B0D0400 		mov	ecx, DWORD PTR guest+4
 241      0000
 242 0174 8B995C05 		mov	ebx, DWORD PTR [ecx+1372]
 242      0000
 243 017a 8B895805 		mov	ecx, DWORD PTR [ecx+1368]
 243      0000
 244 0180 89C8     		mov	eax, ecx
 245 0182 25000000 		and	eax, -2147483648
 245      80
 246 0187 8945C0   		mov	DWORD PTR [ebp-64], eax
 247 018a 89D8     		mov	eax, ebx
 248 018c 83E000   		and	eax, 0
 249 018f 8945C4   		mov	DWORD PTR [ebp-60], eax
 250 0192 8B5DC0   		mov	ebx, DWORD PTR [ebp-64]
 251 0195 8B75C4   		mov	esi, DWORD PTR [ebp-60]
 252 0198 89D8     		mov	eax, ebx
 253 019a 09F0     		or	eax, esi
 254 019c 85C0     		test	eax, eax
 255 019e 7508     		jne	.L10
 101:guest.c       ****         return GAddress;
 256              		.loc 1 101 0
 257 01a0 8B4508   		mov	eax, DWORD PTR [ebp+8]
 258 01a3 E98B0000 		jmp	.L11
 258      00
 259              	.L10:
 102:guest.c       **** //    if (guestMemOffset > 0)
 103:guest.c       ****     DWORD PDirNum = ((GAddress & 0xFFFFF000) / 0x400000) * 4; //4 MB per page directory entry, *4 a
 260              		.loc 1 103 0
 261 01a8 8B4508   		mov	eax, DWORD PTR [ebp+8]
 262 01ab 2500F0FF 		and	eax, -4096
 262      FF
 263 01b0 C1E816   		shr	eax, 22
 264 01b3 C1E002   		sal	eax, 2
 265 01b6 8945E0   		mov	DWORD PTR [ebp-32], eax
 104:guest.c       ****     //Get the offset from the beginning of the page table where our entry resides.  i.e. 0x00007245
 105:guest.c       ****     //The division by 0x400 is shortcut for / 0x1000 * 4
 106:guest.c       ****     DWORD PTEntryNum = (( (GAddress % 0x400000 ) & 0xFFFFF000) / 0x400);
 266              		.loc 1 106 0
 267 01b9 8B4508   		mov	eax, DWORD PTR [ebp+8]
 268 01bc 2500F03F 		and	eax, 4190208
 268      00
 269 01c1 C1E80A   		shr	eax, 10
 270 01c4 8945DC   		mov	DWORD PTR [ebp-36], eax
 107:guest.c       ****     //Get the page table entry (i.e. 0x7245 = 0x00107007)
 108:guest.c       ****     DWORD PTPtr = guest.vmcb->cr3 + guestMemOffset  + PDirNum; //Get the pointer to the page direct
 271              		.loc 1 108 0
 272 01c7 A1040000 		mov	eax, DWORD PTR guest+4
 272      00
 273 01cc 8B905405 		mov	edx, DWORD PTR [eax+1364]
 273      0000
 274 01d2 8B805005 		mov	eax, DWORD PTR [eax+1360]
 274      0000
 275 01d8 89C2     		mov	edx, eax
 276 01da 8B45E4   		mov	eax, DWORD PTR [ebp-28]
 277 01dd 01C2     		add	edx, eax
 278 01df 8B45E0   		mov	eax, DWORD PTR [ebp-32]
 279 01e2 01D0     		add	eax, edx
 280 01e4 8945D8   		mov	DWORD PTR [ebp-40], eax
 109:guest.c       ****     //Get the page table entry (i.e. 0x7245 = 0x00107007)
 110:guest.c       ****     DWORD PDirEntry = GetMemD( (PTPtr) ,false) + guestMemOffset; 
 281              		.loc 1 110 0
 282 01e7 83EC08   		sub	esp, 8
 283 01ea 6A00     		push	0
 284 01ec FF75D8   		push	DWORD PTR [ebp-40]
 285 01ef E8FCFFFF 		call	GetMemD
 285      FF
 286 01f4 83C410   		add	esp, 16
 287 01f7 89C2     		mov	edx, eax
 288 01f9 8B45E4   		mov	eax, DWORD PTR [ebp-28]
 289 01fc 01D0     		add	eax, edx
 290 01fe 8945D4   		mov	DWORD PTR [ebp-44], eax
 111:guest.c       ****     //Strip off the properties (i.e. 0x00107007 = 0x00107000)
 112:guest.c       ****     DWORD PTEntry = GetMemD( (PDirEntry & 0xFFFFF000) + PTEntryNum, false) ;
 291              		.loc 1 112 0
 292 0201 8B45D4   		mov	eax, DWORD PTR [ebp-44]
 293 0204 2500F0FF 		and	eax, -4096
 293      FF
 294 0209 89C2     		mov	edx, eax
 295 020b 8B45DC   		mov	eax, DWORD PTR [ebp-36]
 296 020e 01D0     		add	eax, edx
 297 0210 83EC08   		sub	esp, 8
 298 0213 6A00     		push	0
 299 0215 50       		push	eax
 300 0216 E8FCFFFF 		call	GetMemD
 300      FF
 301 021b 83C410   		add	esp, 16
 302 021e 8945D0   		mov	DWORD PTR [ebp-48], eax
 113:guest.c       ****     PTEntry &= 0xFFFFF000;
 303              		.loc 1 113 0
 304 0221 8165D000 		and	DWORD PTR [ebp-48], -4096
 304      F0FFFF
 114:guest.c       ****     //Add the pageoffset as we return the result i.e. 0x00107000 = 0x00107245
 115:guest.c       ****     return PTEntry | (GAddress & 0x00000FFF);
 305              		.loc 1 115 0
 306 0228 8B4508   		mov	eax, DWORD PTR [ebp+8]
 307 022b 25FF0F00 		and	eax, 4095
 307      00
 308 0230 0B45D0   		or	eax, DWORD PTR [ebp-48]
 309              	.L11:
 116:guest.c       **** }
 310              		.loc 1 116 0
 311 0233 8D65F4   		lea	esp, [ebp-12]
 312 0236 5B       		pop	ebx
 313              		.cfi_restore 3
 314 0237 5E       		pop	esi
 315              		.cfi_restore 6
 316 0238 5F       		pop	edi
 317              		.cfi_restore 7
 318 0239 5D       		pop	ebp
 319              		.cfi_restore 5
 320              		.cfi_def_cfa 4, 4
 321 023a C3       		ret
 322              		.cfi_endproc
 323              	.LFE3:
 325              		.globl	DoNestedPageLookup
 327              	DoNestedPageLookup:
 328              	.LFB4:
 117:guest.c       **** 
 118:guest.c       **** DWORD DoNestedPageLookup(DWORD GAddress)
 119:guest.c       **** {
 329              		.loc 1 119 0
 330              		.cfi_startproc
 331 023b 55       		push	ebp
 332              		.cfi_def_cfa_offset 8
 333              		.cfi_offset 5, -8
 334 023c 89E5     		mov	ebp, esp
 335              		.cfi_def_cfa_register 5
 336 023e 83EC28   		sub	esp, 40
 120:guest.c       **** //    if (guest.vmcb->np_enable)
 121:guest.c       ****     DWORD GuestPhys = DoGuestPageLookup(GAddress); 
 337              		.loc 1 121 0
 338 0241 83EC0C   		sub	esp, 12
 339 0244 FF7508   		push	DWORD PTR [ebp+8]
 340 0247 E8FCFFFF 		call	DoGuestPageLookup
 340      FF
 341 024c 83C410   		add	esp, 16
 342 024f 8945F4   		mov	DWORD PTR [ebp-12], eax
 122:guest.c       **** 
 123:guest.c       ****     if (guest.vmcb->np_enable)
 343              		.loc 1 123 0
 344 0252 A1040000 		mov	eax, DWORD PTR guest+4
 344      00
 345 0257 8B909400 		mov	edx, DWORD PTR [eax+148]
 345      0000
 346 025d 8B809000 		mov	eax, DWORD PTR [eax+144]
 346      0000
 347 0263 09D0     		or	eax, edx
 348 0265 85C0     		test	eax, eax
 349 0267 0F848100 		je	.L13
 349      0000
 350              	.LBB2:
 124:guest.c       ****     {
 125:guest.c       ****         DWORD PDirNum = ((GuestPhys & 0xFFFFF000) / 0x400000) * 4; //4 MB per page directory entry,
 351              		.loc 1 125 0
 352 026d 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 353 0270 2500F0FF 		and	eax, -4096
 353      FF
 354 0275 C1E816   		shr	eax, 22
 355 0278 C1E002   		sal	eax, 2
 356 027b 8945F0   		mov	DWORD PTR [ebp-16], eax
 126:guest.c       ****         //Get the offset from the beginning of the page table where our entry resides.  i.e. 0x0000
 127:guest.c       ****         //The division by 0x400 is shortcut for / 0x1000 * 4
 128:guest.c       ****         DWORD PTEntryNum = (( (GuestPhys % 0x400000) & 0xFFFFF000) / 0x400);
 357              		.loc 1 128 0
 358 027e 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 359 0281 2500F03F 		and	eax, 4190208
 359      00
 360 0286 C1E80A   		shr	eax, 10
 361 0289 8945EC   		mov	DWORD PTR [ebp-20], eax
 129:guest.c       ****         //Get the page table entry (i.e. 0x7245 = 0x00107007)
 130:guest.c       ****         DWORD PTPtr = guest.vmcb->nested_cr3 + PDirNum; //Get the pointer to the page directory ent
 362              		.loc 1 130 0
 363 028c A1040000 		mov	eax, DWORD PTR guest+4
 363      00
 364 0291 8B90B400 		mov	edx, DWORD PTR [eax+180]
 364      0000
 365 0297 8B80B000 		mov	eax, DWORD PTR [eax+176]
 365      0000
 366 029d 89C2     		mov	edx, eax
 367 029f 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 368 02a2 01D0     		add	eax, edx
 369 02a4 8945E8   		mov	DWORD PTR [ebp-24], eax
 131:guest.c       ****         //Get the page table entry (i.e. 0x7245 = 0x00107007)
 132:guest.c       ****         DWORD PDirEntry = GetMemD( (PTPtr),false); 
 370              		.loc 1 132 0
 371 02a7 83EC08   		sub	esp, 8
 372 02aa 6A00     		push	0
 373 02ac FF75E8   		push	DWORD PTR [ebp-24]
 374 02af E8FCFFFF 		call	GetMemD
 374      FF
 375 02b4 83C410   		add	esp, 16
 376 02b7 8945E4   		mov	DWORD PTR [ebp-28], eax
 133:guest.c       ****         //Strip off the properties (i.e. 0x00107007 = 0x00107000)
 134:guest.c       ****         DWORD PTEntry = GetMemD( (PDirEntry & 0xFFFFF000) + PTEntryNum, false) ;
 377              		.loc 1 134 0
 378 02ba 8B45E4   		mov	eax, DWORD PTR [ebp-28]
 379 02bd 2500F0FF 		and	eax, -4096
 379      FF
 380 02c2 89C2     		mov	edx, eax
 381 02c4 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 382 02c7 01D0     		add	eax, edx
 383 02c9 83EC08   		sub	esp, 8
 384 02cc 6A00     		push	0
 385 02ce 50       		push	eax
 386 02cf E8FCFFFF 		call	GetMemD
 386      FF
 387 02d4 83C410   		add	esp, 16
 388 02d7 8945E0   		mov	DWORD PTR [ebp-32], eax
 135:guest.c       ****         PTEntry &= 0xFFFFF000;
 389              		.loc 1 135 0
 390 02da 8165E000 		and	DWORD PTR [ebp-32], -4096
 390      F0FFFF
 136:guest.c       ****         //Add the pageoffset as we return the result i.e. 0x00107000 = 0x00107245
 137:guest.c       ****         return PTEntry | (GAddress & 0x00000FFF);
 391              		.loc 1 137 0
 392 02e1 8B4508   		mov	eax, DWORD PTR [ebp+8]
 393 02e4 25FF0F00 		and	eax, 4095
 393      00
 394 02e9 0B45E0   		or	eax, DWORD PTR [ebp-32]
 395 02ec EB03     		jmp	.L14
 396              	.L13:
 397              	.LBE2:
 138:guest.c       ****     }
 139:guest.c       ****     else
 140:guest.c       ****     {
 141:guest.c       ****         return GuestPhys;
 398              		.loc 1 141 0
 399 02ee 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 400              	.L14:
 142:guest.c       ****     }
 143:guest.c       **** }
 401              		.loc 1 143 0
 402 02f1 C9       		leave
 403              		.cfi_restore 5
 404              		.cfi_def_cfa 4, 4
 405 02f2 C3       		ret
 406              		.cfi_endproc
 407              	.LFE4:
 409              		.globl	CaptureInterruptDetails
 411              	CaptureInterruptDetails:
 412              	.LFB5:
 144:guest.c       **** 
 145:guest.c       **** void CaptureInterruptDetails(BYTE vector)
 146:guest.c       **** {
 413              		.loc 1 146 0
 414              		.cfi_startproc
 415 02f3 55       		push	ebp
 416              		.cfi_def_cfa_offset 8
 417              		.cfi_offset 5, -8
 418 02f4 89E5     		mov	ebp, esp
 419              		.cfi_def_cfa_register 5
 420 02f6 83EC08   		sub	esp, 8
 421 02f9 8B4508   		mov	eax, DWORD PTR [ebp+8]
 422 02fc 8845FC   		mov	BYTE PTR [ebp-4], al
 147:guest.c       ****     IntDetails[IntDetailsPtr].IntNum = vector;
 423              		.loc 1 147 0
 424 02ff A1000000 		mov	eax, DWORD PTR IntDetails
 424      00
 425 0304 8B150000 		mov	edx, DWORD PTR IntDetailsPtr
 425      0000
 426 030a C1E204   		sal	edx, 4
 427 030d 01C2     		add	edx, eax
 428 030f 0FB645FC 		movzx	eax, BYTE PTR [ebp-4]
 429 0313 668902   		mov	WORD PTR [edx], ax
 148:guest.c       ****     IntDetails[IntDetailsPtr].AXVal = guest.vmcb->rax;
 430              		.loc 1 148 0
 431 0316 A1000000 		mov	eax, DWORD PTR IntDetails
 431      00
 432 031b 8B150000 		mov	edx, DWORD PTR IntDetailsPtr
 432      0000
 433 0321 C1E204   		sal	edx, 4
 434 0324 8D0C10   		lea	ecx, [eax+edx]
 435 0327 A1040000 		mov	eax, DWORD PTR guest+4
 435      00
 436 032c 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 436      0000
 437 0332 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 437      0000
 438 0338 66894102 		mov	WORD PTR [ecx+2], ax
 149:guest.c       ****     IntDetails[IntDetailsPtr].BXVal = GuestRegisters[0];
 439              		.loc 1 149 0
 440 033c A1000000 		mov	eax, DWORD PTR IntDetails
 440      00
 441 0341 8B150000 		mov	edx, DWORD PTR IntDetailsPtr
 441      0000
 442 0347 C1E204   		sal	edx, 4
 443 034a 01D0     		add	eax, edx
 444 034c 8B150000 		mov	edx, DWORD PTR GuestRegisters
 444      0000
 445 0352 66895004 		mov	WORD PTR [eax+4], dx
 150:guest.c       ****     IntDetails[IntDetailsPtr].ESVal = guest.vmcb->es.sel;	
 446              		.loc 1 150 0
 447 0356 A1000000 		mov	eax, DWORD PTR IntDetails
 447      00
 448 035b 8B150000 		mov	edx, DWORD PTR IntDetailsPtr
 448      0000
 449 0361 C1E204   		sal	edx, 4
 450 0364 01C2     		add	edx, eax
 451 0366 A1040000 		mov	eax, DWORD PTR guest+4
 451      00
 452 036b 0FB78000 		movzx	eax, WORD PTR [eax+1024]
 452      040000
 453 0372 66894206 		mov	WORD PTR [edx+6], ax
 151:guest.c       ****     IntDetails[IntDetailsPtr].CSVal = guest.vmcb->cs.base;
 454              		.loc 1 151 0
 455 0376 A1000000 		mov	eax, DWORD PTR IntDetails
 455      00
 456 037b 8B150000 		mov	edx, DWORD PTR IntDetailsPtr
 456      0000
 457 0381 C1E204   		sal	edx, 4
 458 0384 8D0C10   		lea	ecx, [eax+edx]
 459 0387 A1040000 		mov	eax, DWORD PTR guest+4
 459      00
 460 038c 8B901C04 		mov	edx, DWORD PTR [eax+1052]
 460      0000
 461 0392 8B801804 		mov	eax, DWORD PTR [eax+1048]
 461      0000
 462 0398 66894108 		mov	WORD PTR [ecx+8], ax
 152:guest.c       ****     IntDetails[IntDetailsPtr].IPVal = guest.vmcb->rip;
 463              		.loc 1 152 0
 464 039c A1000000 		mov	eax, DWORD PTR IntDetails
 464      00
 465 03a1 8B150000 		mov	edx, DWORD PTR IntDetailsPtr
 465      0000
 466 03a7 C1E204   		sal	edx, 4
 467 03aa 8D0C10   		lea	ecx, [eax+edx]
 468 03ad A1040000 		mov	eax, DWORD PTR guest+4
 468      00
 469 03b2 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 469      0000
 470 03b8 8B807805 		mov	eax, DWORD PTR [eax+1400]
 470      0000
 471 03be 6689410A 		mov	WORD PTR [ecx+10], ax
 153:guest.c       ****     
 154:guest.c       **** }
 472              		.loc 1 154 0
 473 03c2 90       		nop
 474 03c3 C9       		leave
 475              		.cfi_restore 5
 476              		.cfi_def_cfa 4, 4
 477 03c4 C3       		ret
 478              		.cfi_endproc
 479              	.LFE5:
 481              		.globl	HandleRealModeSWInterrupt
 483              	HandleRealModeSWInterrupt:
 484              	.LFB6:
 155:guest.c       **** 
 156:guest.c       **** void HandleRealModeSWInterrupt(BYTE vector)
 157:guest.c       **** {
 485              		.loc 1 157 0
 486              		.cfi_startproc
 487 03c5 55       		push	ebp
 488              		.cfi_def_cfa_offset 8
 489              		.cfi_offset 5, -8
 490 03c6 89E5     		mov	ebp, esp
 491              		.cfi_def_cfa_register 5
 492 03c8 57       		push	edi
 493 03c9 56       		push	esi
 494 03ca 53       		push	ebx
 495 03cb 81EC8400 		sub	esp, 132
 495      0000
 496              		.cfi_offset 7, -12
 497              		.cfi_offset 6, -16
 498              		.cfi_offset 3, -20
 499 03d1 8B4508   		mov	eax, DWORD PTR [ebp+8]
 500 03d4 8845EC   		mov	BYTE PTR [ebp-20], al
 158:guest.c       **** //	if ((vector == 0x8) || (vector == 0x0) || (vector == 0x1c) || (vector==0x10) || (vector == 0x16)
 159:guest.c       **** //	{
 160:guest.c       **** //		UpdateGuestForSoftwareInterrupt(vector);
 161:guest.c       **** //		return;
 162:guest.c       **** //	}
 163:guest.c       **** 
 164:guest.c       ****         //CaptureInterruptDetails(vector);
 165:guest.c       ****         //Do something based on the interrupt #
 166:guest.c       **** 	switch (vector)
 501              		.loc 1 166 0
 502 03d7 0FB645EC 		movzx	eax, BYTE PTR [ebp-20]
 503 03db 83F812   		cmp	eax, 18
 504 03de 7440     		je	.L18
 505 03e0 83F812   		cmp	eax, 18
 506 03e3 7F0A     		jg	.L19
 507 03e5 83F811   		cmp	eax, 17
 508 03e8 7418     		je	.L20
 509 03ea E9050500 		jmp	.L17
 509      00
 510              	.L19:
 511 03ef 83F813   		cmp	eax, 19
 512 03f2 744A     		je	.L21
 513 03f4 83F815   		cmp	eax, 21
 514 03f7 0F846201 		je	.L22
 514      0000
 515 03fd E9F20400 		jmp	.L17
 515      00
 516              	.L20:
 167:guest.c       **** 	{
 168:guest.c       **** 		case 0x11:	//GET EQUIPMENT LIST
 169:guest.c       **** 			guest.vmcb->rax = 0x0122;  //only video mode & 80x87 & DMA set  100100010
 517              		.loc 1 169 0
 518 0402 A1040000 		mov	eax, DWORD PTR guest+4
 518      00
 519 0407 C780F805 		mov	DWORD PTR [eax+1528], 290
 519      00002201 
 519      0000
 520 0411 C780FC05 		mov	DWORD PTR [eax+1532], 0
 520      00000000 
 520      0000
 170:guest.c       **** 			break;
 521              		.loc 1 170 0
 522 041b E94F0500 		jmp	.L23
 522      00
 523              	.L18:
 171:guest.c       **** 		case 0x12:
 172:guest.c       **** 			guest.vmcb->rax = 0x27f;	//4 MB of ram installed - mem size / 1k
 524              		.loc 1 172 0
 525 0420 A1040000 		mov	eax, DWORD PTR guest+4
 525      00
 526 0425 C780F805 		mov	DWORD PTR [eax+1528], 639
 526      00007F02 
 526      0000
 527 042f C780FC05 		mov	DWORD PTR [eax+1532], 0
 527      00000000 
 527      0000
 173:guest.c       **** 			break;
 528              		.loc 1 173 0
 529 0439 E9310500 		jmp	.L23
 529      00
 530              	.L21:
 174:guest.c       **** 		case 0x13:
 175:guest.c       **** 			//GuestInt13Handler(); //CLR 09/21/2014 - Finding out if this is broken
 176:guest.c       **** 			if ( (guest.vmcb->rax & 0x0F00) == 0x0800)
 531              		.loc 1 176 0
 532 043e A1040000 		mov	eax, DWORD PTR guest+4
 532      00
 533 0443 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 533      0000
 534 0449 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 534      0000
 535 044f 89C7     		mov	edi, eax
 536 0451 81E7000F 		and	edi, 3840
 536      0000
 537 0457 89F9     		mov	ecx, edi
 538 0459 89D0     		mov	eax, edx
 539 045b 83E000   		and	eax, 0
 540 045e 89C3     		mov	ebx, eax
 541 0460 89C8     		mov	eax, ecx
 542 0462 80F408   		xor	ah, 8
 543 0465 09D8     		or	eax, ebx
 544 0467 85C0     		test	eax, eax
 545 0469 7575     		jne	.L24
 177:guest.c       **** 			{
 178:guest.c       **** 				guest.vmcb->rax = 0x0000;
 546              		.loc 1 178 0
 547 046b A1040000 		mov	eax, DWORD PTR guest+4
 547      00
 548 0470 C780F805 		mov	DWORD PTR [eax+1528], 0
 548      00000000 
 548      0000
 549 047a C780FC05 		mov	DWORD PTR [eax+1532], 0
 549      00000000 
 549      0000
 179:guest.c       ****                                 //thumb=BX=0,CX=03FF,DX=0F01
 180:guest.c       **** 				GuestRegisters[RAN_EBX] = 0x0000;
 550              		.loc 1 180 0
 551 0484 C7050000 		mov	DWORD PTR GuestRegisters, 0
 551      00000000 
 551      0000
 181:guest.c       ****                                                           //was 037f
 182:guest.c       **** 				GuestRegisters[RAN_ECX] = 0xFFFF;	//CH=low eight bits of maximum cylinder number, CL=high two b
 552              		.loc 1 182 0
 553 048e C7050400 		mov	DWORD PTR GuestRegisters+4, 65535
 553      0000FFFF 
 553      0000
 183:guest.c       **** 									//						   maximum sector number (bits 5-0) (0x80, 0x3f = BF)
 184:guest.c       **** 							  //was 0f01	//
 185:guest.c       **** 				GuestRegisters[RAN_EDX] = 0xFF01;	//DH = maximum head number, DL = number of drives
 554              		.loc 1 185 0
 555 0498 C7050800 		mov	DWORD PTR GuestRegisters+8, 65281
 555      000001FF 
 555      0000
 186:guest.c       **** 				CLEAR_GUEST_CARRY_FLAG;
 556              		.loc 1 186 0
 557 04a2 8B0D0400 		mov	ecx, DWORD PTR guest+4
 557      0000
 558 04a8 A1040000 		mov	eax, DWORD PTR guest+4
 558      00
 559 04ad 8B907405 		mov	edx, DWORD PTR [eax+1396]
 559      0000
 560 04b3 8B807005 		mov	eax, DWORD PTR [eax+1392]
 560      0000
 561 04b9 89C7     		mov	edi, eax
 562 04bb 83E7FE   		and	edi, -2
 563 04be 897DE0   		mov	DWORD PTR [ebp-32], edi
 564 04c1 89D0     		mov	eax, edx
 565 04c3 83E000   		and	eax, 0
 566 04c6 8945E4   		mov	DWORD PTR [ebp-28], eax
 567 04c9 8B45E0   		mov	eax, DWORD PTR [ebp-32]
 568 04cc 8B55E4   		mov	edx, DWORD PTR [ebp-28]
 569 04cf 89817005 		mov	DWORD PTR [ecx+1392], eax
 569      0000
 570 04d5 89917405 		mov	DWORD PTR [ecx+1396], edx
 570      0000
 187:guest.c       **** 			}
 188:guest.c       **** 			else
 189:guest.c       **** 			{
 190:guest.c       **** 				guest.vmcb->rip += 2;
 191:guest.c       ****                                 guest.vmcb->eventinj.fields.v = true;
 192:guest.c       ****                                 guest.vmcb->eventinj.fields.ev = false;
 193:guest.c       ****                                 guest.vmcb->eventinj.fields.type = 4;
 194:guest.c       ****                                 guest.vmcb->eventinj.fields.vector = vector;
 195:guest.c       **** 				//SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(0 << 11) | (DWORD)(4 << 8) | (BYTE
 196:guest.c       **** 			}
 197:guest.c       **** 			break;
 571              		.loc 1 197 0
 572 04db E98F0400 		jmp	.L23
 572      00
 573              	.L24:
 190:guest.c       ****                                 guest.vmcb->eventinj.fields.v = true;
 574              		.loc 1 190 0
 575 04e0 8B0D0400 		mov	ecx, DWORD PTR guest+4
 575      0000
 576 04e6 A1040000 		mov	eax, DWORD PTR guest+4
 576      00
 577 04eb 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 577      0000
 578 04f1 8B807805 		mov	eax, DWORD PTR [eax+1400]
 578      0000
 579 04f7 83C002   		add	eax, 2
 580 04fa 83D200   		adc	edx, 0
 581 04fd 89817805 		mov	DWORD PTR [ecx+1400], eax
 581      0000
 582 0503 89917C05 		mov	DWORD PTR [ecx+1404], edx
 582      0000
 191:guest.c       ****                                 guest.vmcb->eventinj.fields.ev = false;
 583              		.loc 1 191 0
 584 0509 A1040000 		mov	eax, DWORD PTR guest+4
 584      00
 585 050e 0FB690AB 		movzx	edx, BYTE PTR [eax+171]
 585      000000
 586 0515 83CA80   		or	edx, -128
 587 0518 8890AB00 		mov	BYTE PTR [eax+171], dl
 587      0000
 192:guest.c       ****                                 guest.vmcb->eventinj.fields.type = 4;
 588              		.loc 1 192 0
 589 051e A1040000 		mov	eax, DWORD PTR guest+4
 589      00
 590 0523 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 590      000000
 591 052a 83E2F7   		and	edx, -9
 592 052d 8890A900 		mov	BYTE PTR [eax+169], dl
 592      0000
 193:guest.c       ****                                 guest.vmcb->eventinj.fields.vector = vector;
 593              		.loc 1 193 0
 594 0533 A1040000 		mov	eax, DWORD PTR guest+4
 594      00
 595 0538 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 595      000000
 596 053f 83E2F8   		and	edx, -8
 597 0542 83CA04   		or	edx, 4
 598 0545 8890A900 		mov	BYTE PTR [eax+169], dl
 598      0000
 194:guest.c       **** 				//SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(0 << 11) | (DWORD)(4 << 8) | (BYTE
 599              		.loc 1 194 0
 600 054b A1040000 		mov	eax, DWORD PTR guest+4
 600      00
 601 0550 0FB655EC 		movzx	edx, BYTE PTR [ebp-20]
 602 0554 8890A800 		mov	BYTE PTR [eax+168], dl
 602      0000
 603              		.loc 1 197 0
 604 055a E9100400 		jmp	.L23
 604      00
 605              	.L22:
 198:guest.c       **** 		case 0x15:
 199:guest.c       **** 			if ( (guest.vmcb->rax & 0xFF00) == 0x8800)
 606              		.loc 1 199 0
 607 055f A1040000 		mov	eax, DWORD PTR guest+4
 607      00
 608 0564 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 608      0000
 609 056a 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 609      0000
 610 0570 89C7     		mov	edi, eax
 611 0572 81E700FF 		and	edi, 65280
 611      0000
 612 0578 897DD8   		mov	DWORD PTR [ebp-40], edi
 613 057b 89D0     		mov	eax, edx
 614 057d 83E000   		and	eax, 0
 615 0580 8945DC   		mov	DWORD PTR [ebp-36], eax
 616 0583 8B5DD8   		mov	ebx, DWORD PTR [ebp-40]
 617 0586 8B75DC   		mov	esi, DWORD PTR [ebp-36]
 618 0589 89D8     		mov	eax, ebx
 619 058b 80F488   		xor	ah, 136
 620 058e 09F0     		or	eax, esi
 621 0590 85C0     		test	eax, eax
 622 0592 0F858900 		jne	.L26
 622      0000
 200:guest.c       **** 			{
 201:guest.c       ****                             if (guest.memSize > 0x4000000)
 623              		.loc 1 201 0
 624 0598 A1000000 		mov	eax, DWORD PTR guest
 624      00
 625 059d 3D000000 		cmp	eax, 67108864
 625      04
 626 05a2 761B     		jbe	.L27
 202:guest.c       ****                                 guest.vmcb->rax = 0xFFFF; //0xC00
 627              		.loc 1 202 0
 628 05a4 A1040000 		mov	eax, DWORD PTR guest+4
 628      00
 629 05a9 C780F805 		mov	DWORD PTR [eax+1528], 65535
 629      0000FFFF 
 629      0000
 630 05b3 C780FC05 		mov	DWORD PTR [eax+1532], 0
 630      00000000 
 630      0000
 631 05bd EB24     		jmp	.L28
 632              	.L27:
 203:guest.c       ****                             else
 204:guest.c       ****                                 guest.vmcb->rax = (guest.memSize-0x100000) / 0x400; //0xC00
 633              		.loc 1 204 0
 634 05bf 8B0D0400 		mov	ecx, DWORD PTR guest+4
 634      0000
 635 05c5 A1000000 		mov	eax, DWORD PTR guest
 635      00
 636 05ca 2D000010 		sub	eax, 1048576
 636      00
 637 05cf C1E80A   		shr	eax, 10
 638 05d2 BA000000 		mov	edx, 0
 638      00
 639 05d7 8981F805 		mov	DWORD PTR [ecx+1528], eax
 639      0000
 640 05dd 8991FC05 		mov	DWORD PTR [ecx+1532], edx
 640      0000
 641              	.L28:
 205:guest.c       ****                             CLEAR_GUEST_CARRY_FLAG;
 642              		.loc 1 205 0
 643 05e3 8B0D0400 		mov	ecx, DWORD PTR guest+4
 643      0000
 644 05e9 A1040000 		mov	eax, DWORD PTR guest+4
 644      00
 645 05ee 8B907405 		mov	edx, DWORD PTR [eax+1396]
 645      0000
 646 05f4 8B807005 		mov	eax, DWORD PTR [eax+1392]
 646      0000
 647 05fa 89C7     		mov	edi, eax
 648 05fc 83E7FE   		and	edi, -2
 649 05ff 897DD0   		mov	DWORD PTR [ebp-48], edi
 650 0602 89D0     		mov	eax, edx
 651 0604 83E000   		and	eax, 0
 652 0607 8945D4   		mov	DWORD PTR [ebp-44], eax
 653 060a 8B45D0   		mov	eax, DWORD PTR [ebp-48]
 654 060d 8B55D4   		mov	edx, DWORD PTR [ebp-44]
 655 0610 89817005 		mov	DWORD PTR [ecx+1392], eax
 655      0000
 656 0616 89917405 		mov	DWORD PTR [ecx+1396], edx
 656      0000
 206:guest.c       **** 			}
 207:guest.c       **** 			else if  ((guest.vmcb->rax & 0xFFFF) == 0xE820) 
 208:guest.c       **** 			{
 209:guest.c       ****                             guest.vmcb->rax = 0x8600 | (guest.vmcb->rax & 0xFFFF00FF);
 210:guest.c       ****                             SET_GUEST_CARRY_FLAG;
 211:guest.c       **** 			}
 212:guest.c       ****                         else if  (((guest.vmcb->rax & 0xFFFF) == 0xE801) || ((guest.vmcb->rax & 0xF
 213:guest.c       ****                                 || (((guest.vmcb->rax & 0xFF00) & 0x8A00) == 0x8A00) || (((guest.vm
 214:guest.c       **** 			{
 215:guest.c       ****                             guest.vmcb->rax = 0x8600 | (guest.vmcb->rax & 0xFFFF00FF);
 216:guest.c       ****                             SET_GUEST_CARRY_FLAG;
 217:guest.c       **** 			}
 218:guest.c       **** 			else
 219:guest.c       **** 			{
 220:guest.c       ****                             guest.vmcb->eventinj.fields.v = true;
 221:guest.c       ****                             guest.vmcb->eventinj.fields.ev = false;
 222:guest.c       ****                             guest.vmcb->eventinj.fields.type = 4;
 223:guest.c       ****                             guest.vmcb->eventinj.fields.vector = vector;
 224:guest.c       ****                             //SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(0 << 11) |
 225:guest.c       **** 			}
 226:guest.c       **** 			break;
 657              		.loc 1 226 0
 658 061c E94E0300 		jmp	.L23
 658      00
 659              	.L26:
 207:guest.c       **** 			{
 660              		.loc 1 207 0
 661 0621 A1040000 		mov	eax, DWORD PTR guest+4
 661      00
 662 0626 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 662      0000
 663 062c 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 663      0000
 664 0632 0FB7C8   		movzx	ecx, ax
 665 0635 894DC8   		mov	DWORD PTR [ebp-56], ecx
 666 0638 89D0     		mov	eax, edx
 667 063a 83E000   		and	eax, 0
 668 063d 8945CC   		mov	DWORD PTR [ebp-52], eax
 669 0640 8B5DC8   		mov	ebx, DWORD PTR [ebp-56]
 670 0643 8B75CC   		mov	esi, DWORD PTR [ebp-52]
 671 0646 89D8     		mov	eax, ebx
 672 0648 3520E800 		xor	eax, 59424
 672      00
 673 064d 09F0     		or	eax, esi
 674 064f 85C0     		test	eax, eax
 675 0651 0F859300 		jne	.L30
 675      0000
 209:guest.c       ****                             SET_GUEST_CARRY_FLAG;
 676              		.loc 1 209 0
 677 0657 8B0D0400 		mov	ecx, DWORD PTR guest+4
 677      0000
 678 065d A1040000 		mov	eax, DWORD PTR guest+4
 678      00
 679 0662 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 679      0000
 680 0668 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 680      0000
 681 066e 89C7     		mov	edi, eax
 682 0670 81E7FF00 		and	edi, -65281
 682      FFFF
 683 0676 897DC0   		mov	DWORD PTR [ebp-64], edi
 684 0679 89D0     		mov	eax, edx
 685 067b 83E000   		and	eax, 0
 686 067e 8945C4   		mov	DWORD PTR [ebp-60], eax
 687 0681 8B45C0   		mov	eax, DWORD PTR [ebp-64]
 688 0684 8B55C4   		mov	edx, DWORD PTR [ebp-60]
 689 0687 89C7     		mov	edi, eax
 690 0689 81CF0086 		or	edi, 34304
 690      0000
 691 068f 897DB8   		mov	DWORD PTR [ebp-72], edi
 692 0692 89D0     		mov	eax, edx
 693 0694 80CC00   		or	ah, 0
 694 0697 8945BC   		mov	DWORD PTR [ebp-68], eax
 695 069a 8B45B8   		mov	eax, DWORD PTR [ebp-72]
 696 069d 8B55BC   		mov	edx, DWORD PTR [ebp-68]
 697 06a0 8981F805 		mov	DWORD PTR [ecx+1528], eax
 697      0000
 698 06a6 8991FC05 		mov	DWORD PTR [ecx+1532], edx
 698      0000
 210:guest.c       **** 			}
 699              		.loc 1 210 0
 700 06ac 8B0D0400 		mov	ecx, DWORD PTR guest+4
 700      0000
 701 06b2 A1040000 		mov	eax, DWORD PTR guest+4
 701      00
 702 06b7 8B907405 		mov	edx, DWORD PTR [eax+1396]
 702      0000
 703 06bd 8B807005 		mov	eax, DWORD PTR [eax+1392]
 703      0000
 704 06c3 89C7     		mov	edi, eax
 705 06c5 83CF01   		or	edi, 1
 706 06c8 897DB0   		mov	DWORD PTR [ebp-80], edi
 707 06cb 89D0     		mov	eax, edx
 708 06cd 80CC00   		or	ah, 0
 709 06d0 8945B4   		mov	DWORD PTR [ebp-76], eax
 710 06d3 8B45B0   		mov	eax, DWORD PTR [ebp-80]
 711 06d6 8B55B4   		mov	edx, DWORD PTR [ebp-76]
 712 06d9 89817005 		mov	DWORD PTR [ecx+1392], eax
 712      0000
 713 06df 89917405 		mov	DWORD PTR [ecx+1396], edx
 713      0000
 714              		.loc 1 226 0
 715 06e5 E9850200 		jmp	.L23
 715      00
 716              	.L30:
 212:guest.c       ****                                 || (((guest.vmcb->rax & 0xFF00) & 0x8A00) == 0x8A00) || (((guest.vm
 717              		.loc 1 212 0
 718 06ea A1040000 		mov	eax, DWORD PTR guest+4
 718      00
 719 06ef 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 719      0000
 720 06f5 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 720      0000
 721 06fb 0FB7C8   		movzx	ecx, ax
 722 06fe 894DA8   		mov	DWORD PTR [ebp-88], ecx
 723 0701 89D0     		mov	eax, edx
 724 0703 83E000   		and	eax, 0
 725 0706 8945AC   		mov	DWORD PTR [ebp-84], eax
 726 0709 8B5DA8   		mov	ebx, DWORD PTR [ebp-88]
 727 070c 8B75AC   		mov	esi, DWORD PTR [ebp-84]
 728 070f 89D8     		mov	eax, ebx
 729 0711 3501E800 		xor	eax, 59393
 729      00
 730 0716 09F0     		or	eax, esi
 731 0718 85C0     		test	eax, eax
 732 071a 0F84D600 		je	.L31
 732      0000
 212:guest.c       ****                                 || (((guest.vmcb->rax & 0xFF00) & 0x8A00) == 0x8A00) || (((guest.vm
 733              		.loc 1 212 0 is_stmt 0 discriminator 1
 734 0720 A1040000 		mov	eax, DWORD PTR guest+4
 734      00
 735 0725 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 735      0000
 736 072b 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 736      0000
 737 0731 0FB7F0   		movzx	esi, ax
 738 0734 8975A0   		mov	DWORD PTR [ebp-96], esi
 739 0737 89D0     		mov	eax, edx
 740 0739 83E000   		and	eax, 0
 741 073c 8945A4   		mov	DWORD PTR [ebp-92], eax
 742 073f 8B5DA0   		mov	ebx, DWORD PTR [ebp-96]
 743 0742 8B75A4   		mov	esi, DWORD PTR [ebp-92]
 744 0745 89D8     		mov	eax, ebx
 745 0747 3581E800 		xor	eax, 59521
 745      00
 746 074c 09F0     		or	eax, esi
 747 074e 85C0     		test	eax, eax
 748 0750 0F84A000 		je	.L31
 748      0000
 212:guest.c       ****                                 || (((guest.vmcb->rax & 0xFF00) & 0x8A00) == 0x8A00) || (((guest.vm
 749              		.loc 1 212 0 discriminator 2
 750 0756 A1040000 		mov	eax, DWORD PTR guest+4
 750      00
 751 075b 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 751      0000
 752 0761 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 752      0000
 753 0767 0FB7F8   		movzx	edi, ax
 754 076a 897D98   		mov	DWORD PTR [ebp-104], edi
 755 076d 89D0     		mov	eax, edx
 756 076f 83E000   		and	eax, 0
 757 0772 89459C   		mov	DWORD PTR [ebp-100], eax
 758 0775 8B5D98   		mov	ebx, DWORD PTR [ebp-104]
 759 0778 8B759C   		mov	esi, DWORD PTR [ebp-100]
 760 077b 89D8     		mov	eax, ebx
 761 077d 3588DA00 		xor	eax, 55944
 761      00
 762 0782 09F0     		or	eax, esi
 763 0784 85C0     		test	eax, eax
 764 0786 746E     		je	.L31
 213:guest.c       **** 			{
 765              		.loc 1 213 0 is_stmt 1
 766 0788 A1040000 		mov	eax, DWORD PTR guest+4
 766      00
 767 078d 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 767      0000
 768 0793 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 768      0000
 769 0799 89C7     		mov	edi, eax
 770 079b 81E7008A 		and	edi, 35328
 770      0000
 771 07a1 897D90   		mov	DWORD PTR [ebp-112], edi
 772 07a4 89D0     		mov	eax, edx
 773 07a6 83E000   		and	eax, 0
 774 07a9 894594   		mov	DWORD PTR [ebp-108], eax
 775 07ac 8B5D90   		mov	ebx, DWORD PTR [ebp-112]
 776 07af 8B7594   		mov	esi, DWORD PTR [ebp-108]
 777 07b2 89D8     		mov	eax, ebx
 778 07b4 80F48A   		xor	ah, 138
 779 07b7 09F0     		or	eax, esi
 780 07b9 85C0     		test	eax, eax
 781 07bb 7439     		je	.L31
 213:guest.c       **** 			{
 782              		.loc 1 213 0 is_stmt 0 discriminator 1
 783 07bd A1040000 		mov	eax, DWORD PTR guest+4
 783      00
 784 07c2 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 784      0000
 785 07c8 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 785      0000
 786 07ce 89C3     		mov	ebx, eax
 787 07d0 81E300C7 		and	ebx, 50944
 787      0000
 788 07d6 895D88   		mov	DWORD PTR [ebp-120], ebx
 789 07d9 89D0     		mov	eax, edx
 790 07db 83E000   		and	eax, 0
 791 07de 89458C   		mov	DWORD PTR [ebp-116], eax
 792 07e1 8B5D88   		mov	ebx, DWORD PTR [ebp-120]
 793 07e4 8B758C   		mov	esi, DWORD PTR [ebp-116]
 794 07e7 89D8     		mov	eax, ebx
 795 07e9 80F4C7   		xor	ah, 199
 796 07ec 09F0     		or	eax, esi
 797 07ee 85C0     		test	eax, eax
 798 07f0 0F85AB00 		jne	.L32
 798      0000
 799              	.L31:
 215:guest.c       ****                             SET_GUEST_CARRY_FLAG;
 800              		.loc 1 215 0 is_stmt 1
 801 07f6 8B0D0400 		mov	ecx, DWORD PTR guest+4
 801      0000
 802 07fc A1040000 		mov	eax, DWORD PTR guest+4
 802      00
 803 0801 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 803      0000
 804 0807 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 804      0000
 805 080d 89C6     		mov	esi, eax
 806 080f 81E6FF00 		and	esi, -65281
 806      FFFF
 807 0815 897580   		mov	DWORD PTR [ebp-128], esi
 808 0818 89D0     		mov	eax, edx
 809 081a 83E000   		and	eax, 0
 810 081d 894584   		mov	DWORD PTR [ebp-124], eax
 811 0820 8B4580   		mov	eax, DWORD PTR [ebp-128]
 812 0823 8B5584   		mov	edx, DWORD PTR [ebp-124]
 813 0826 89C7     		mov	edi, eax
 814 0828 81CF0086 		or	edi, 34304
 814      0000
 815 082e 89BD78FF 		mov	DWORD PTR [ebp-136], edi
 815      FFFF
 816 0834 89D0     		mov	eax, edx
 817 0836 80CC00   		or	ah, 0
 818 0839 89857CFF 		mov	DWORD PTR [ebp-132], eax
 818      FFFF
 819 083f 8B8578FF 		mov	eax, DWORD PTR [ebp-136]
 819      FFFF
 820 0845 8B957CFF 		mov	edx, DWORD PTR [ebp-132]
 820      FFFF
 821 084b 8981F805 		mov	DWORD PTR [ecx+1528], eax
 821      0000
 822 0851 8991FC05 		mov	DWORD PTR [ecx+1532], edx
 822      0000
 216:guest.c       **** 			}
 823              		.loc 1 216 0
 824 0857 8B0D0400 		mov	ecx, DWORD PTR guest+4
 824      0000
 825 085d A1040000 		mov	eax, DWORD PTR guest+4
 825      00
 826 0862 8B907405 		mov	edx, DWORD PTR [eax+1396]
 826      0000
 827 0868 8B807005 		mov	eax, DWORD PTR [eax+1392]
 827      0000
 828 086e 89C3     		mov	ebx, eax
 829 0870 83CB01   		or	ebx, 1
 830 0873 899D70FF 		mov	DWORD PTR [ebp-144], ebx
 830      FFFF
 831 0879 89D0     		mov	eax, edx
 832 087b 80CC00   		or	ah, 0
 833 087e 898574FF 		mov	DWORD PTR [ebp-140], eax
 833      FFFF
 834 0884 8B8570FF 		mov	eax, DWORD PTR [ebp-144]
 834      FFFF
 835 088a 8B9574FF 		mov	edx, DWORD PTR [ebp-140]
 835      FFFF
 836 0890 89817005 		mov	DWORD PTR [ecx+1392], eax
 836      0000
 837 0896 89917405 		mov	DWORD PTR [ecx+1396], edx
 837      0000
 838              		.loc 1 226 0
 839 089c E9CE0000 		jmp	.L23
 839      00
 840              	.L32:
 220:guest.c       ****                             guest.vmcb->eventinj.fields.ev = false;
 841              		.loc 1 220 0
 842 08a1 A1040000 		mov	eax, DWORD PTR guest+4
 842      00
 843 08a6 0FB690AB 		movzx	edx, BYTE PTR [eax+171]
 843      000000
 844 08ad 83CA80   		or	edx, -128
 845 08b0 8890AB00 		mov	BYTE PTR [eax+171], dl
 845      0000
 221:guest.c       ****                             guest.vmcb->eventinj.fields.type = 4;
 846              		.loc 1 221 0
 847 08b6 A1040000 		mov	eax, DWORD PTR guest+4
 847      00
 848 08bb 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 848      000000
 849 08c2 83E2F7   		and	edx, -9
 850 08c5 8890A900 		mov	BYTE PTR [eax+169], dl
 850      0000
 222:guest.c       ****                             guest.vmcb->eventinj.fields.vector = vector;
 851              		.loc 1 222 0
 852 08cb A1040000 		mov	eax, DWORD PTR guest+4
 852      00
 853 08d0 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 853      000000
 854 08d7 83E2F8   		and	edx, -8
 855 08da 83CA04   		or	edx, 4
 856 08dd 8890A900 		mov	BYTE PTR [eax+169], dl
 856      0000
 223:guest.c       ****                             //SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(0 << 11) |
 857              		.loc 1 223 0
 858 08e3 A1040000 		mov	eax, DWORD PTR guest+4
 858      00
 859 08e8 0FB655EC 		movzx	edx, BYTE PTR [ebp-20]
 860 08ec 8890A800 		mov	BYTE PTR [eax+168], dl
 860      0000
 861              		.loc 1 226 0
 862 08f2 EB7B     		jmp	.L23
 863              	.L17:
 227:guest.c       **** 		default:
 228:guest.c       **** 			{
 229:guest.c       ****                             guest.vmcb->rip += 2;
 864              		.loc 1 229 0
 865 08f4 8B0D0400 		mov	ecx, DWORD PTR guest+4
 865      0000
 866 08fa A1040000 		mov	eax, DWORD PTR guest+4
 866      00
 867 08ff 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 867      0000
 868 0905 8B807805 		mov	eax, DWORD PTR [eax+1400]
 868      0000
 869 090b 83C002   		add	eax, 2
 870 090e 83D200   		adc	edx, 0
 871 0911 89817805 		mov	DWORD PTR [ecx+1400], eax
 871      0000
 872 0917 89917C05 		mov	DWORD PTR [ecx+1404], edx
 872      0000
 230:guest.c       ****                             guest.vmcb->eventinj.fields.v = true;
 873              		.loc 1 230 0
 874 091d A1040000 		mov	eax, DWORD PTR guest+4
 874      00
 875 0922 0FB690AB 		movzx	edx, BYTE PTR [eax+171]
 875      000000
 876 0929 83CA80   		or	edx, -128
 877 092c 8890AB00 		mov	BYTE PTR [eax+171], dl
 877      0000
 231:guest.c       ****                             guest.vmcb->eventinj.fields.ev = false;
 878              		.loc 1 231 0
 879 0932 A1040000 		mov	eax, DWORD PTR guest+4
 879      00
 880 0937 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 880      000000
 881 093e 83E2F7   		and	edx, -9
 882 0941 8890A900 		mov	BYTE PTR [eax+169], dl
 882      0000
 232:guest.c       ****                             guest.vmcb->eventinj.fields.type = 4;
 883              		.loc 1 232 0
 884 0947 A1040000 		mov	eax, DWORD PTR guest+4
 884      00
 885 094c 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 885      000000
 886 0953 83E2F8   		and	edx, -8
 887 0956 83CA04   		or	edx, 4
 888 0959 8890A900 		mov	BYTE PTR [eax+169], dl
 888      0000
 233:guest.c       ****                             guest.vmcb->eventinj.fields.vector = vector;
 889              		.loc 1 233 0
 890 095f A1040000 		mov	eax, DWORD PTR guest+4
 890      00
 891 0964 0FB655EC 		movzx	edx, BYTE PTR [ebp-20]
 892 0968 8890A800 		mov	BYTE PTR [eax+168], dl
 892      0000
 234:guest.c       ****                             //SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(0 << 11) |
 235:guest.c       **** 			}
 236:guest.c       **** 			break;
 893              		.loc 1 236 0
 894 096e 90       		nop
 895              	.L23:
 237:guest.c       **** 	}
 238:guest.c       **** /*	if ( (vector != 0x13) && (vector != 0x21) )
 239:guest.c       **** 		IntDetailsPtr++;
 240:guest.c       **** */
 241:guest.c       **** }
 896              		.loc 1 241 0
 897 096f 90       		nop
 898 0970 81C48400 		add	esp, 132
 898      0000
 899 0976 5B       		pop	ebx
 900              		.cfi_restore 3
 901 0977 5E       		pop	esi
 902              		.cfi_restore 6
 903 0978 5F       		pop	edi
 904              		.cfi_restore 7
 905 0979 5D       		pop	ebp
 906              		.cfi_restore 5
 907              		.cfi_def_cfa 4, 4
 908 097a C3       		ret
 909              		.cfi_endproc
 910              	.LFE6:
 912              		.globl	PopCSIPFlagsOffGuestStackReal16
 914              	PopCSIPFlagsOffGuestStackReal16:
 915              	.LFB7:
 242:guest.c       **** 
 243:guest.c       **** void PopCSIPFlagsOffGuestStackReal16()
 244:guest.c       **** {
 916              		.loc 1 244 0
 917              		.cfi_startproc
 918 097b 55       		push	ebp
 919              		.cfi_def_cfa_offset 8
 920              		.cfi_offset 5, -8
 921 097c 89E5     		mov	ebp, esp
 922              		.cfi_def_cfa_register 5
 923 097e 83EC18   		sub	esp, 24
 245:guest.c       **** 	DWORD GuestStackAddressBeforePop = guest.vmcb->ss.sel;
 924              		.loc 1 245 0
 925 0981 A1040000 		mov	eax, DWORD PTR guest+4
 925      00
 926 0986 0FB78020 		movzx	eax, WORD PTR [eax+1056]
 926      040000
 927 098d 0FB7C0   		movzx	eax, ax
 928 0990 8945F4   		mov	DWORD PTR [ebp-12], eax
 246:guest.c       **** 	 GuestStackAddressBeforePop += guest.vmcb->rsp;
 929              		.loc 1 246 0
 930 0993 A1040000 		mov	eax, DWORD PTR guest+4
 930      00
 931 0998 8B90DC05 		mov	edx, DWORD PTR [eax+1500]
 931      0000
 932 099e 8B80D805 		mov	eax, DWORD PTR [eax+1496]
 932      0000
 933 09a4 0145F4   		add	DWORD PTR [ebp-12], eax
 247:guest.c       **** 	DWORD lNewCS = 0, lNewIP = 0; //, lNewDS, lNewSS, lNewES, lNewGS, lNewFS;
 934              		.loc 1 247 0
 935 09a7 C745F000 		mov	DWORD PTR [ebp-16], 0
 935      000000
 936 09ae C745EC00 		mov	DWORD PTR [ebp-20], 0
 936      000000
 248:guest.c       **** //	DWORD lNewSP;
 249:guest.c       **** 	DWORD lNewFlags = 0;
 937              		.loc 1 249 0
 938 09b5 C745E800 		mov	DWORD PTR [ebp-24], 0
 938      000000
 250:guest.c       **** 	//Make sure the guest stack doesn't page fault
 251:guest.c       **** 	HandleGuestPagingException( GuestStackAddressBeforePop, 0x0);
 939              		.loc 1 251 0
 940 09bc 83EC08   		sub	esp, 8
 941 09bf 6A00     		push	0
 942 09c1 FF75F4   		push	DWORD PTR [ebp-12]
 943 09c4 E8FCFFFF 		call	HandleGuestPagingException
 943      FF
 944 09c9 83C410   		add	esp, 16
 252:guest.c       **** //CLR 09/14/2014 - Copied block from below to see if it helps my IRET
 253:guest.c       **** 		lNewFlags = GetMemW( GuestStackAddressBeforePop+4, true);
 945              		.loc 1 253 0
 946 09cc 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 947 09cf 83C004   		add	eax, 4
 948 09d2 83EC08   		sub	esp, 8
 949 09d5 6A01     		push	1
 950 09d7 50       		push	eax
 951 09d8 E8FCFFFF 		call	GetMemW
 951      FF
 952 09dd 83C410   		add	esp, 16
 953 09e0 0FB7C0   		movzx	eax, ax
 954 09e3 8945E8   		mov	DWORD PTR [ebp-24], eax
 254:guest.c       **** 		lNewFlags |= 0x200;		//Turn on interrupts
 955              		.loc 1 254 0
 956 09e6 814DE800 		or	DWORD PTR [ebp-24], 512
 956      020000
 255:guest.c       **** 		lNewFlags &= 0xFEFF;	//Turn off debug (single step)
 957              		.loc 1 255 0
 958 09ed 8165E8FF 		and	DWORD PTR [ebp-24], 65279
 958      FE0000
 256:guest.c       **** 		guest.vmcb->rflags = lNewFlags;
 959              		.loc 1 256 0
 960 09f4 8B0D0400 		mov	ecx, DWORD PTR guest+4
 960      0000
 961 09fa 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 962 09fd BA000000 		mov	edx, 0
 962      00
 963 0a02 89817005 		mov	DWORD PTR [ecx+1392], eax
 963      0000
 964 0a08 89917405 		mov	DWORD PTR [ecx+1396], edx
 964      0000
 257:guest.c       **** 		//CS:IP handling
 258:guest.c       **** 		lNewCS = GetMemW( GuestStackAddressBeforePop+2, true);
 965              		.loc 1 258 0
 966 0a0e 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 967 0a11 83C002   		add	eax, 2
 968 0a14 83EC08   		sub	esp, 8
 969 0a17 6A01     		push	1
 970 0a19 50       		push	eax
 971 0a1a E8FCFFFF 		call	GetMemW
 971      FF
 972 0a1f 83C410   		add	esp, 16
 973 0a22 0FB7C0   		movzx	eax, ax
 974 0a25 8945F0   		mov	DWORD PTR [ebp-16], eax
 259:guest.c       **** 		//SetVMCBW(VMCB_SAVE_STATE_CS, lNewCS);		//CLR 09/22/2014 - This was wrong!
 260:guest.c       **** 		guest.vmcb->cs.base = lNewCS << 4;
 975              		.loc 1 260 0
 976 0a28 8B0D0400 		mov	ecx, DWORD PTR guest+4
 976      0000
 977 0a2e 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 978 0a31 C1E004   		sal	eax, 4
 979 0a34 BA000000 		mov	edx, 0
 979      00
 980 0a39 89811804 		mov	DWORD PTR [ecx+1048], eax
 980      0000
 981 0a3f 89911C04 		mov	DWORD PTR [ecx+1052], edx
 981      0000
 261:guest.c       **** 		lNewIP = GetMemW( GuestStackAddressBeforePop, true);
 982              		.loc 1 261 0
 983 0a45 83EC08   		sub	esp, 8
 984 0a48 6A01     		push	1
 985 0a4a FF75F4   		push	DWORD PTR [ebp-12]
 986 0a4d E8FCFFFF 		call	GetMemW
 986      FF
 987 0a52 83C410   		add	esp, 16
 988 0a55 0FB7C0   		movzx	eax, ax
 989 0a58 8945EC   		mov	DWORD PTR [ebp-20], eax
 262:guest.c       **** 		guest.vmcb->rip = lNewIP;
 990              		.loc 1 262 0
 991 0a5b 8B0D0400 		mov	ecx, DWORD PTR guest+4
 991      0000
 992 0a61 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 993 0a64 BA000000 		mov	edx, 0
 993      00
 994 0a69 89817805 		mov	DWORD PTR [ecx+1400], eax
 994      0000
 995 0a6f 89917C05 		mov	DWORD PTR [ecx+1404], edx
 995      0000
 263:guest.c       **** 		//Make sure the guest CS:IP doesnt' page fault
 264:guest.c       **** 		HandleGuestPagingException( ( (lNewCS) + lNewIP),0x0);
 996              		.loc 1 264 0
 997 0a75 8B55F0   		mov	edx, DWORD PTR [ebp-16]
 998 0a78 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 999 0a7b 01D0     		add	eax, edx
 1000 0a7d 83EC08   		sub	esp, 8
 1001 0a80 6A00     		push	0
 1002 0a82 50       		push	eax
 1003 0a83 E8FCFFFF 		call	HandleGuestPagingException
 1003      FF
 1004 0a88 83C410   		add	esp, 16
 265:guest.c       **** 		//Increase the stack pointer to release the "popped" values above
 266:guest.c       **** 		guest.vmcb->rsp = guest.vmcb->rsp + 6;
 1005              		.loc 1 266 0
 1006 0a8b 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1006      0000
 1007 0a91 A1040000 		mov	eax, DWORD PTR guest+4
 1007      00
 1008 0a96 8B90DC05 		mov	edx, DWORD PTR [eax+1500]
 1008      0000
 1009 0a9c 8B80D805 		mov	eax, DWORD PTR [eax+1496]
 1009      0000
 1010 0aa2 83C006   		add	eax, 6
 1011 0aa5 83D200   		adc	edx, 0
 1012 0aa8 8981D805 		mov	DWORD PTR [ecx+1496], eax
 1012      0000
 1013 0aae 8991DC05 		mov	DWORD PTR [ecx+1500], edx
 1013      0000
 267:guest.c       **** }
 1014              		.loc 1 267 0
 1015 0ab4 90       		nop
 1016 0ab5 C9       		leave
 1017              		.cfi_restore 5
 1018              		.cfi_def_cfa 4, 4
 1019 0ab6 C3       		ret
 1020              		.cfi_endproc
 1021              	.LFE7:
 1023              		.globl	HandleInterrutpReturn
 1025              	HandleInterrutpReturn:
 1026              	.LFB8:
 268:guest.c       **** 
 269:guest.c       **** void HandleInterrutpReturn()
 270:guest.c       **** {
 1027              		.loc 1 270 0
 1028              		.cfi_startproc
 1029 0ab7 55       		push	ebp
 1030              		.cfi_def_cfa_offset 8
 1031              		.cfi_offset 5, -8
 1032 0ab8 89E5     		mov	ebp, esp
 1033              		.cfi_def_cfa_register 5
 1034 0aba 83EC08   		sub	esp, 8
 271:guest.c       **** 	PopCSIPFlagsOffGuestStackReal16();
 1035              		.loc 1 271 0
 1036 0abd E8FCFFFF 		call	PopCSIPFlagsOffGuestStackReal16
 1036      FF
 272:guest.c       **** }
 1037              		.loc 1 272 0
 1038 0ac2 90       		nop
 1039 0ac3 C9       		leave
 1040              		.cfi_restore 5
 1041              		.cfi_def_cfa 4, 4
 1042 0ac4 C3       		ret
 1043              		.cfi_endproc
 1044              	.LFE8:
 1046              		.globl	HandleCR0Write
 1048              	HandleCR0Write:
 1049              	.LFB9:
 273:guest.c       **** 
 274:guest.c       **** /*
 275:guest.c       ****  * Handling a CR0 write is complicated.  Here's what we will do ...
 276:guest.c       ****  * 1) Figure out which instruction set the CR0 and update the guest shadow CR0 appropriately
 277:guest.c       ****  * 2) 
 278:guest.c       ****  */
 279:guest.c       **** void HandleCR0Write()
 280:guest.c       **** {
 1050              		.loc 1 280 0
 1051              		.cfi_startproc
 1052 0ac5 55       		push	ebp
 1053              		.cfi_def_cfa_offset 8
 1054              		.cfi_offset 5, -8
 1055 0ac6 89E5     		mov	ebp, esp
 1056              		.cfi_def_cfa_register 5
 1057 0ac8 57       		push	edi
 1058 0ac9 56       		push	esi
 1059 0aca 53       		push	ebx
 1060 0acb 83EC2C   		sub	esp, 44
 1061              		.cfi_offset 7, -12
 1062              		.cfi_offset 6, -16
 1063              		.cfi_offset 3, -20
 281:guest.c       **** DWORD CSIp = GetCSIp();
 1064              		.loc 1 281 0
 1065 0ace E8FCFFFF 		call	GetCSIp
 1065      FF
 1066 0ad3 8945E0   		mov	DWORD PTR [ebp-32], eax
 282:guest.c       **** WORD Instruction = GetMemW(CSIp, true);
 1067              		.loc 1 282 0
 1068 0ad6 83EC08   		sub	esp, 8
 1069 0ad9 6A01     		push	1
 1070 0adb FF75E0   		push	DWORD PTR [ebp-32]
 1071 0ade E8FCFFFF 		call	GetMemW
 1071      FF
 1072 0ae3 83C410   		add	esp, 16
 1073 0ae6 668945DE 		mov	WORD PTR [ebp-34], ax
 283:guest.c       **** DWORD newCR0;
 284:guest.c       ****     
 285:guest.c       ****     if ( (guest.vmcb->exitinfo1 & 0x8000000000000000) == 0x8000000000000000)   //Instruction was a 
 1074              		.loc 1 285 0
 1075 0aea A1040000 		mov	eax, DWORD PTR guest+4
 1075      00
 1076 0aef 8B507C   		mov	edx, DWORD PTR [eax+124]
 1077 0af2 8B4078   		mov	eax, DWORD PTR [eax+120]
 1078 0af5 85D2     		test	edx, edx
 1079 0af7 7926     		jns	.L36
 286:guest.c       ****             newCR0 = GetGPRValue(guest.vmcb->exitinfo1 & 0xFF, true, false);
 1080              		.loc 1 286 0
 1081 0af9 A1040000 		mov	eax, DWORD PTR guest+4
 1081      00
 1082 0afe 8B507C   		mov	edx, DWORD PTR [eax+124]
 1083 0b01 8B4078   		mov	eax, DWORD PTR [eax+120]
 1084 0b04 0FB6C0   		movzx	eax, al
 1085 0b07 83EC04   		sub	esp, 4
 1086 0b0a 6A00     		push	0
 1087 0b0c 6A01     		push	1
 1088 0b0e 50       		push	eax
 1089 0b0f E8FCFFFF 		call	GetGPRValue
 1089      FF
 1090 0b14 83C410   		add	esp, 16
 1091 0b17 8945E4   		mov	DWORD PTR [ebp-28], eax
 1092 0b1a E98F0000 		jmp	.L37
 1092      00
 1093              	.L36:
 287:guest.c       ****     else if (Instruction == OPCODE_CLTS)
 1094              		.loc 1 287 0
 1095 0b1f 66817DDE 		cmp	WORD PTR [ebp-34], 1551
 1095      0F06
 1096 0b25 756E     		jne	.L38
 288:guest.c       ****     {
 289:guest.c       ****             guest.guestViewCR0 &= 0xFFFFFFF7; //Clear task switching flag
 1097              		.loc 1 289 0
 1098 0b27 A1140000 		mov	eax, DWORD PTR guest+20
 1098      00
 1099 0b2c 83E0F7   		and	eax, -9
 1100 0b2f A3140000 		mov	DWORD PTR guest+20, eax
 1100      00
 290:guest.c       ****             guest.vmcb->cr0 &= 0xFFFFFFF7;
 1101              		.loc 1 290 0
 1102 0b34 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1102      0000
 1103 0b3a A1040000 		mov	eax, DWORD PTR guest+4
 1103      00
 1104 0b3f 8B905C05 		mov	edx, DWORD PTR [eax+1372]
 1104      0000
 1105 0b45 8B805805 		mov	eax, DWORD PTR [eax+1368]
 1105      0000
 1106 0b4b 89C6     		mov	esi, eax
 1107 0b4d 83E6F7   		and	esi, -9
 1108 0b50 8975D0   		mov	DWORD PTR [ebp-48], esi
 1109 0b53 89D0     		mov	eax, edx
 1110 0b55 83E000   		and	eax, 0
 1111 0b58 8945D4   		mov	DWORD PTR [ebp-44], eax
 1112 0b5b 8B45D0   		mov	eax, DWORD PTR [ebp-48]
 1113 0b5e 8B55D4   		mov	edx, DWORD PTR [ebp-44]
 1114 0b61 89815805 		mov	DWORD PTR [ecx+1368], eax
 1114      0000
 1115 0b67 89915C05 		mov	DWORD PTR [ecx+1372], edx
 1115      0000
 291:guest.c       ****             guest.vmcb->rip = guest.vmcb->nextrip;
 1116              		.loc 1 291 0
 1117 0b6d 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1117      0000
 1118 0b73 A1040000 		mov	eax, DWORD PTR guest+4
 1118      00
 1119 0b78 8B90CC00 		mov	edx, DWORD PTR [eax+204]
 1119      0000
 1120 0b7e 8B80C800 		mov	eax, DWORD PTR [eax+200]
 1120      0000
 1121 0b84 89817805 		mov	DWORD PTR [ecx+1400], eax
 1121      0000
 1122 0b8a 89917C05 		mov	DWORD PTR [ecx+1404], edx
 1122      0000
 292:guest.c       ****             return;
 1123              		.loc 1 292 0
 1124 0b90 E9C70100 		jmp	.L35
 1124      00
 1125              	.L38:
 293:guest.c       ****     }
 294:guest.c       ****     else //LMSW
 295:guest.c       ****     {
 296:guest.c       ****         newCR0 = guest.vmcb->rax & 0x0000FFFF;
 1126              		.loc 1 296 0
 1127 0b95 A1040000 		mov	eax, DWORD PTR guest+4
 1127      00
 1128 0b9a 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 1128      0000
 1129 0ba0 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 1129      0000
 1130 0ba6 25FFFF00 		and	eax, 65535
 1130      00
 1131 0bab 8945E4   		mov	DWORD PTR [ebp-28], eax
 1132              	.L37:
 297:guest.c       ****         //guest.shadowCR0 = ((guest.shadowCR0 & 0xFFFF0000) | (guest.vmcb->rax & 0x0000FFFF)) | 0x8
 298:guest.c       ****         //guest.vmcb->cr0 = guest.shadowCR0;
 299:guest.c       ****     }
 300:guest.c       ****     //While with paging we maintain the shadow CR0 but never turn the paging bit off/on (it stays o
 301:guest.c       ****     //with the pmode bit we actually do turn it on & off in the guest as well as keep the shadow CR
 302:guest.c       ****     if ( (newCR0 & 1) == 1 )
 1133              		.loc 1 302 0
 1134 0bae 8B45E4   		mov	eax, DWORD PTR [ebp-28]
 1135 0bb1 83E001   		and	eax, 1
 1136 0bb4 85C0     		test	eax, eax
 1137 0bb6 7458     		je	.L40
 303:guest.c       ****     {
 304:guest.c       ****         if ((guest.guestViewCR0 & 0x1) != 0x1 )
 1138              		.loc 1 304 0
 1139 0bb8 A1140000 		mov	eax, DWORD PTR guest+20
 1139      00
 1140 0bbd 83E001   		and	eax, 1
 1141 0bc0 85C0     		test	eax, eax
 1142 0bc2 0F859C00 		jne	.L42
 1142      0000
 305:guest.c       ****         {
 306:guest.c       ****             guest.guestViewCR0 |= 0x1;
 1143              		.loc 1 306 0
 1144 0bc8 A1140000 		mov	eax, DWORD PTR guest+20
 1144      00
 1145 0bcd 83C801   		or	eax, 1
 1146 0bd0 A3140000 		mov	DWORD PTR guest+20, eax
 1146      00
 307:guest.c       ****             //Unlike with paging, we will actually turn pmode on
 308:guest.c       ****             guest.vmcb->cr0 |= 0x1;
 1147              		.loc 1 308 0
 1148 0bd5 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1148      0000
 1149 0bdb A1040000 		mov	eax, DWORD PTR guest+4
 1149      00
 1150 0be0 8B905C05 		mov	edx, DWORD PTR [eax+1372]
 1150      0000
 1151 0be6 8B805805 		mov	eax, DWORD PTR [eax+1368]
 1151      0000
 1152 0bec 89C3     		mov	ebx, eax
 1153 0bee 83CB01   		or	ebx, 1
 1154 0bf1 895DC8   		mov	DWORD PTR [ebp-56], ebx
 1155 0bf4 89D0     		mov	eax, edx
 1156 0bf6 80CC00   		or	ah, 0
 1157 0bf9 8945CC   		mov	DWORD PTR [ebp-52], eax
 1158 0bfc 8B45C8   		mov	eax, DWORD PTR [ebp-56]
 1159 0bff 8B55CC   		mov	edx, DWORD PTR [ebp-52]
 1160 0c02 89815805 		mov	DWORD PTR [ecx+1368], eax
 1160      0000
 1161 0c08 89915C05 		mov	DWORD PTR [ecx+1372], edx
 1161      0000
 1162 0c0e EB54     		jmp	.L42
 1163              	.L40:
 309:guest.c       ****         }
 310:guest.c       ****     }
 311:guest.c       ****     else if ( ((guest.guestViewCR0 & 0x1) == 0x1) && ((newCR0 & 1) != 1))
 1164              		.loc 1 311 0
 1165 0c10 A1140000 		mov	eax, DWORD PTR guest+20
 1165      00
 1166 0c15 83E001   		and	eax, 1
 1167 0c18 85C0     		test	eax, eax
 1168 0c1a 7448     		je	.L42
 1169              		.loc 1 311 0 is_stmt 0 discriminator 1
 1170 0c1c 8B45E4   		mov	eax, DWORD PTR [ebp-28]
 1171 0c1f 83E001   		and	eax, 1
 1172 0c22 85C0     		test	eax, eax
 1173 0c24 753E     		jne	.L42
 312:guest.c       ****     {
 313:guest.c       ****             guest.guestViewCR0 &= 0xFFFFFFFE;
 1174              		.loc 1 313 0 is_stmt 1
 1175 0c26 A1140000 		mov	eax, DWORD PTR guest+20
 1175      00
 1176 0c2b 83E0FE   		and	eax, -2
 1177 0c2e A3140000 		mov	DWORD PTR guest+20, eax
 1177      00
 314:guest.c       ****             //Unlike with paging, we actually will turn pmode off
 315:guest.c       ****             guest.vmcb->cr0 &= 0xFFFFFFFE;
 1178              		.loc 1 315 0
 1179 0c33 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1179      0000
 1180 0c39 A1040000 		mov	eax, DWORD PTR guest+4
 1180      00
 1181 0c3e 8B905C05 		mov	edx, DWORD PTR [eax+1372]
 1181      0000
 1182 0c44 8B805805 		mov	eax, DWORD PTR [eax+1368]
 1182      0000
 1183 0c4a 89C7     		mov	edi, eax
 1184 0c4c 83E7FE   		and	edi, -2
 1185 0c4f 89FB     		mov	ebx, edi
 1186 0c51 89D0     		mov	eax, edx
 1187 0c53 83E000   		and	eax, 0
 1188 0c56 89C6     		mov	esi, eax
 1189 0c58 89995805 		mov	DWORD PTR [ecx+1368], ebx
 1189      0000
 1190 0c5e 89B15C05 		mov	DWORD PTR [ecx+1372], esi
 1190      0000
 1191              	.L42:
 316:guest.c       ****     }
 317:guest.c       ****     //If paging is on in the new CR0 ...
 318:guest.c       ****         //And it was not before ...
 319:guest.c       ****     if ((guest.guestViewCR0 & 0x80000000) != 0x80000000 && ((newCR0 & 0x80000000) == 0x80000000))
 1192              		.loc 1 319 0
 1193 0c64 A1140000 		mov	eax, DWORD PTR guest+20
 1193      00
 1194 0c69 85C0     		test	eax, eax
 1195 0c6b 7864     		js	.L43
 1196              		.loc 1 319 0 is_stmt 0 discriminator 1
 1197 0c6d 8B45E4   		mov	eax, DWORD PTR [ebp-28]
 1198 0c70 85C0     		test	eax, eax
 1199 0c72 795D     		jns	.L43
 320:guest.c       ****     {
 321:guest.c       ****         //We need to change the guest to paged and enable Nested
 322:guest.c       ****         guest.vmcb->np_enable = true;
 1200              		.loc 1 322 0 is_stmt 1
 1201 0c74 A1040000 		mov	eax, DWORD PTR guest+4
 1201      00
 1202 0c79 C7809000 		mov	DWORD PTR [eax+144], 1
 1202      00000100 
 1202      0000
 1203 0c83 C7809400 		mov	DWORD PTR [eax+148], 0
 1203      00000000 
 1203      0000
 323:guest.c       ****         //Turn off intercepting of paging exceptions while nested paging is on
 324:guest.c       ****         guest.vmcb->exception_intercepts &= 0xBFFF;
 1204              		.loc 1 324 0
 1205 0c8d A1040000 		mov	eax, DWORD PTR guest+4
 1205      00
 1206 0c92 8B150400 		mov	edx, DWORD PTR guest+4
 1206      0000
 1207 0c98 8B5208   		mov	edx, DWORD PTR [edx+8]
 1208 0c9b 81E2FFBF 		and	edx, 49151
 1208      0000
 1209 0ca1 895008   		mov	DWORD PTR [eax+8], edx
 325:guest.c       ****         guest.vmcb->cr3 = guest.requestedCR3;
 1210              		.loc 1 325 0
 1211 0ca4 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1211      0000
 1212 0caa A10C0000 		mov	eax, DWORD PTR guest+12
 1212      00
 1213 0caf BA000000 		mov	edx, 0
 1213      00
 1214 0cb4 89815005 		mov	DWORD PTR [ecx+1360], eax
 1214      0000
 1215 0cba 89915405 		mov	DWORD PTR [ecx+1364], edx
 1215      0000
 326:guest.c       ****         //Let the guest think paging is on (which it is) but don't affect the real paging flag
 327:guest.c       ****         guest.guestViewCR0 |= 0x80000000;
 1216              		.loc 1 327 0
 1217 0cc0 A1140000 		mov	eax, DWORD PTR guest+20
 1217      00
 1218 0cc5 0D000000 		or	eax, -2147483648
 1218      80
 1219 0cca A3140000 		mov	DWORD PTR guest+20, eax
 1219      00
 1220 0ccf EB68     		jmp	.L44
 1221              	.L43:
 328:guest.c       ****         //CopyMemory(vhost.CodeBase + vhost.NestedCR3Backup, vhost.CodeBase + vhost.NestedCR3, 0x10
 329:guest.c       **** 
 330:guest.c       ****     }
 331:guest.c       ****     else if ( ((guest.guestViewCR0 & 0x80000000) == 0x80000000) && ((newCR0 & 0x80000000) != 0x8000
 1222              		.loc 1 331 0
 1223 0cd1 A1140000 		mov	eax, DWORD PTR guest+20
 1223      00
 1224 0cd6 85C0     		test	eax, eax
 1225 0cd8 795F     		jns	.L44
 1226              		.loc 1 331 0 is_stmt 0 discriminator 1
 1227 0cda 8B45E4   		mov	eax, DWORD PTR [ebp-28]
 1228 0cdd 85C0     		test	eax, eax
 1229 0cdf 7858     		js	.L44
 332:guest.c       ****     {
 333:guest.c       ****         guest.vmcb->np_enable = false;
 1230              		.loc 1 333 0 is_stmt 1
 1231 0ce1 A1040000 		mov	eax, DWORD PTR guest+4
 1231      00
 1232 0ce6 C7809000 		mov	DWORD PTR [eax+144], 0
 1232      00000000 
 1232      0000
 1233 0cf0 C7809400 		mov	DWORD PTR [eax+148], 0
 1233      00000000 
 1233      0000
 334:guest.c       ****        //Turn on intercepting of paging exceptions as they won't be handled by
 335:guest.c       ****        //nested paging when guest is is in paged-real mode
 336:guest.c       ****         guest.vmcb->exception_intercepts |= 0x4000;
 1234              		.loc 1 336 0
 1235 0cfa A1040000 		mov	eax, DWORD PTR guest+4
 1235      00
 1236 0cff 8B150400 		mov	edx, DWORD PTR guest+4
 1236      0000
 1237 0d05 8B5208   		mov	edx, DWORD PTR [edx+8]
 1238 0d08 80CE40   		or	dh, 64
 1239 0d0b 895008   		mov	DWORD PTR [eax+8], edx
 337:guest.c       ****         guest.vmcb->cr3 = guest.nonPagingCR3;
 1240              		.loc 1 337 0
 1241 0d0e 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1241      0000
 1242 0d14 A1100000 		mov	eax, DWORD PTR guest+16
 1242      00
 1243 0d19 BA000000 		mov	edx, 0
 1243      00
 1244 0d1e 89815005 		mov	DWORD PTR [ecx+1360], eax
 1244      0000
 1245 0d24 89915405 		mov	DWORD PTR [ecx+1364], edx
 1245      0000
 338:guest.c       ****         guest.guestViewCR0 &= 0x7FFFFFFF;
 1246              		.loc 1 338 0
 1247 0d2a A1140000 		mov	eax, DWORD PTR guest+20
 1247      00
 1248 0d2f 25FFFFFF 		and	eax, 2147483647
 1248      7F
 1249 0d34 A3140000 		mov	DWORD PTR guest+20, eax
 1249      00
 1250              	.L44:
 339:guest.c       ****         //Note here that we don't REALLY turn off paging, we just make the guest think we did
 340:guest.c       ****         //  CopyMemory(vhost.CodeBase + vhost.NestedCR3Backup, vhost.CodeBase + vhost.NestedCR3, 0x
 341:guest.c       ****     }
 342:guest.c       ****     guest.vmcb->rip = guest.vmcb->nextrip;
 1251              		.loc 1 342 0
 1252 0d39 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1252      0000
 1253 0d3f A1040000 		mov	eax, DWORD PTR guest+4
 1253      00
 1254 0d44 8B90CC00 		mov	edx, DWORD PTR [eax+204]
 1254      0000
 1255 0d4a 8B80C800 		mov	eax, DWORD PTR [eax+200]
 1255      0000
 1256 0d50 89817805 		mov	DWORD PTR [ecx+1400], eax
 1256      0000
 1257 0d56 89917C05 		mov	DWORD PTR [ecx+1404], edx
 1257      0000
 1258              	.L35:
 343:guest.c       **** }
 1259              		.loc 1 343 0
 1260 0d5c 8D65F4   		lea	esp, [ebp-12]
 1261 0d5f 5B       		pop	ebx
 1262              		.cfi_restore 3
 1263 0d60 5E       		pop	esi
 1264              		.cfi_restore 6
 1265 0d61 5F       		pop	edi
 1266              		.cfi_restore 7
 1267 0d62 5D       		pop	ebp
 1268              		.cfi_restore 5
 1269              		.cfi_def_cfa 4, 4
 1270 0d63 C3       		ret
 1271              		.cfi_endproc
 1272              	.LFE9:
 1274              		.globl	HandleCR0Read
 1276              	HandleCR0Read:
 1277              	.LFB10:
 344:guest.c       **** 
 345:guest.c       **** void HandleCR0Read()
 346:guest.c       **** {
 1278              		.loc 1 346 0
 1279              		.cfi_startproc
 1280 0d64 55       		push	ebp
 1281              		.cfi_def_cfa_offset 8
 1282              		.cfi_offset 5, -8
 1283 0d65 89E5     		mov	ebp, esp
 1284              		.cfi_def_cfa_register 5
 1285 0d67 83EC18   		sub	esp, 24
 347:guest.c       **** DWORD CSIp = GetCSIp();
 1286              		.loc 1 347 0
 1287 0d6a E8FCFFFF 		call	GetCSIp
 1287      FF
 1288 0d6f 8945F4   		mov	DWORD PTR [ebp-12], eax
 348:guest.c       **** WORD Instruction = GetMemW(CSIp, true);
 1289              		.loc 1 348 0
 1290 0d72 83EC08   		sub	esp, 8
 1291 0d75 6A01     		push	1
 1292 0d77 FF75F4   		push	DWORD PTR [ebp-12]
 1293 0d7a E8FCFFFF 		call	GetMemW
 1293      FF
 1294 0d7f 83C410   		add	esp, 16
 1295 0d82 668945F2 		mov	WORD PTR [ebp-14], ax
 349:guest.c       **** 
 350:guest.c       ****         if ( (guest.vmcb->exitinfo1 & 0x8000000000000000) == 0x8000000000000000)   //Instruction wa
 1296              		.loc 1 350 0
 1297 0d86 A1040000 		mov	eax, DWORD PTR guest+4
 1297      00
 1298 0d8b 8B507C   		mov	edx, DWORD PTR [eax+124]
 1299 0d8e 8B4078   		mov	eax, DWORD PTR [eax+120]
 1300 0d91 85D2     		test	edx, edx
 1301 0d93 7922     		jns	.L46
 351:guest.c       ****         {
 352:guest.c       ****             SetGPRValue(guest.vmcb->exitinfo1 & 0xFF, guest.guestViewCR0, true, false);
 1302              		.loc 1 352 0
 1303 0d95 8B0D1400 		mov	ecx, DWORD PTR guest+20
 1303      0000
 1304 0d9b A1040000 		mov	eax, DWORD PTR guest+4
 1304      00
 1305 0da0 8B507C   		mov	edx, DWORD PTR [eax+124]
 1306 0da3 8B4078   		mov	eax, DWORD PTR [eax+120]
 1307 0da6 0FB6C0   		movzx	eax, al
 1308 0da9 6A00     		push	0
 1309 0dab 6A01     		push	1
 1310 0dad 51       		push	ecx
 1311 0dae 50       		push	eax
 1312 0daf E8FCFFFF 		call	SetGPRValue
 1312      FF
 1313 0db4 83C410   		add	esp, 16
 1314              	.L46:
 353:guest.c       ****         }
 354:guest.c       **** 
 355:guest.c       ****         //TODO: SMSW can write to memory which isn't covered here
 356:guest.c       **** 	if (Instruction == OPCODE_SMSW)
 1315              		.loc 1 356 0
 1316 0db7 66817DF2 		cmp	WORD PTR [ebp-14], 271
 1316      0F01
 1317 0dbd 7516     		jne	.L47
 357:guest.c       **** 		SetGuestMODRegGenRegValue(2, guest.guestViewCR0, false, true);
 1318              		.loc 1 357 0
 1319 0dbf A1140000 		mov	eax, DWORD PTR guest+20
 1319      00
 1320 0dc4 6A01     		push	1
 1321 0dc6 6A00     		push	0
 1322 0dc8 50       		push	eax
 1323 0dc9 6A02     		push	2
 1324 0dcb E8FCFFFF 		call	SetGuestMODRegGenRegValue
 1324      FF
 1325 0dd0 83C410   		add	esp, 16
 1326 0dd3 EB14     		jmp	.L48
 1327              	.L47:
 358:guest.c       **** 	else
 359:guest.c       ****         {
 360:guest.c       **** 		SetGuestMODRegGenRegValue(2, guest.guestViewCR0, true, false);
 1328              		.loc 1 360 0
 1329 0dd5 A1140000 		mov	eax, DWORD PTR guest+20
 1329      00
 1330 0dda 6A00     		push	0
 1331 0ddc 6A01     		push	1
 1332 0dde 50       		push	eax
 1333 0ddf 6A02     		push	2
 1334 0de1 E8FCFFFF 		call	SetGuestMODRegGenRegValue
 1334      FF
 1335 0de6 83C410   		add	esp, 16
 1336              	.L48:
 361:guest.c       ****         }
 362:guest.c       ****     guest.vmcb->rip = guest.vmcb->nextrip;
 1337              		.loc 1 362 0
 1338 0de9 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1338      0000
 1339 0def A1040000 		mov	eax, DWORD PTR guest+4
 1339      00
 1340 0df4 8B90CC00 		mov	edx, DWORD PTR [eax+204]
 1340      0000
 1341 0dfa 8B80C800 		mov	eax, DWORD PTR [eax+200]
 1341      0000
 1342 0e00 89817805 		mov	DWORD PTR [ecx+1400], eax
 1342      0000
 1343 0e06 89917C05 		mov	DWORD PTR [ecx+1404], edx
 1343      0000
 363:guest.c       **** }
 1344              		.loc 1 363 0
 1345 0e0c 90       		nop
 1346 0e0d C9       		leave
 1347              		.cfi_restore 5
 1348              		.cfi_def_cfa 4, 4
 1349 0e0e C3       		ret
 1350              		.cfi_endproc
 1351              	.LFE10:
 1353              		.globl	SetGPRValue
 1355              	SetGPRValue:
 1356              	.LFB11:
 364:guest.c       **** 
 365:guest.c       **** void SetGPRValue(int GPRNumber, DWORD Value, bool DW, bool W)
 366:guest.c       **** {
 1357              		.loc 1 366 0
 1358              		.cfi_startproc
 1359 0e0f 55       		push	ebp
 1360              		.cfi_def_cfa_offset 8
 1361              		.cfi_offset 5, -8
 1362 0e10 89E5     		mov	ebp, esp
 1363              		.cfi_def_cfa_register 5
 1364 0e12 56       		push	esi
 1365 0e13 53       		push	ebx
 1366 0e14 83EC20   		sub	esp, 32
 1367              		.cfi_offset 6, -12
 1368              		.cfi_offset 3, -16
 1369 0e17 8B5510   		mov	edx, DWORD PTR [ebp+16]
 1370 0e1a 8B4514   		mov	eax, DWORD PTR [ebp+20]
 1371 0e1d 8855F4   		mov	BYTE PTR [ebp-12], dl
 1372 0e20 8845F0   		mov	BYTE PTR [ebp-16], al
 367:guest.c       ****     switch (GPRNumber)
 1373              		.loc 1 367 0
 1374 0e23 837D0807 		cmp	DWORD PTR [ebp+8], 7
 1375 0e27 0F876102 		ja	.L84
 1375      0000
 1376 0e2d 8B4508   		mov	eax, DWORD PTR [ebp+8]
 1377 0e30 C1E002   		sal	eax, 2
 1378 0e33 05000000 		add	eax, OFFSET FLAT:.L52
 1378      00
 1379 0e38 8B00     		mov	eax, DWORD PTR [eax]
 1380 0e3a FFE0     		jmp	eax
 1381              		.section	.rodata
 1382              		.align 4
 1383              		.align 4
 1384              	.L52:
 1385 0000 3C0E0000 		.long	.L51
 1386 0004 CD0E0000 		.long	.L53
 1387 0008 060F0000 		.long	.L54
 1388 000c 3F0F0000 		.long	.L55
 1389 0010 780F0000 		.long	.L56
 1390 0014 FF0F0000 		.long	.L57
 1391 0018 2F100000 		.long	.L58
 1392 001c 5F100000 		.long	.L59
 1393              		.text
 1394              	.L51:
 368:guest.c       ****     {
 369:guest.c       ****         case MODRM_REG_EAX:
 370:guest.c       ****             if (DW)
 1395              		.loc 1 370 0
 1396 0e3c 807DF400 		cmp	BYTE PTR [ebp-12], 0
 1397 0e40 741F     		je	.L60
 371:guest.c       ****                 guest.vmcb->rax = Value;
 1398              		.loc 1 371 0
 1399 0e42 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1399      0000
 1400 0e48 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1401 0e4b BA000000 		mov	edx, 0
 1401      00
 1402 0e50 8981F805 		mov	DWORD PTR [ecx+1528], eax
 1402      0000
 1403 0e56 8991FC05 		mov	DWORD PTR [ecx+1532], edx
 1403      0000
 372:guest.c       ****             else if (W)
 373:guest.c       ****                 guest.vmcb->rax = Value & 0xFFFF;
 374:guest.c       ****             else
 375:guest.c       ****                 guest.vmcb->rax = Value & 0xFF;
 376:guest.c       ****             break;
 1404              		.loc 1 376 0
 1405 0e5c E92D0200 		jmp	.L50
 1405      00
 1406              	.L60:
 372:guest.c       ****             else if (W)
 1407              		.loc 1 372 0
 1408 0e61 807DF000 		cmp	BYTE PTR [ebp-16], 0
 1409 0e65 7433     		je	.L62
 373:guest.c       ****             else
 1410              		.loc 1 373 0
 1411 0e67 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1411      0000
 1412 0e6d 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1413 0e70 BA000000 		mov	edx, 0
 1413      00
 1414 0e75 0FB7F0   		movzx	esi, ax
 1415 0e78 8975E8   		mov	DWORD PTR [ebp-24], esi
 1416 0e7b 89D0     		mov	eax, edx
 1417 0e7d 83E000   		and	eax, 0
 1418 0e80 8945EC   		mov	DWORD PTR [ebp-20], eax
 1419 0e83 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 1420 0e86 8B55EC   		mov	edx, DWORD PTR [ebp-20]
 1421 0e89 8981F805 		mov	DWORD PTR [ecx+1528], eax
 1421      0000
 1422 0e8f 8991FC05 		mov	DWORD PTR [ecx+1532], edx
 1422      0000
 1423              		.loc 1 376 0
 1424 0e95 E9F40100 		jmp	.L50
 1424      00
 1425              	.L62:
 375:guest.c       ****             break;
 1426              		.loc 1 375 0
 1427 0e9a 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1427      0000
 1428 0ea0 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1429 0ea3 BA000000 		mov	edx, 0
 1429      00
 1430 0ea8 0FB6F0   		movzx	esi, al
 1431 0eab 8975E0   		mov	DWORD PTR [ebp-32], esi
 1432 0eae 89D0     		mov	eax, edx
 1433 0eb0 83E000   		and	eax, 0
 1434 0eb3 8945E4   		mov	DWORD PTR [ebp-28], eax
 1435 0eb6 8B45E0   		mov	eax, DWORD PTR [ebp-32]
 1436 0eb9 8B55E4   		mov	edx, DWORD PTR [ebp-28]
 1437 0ebc 8981F805 		mov	DWORD PTR [ecx+1528], eax
 1437      0000
 1438 0ec2 8991FC05 		mov	DWORD PTR [ecx+1532], edx
 1438      0000
 1439              		.loc 1 376 0
 1440 0ec8 E9C10100 		jmp	.L50
 1440      00
 1441              	.L53:
 377:guest.c       ****         case MODRM_REG_ECX:
 378:guest.c       ****             if (DW)
 1442              		.loc 1 378 0
 1443 0ecd 807DF400 		cmp	BYTE PTR [ebp-12], 0
 1444 0ed1 740D     		je	.L63
 379:guest.c       ****                 GuestRegisters[RAN_ECX] = Value;
 1445              		.loc 1 379 0
 1446 0ed3 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1447 0ed6 A3040000 		mov	DWORD PTR GuestRegisters+4, eax
 1447      00
 380:guest.c       ****             else if (W)
 381:guest.c       ****                 GuestRegisters[RAN_ECX] = Value & 0xFFFF;
 382:guest.c       ****             else
 383:guest.c       ****                 GuestRegisters[RAN_ECX] = Value & 0xFF;
 384:guest.c       ****             break;
 1448              		.loc 1 384 0
 1449 0edb E9AE0100 		jmp	.L50
 1449      00
 1450              	.L63:
 380:guest.c       ****             else if (W)
 1451              		.loc 1 380 0
 1452 0ee0 807DF000 		cmp	BYTE PTR [ebp-16], 0
 1453 0ee4 7410     		je	.L65
 381:guest.c       ****             else
 1454              		.loc 1 381 0
 1455 0ee6 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1456 0ee9 0FB7C0   		movzx	eax, ax
 1457 0eec A3040000 		mov	DWORD PTR GuestRegisters+4, eax
 1457      00
 1458              		.loc 1 384 0
 1459 0ef1 E9980100 		jmp	.L50
 1459      00
 1460              	.L65:
 383:guest.c       ****             break;
 1461              		.loc 1 383 0
 1462 0ef6 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1463 0ef9 0FB6C0   		movzx	eax, al
 1464 0efc A3040000 		mov	DWORD PTR GuestRegisters+4, eax
 1464      00
 1465              		.loc 1 384 0
 1466 0f01 E9880100 		jmp	.L50
 1466      00
 1467              	.L54:
 385:guest.c       ****         case MODRM_REG_EDX:
 386:guest.c       ****             if (DW)
 1468              		.loc 1 386 0
 1469 0f06 807DF400 		cmp	BYTE PTR [ebp-12], 0
 1470 0f0a 740D     		je	.L66
 387:guest.c       ****                 GuestRegisters[RAN_EDX] = Value;
 1471              		.loc 1 387 0
 1472 0f0c 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1473 0f0f A3080000 		mov	DWORD PTR GuestRegisters+8, eax
 1473      00
 388:guest.c       ****             else if (W)
 389:guest.c       ****                 GuestRegisters[RAN_EDX] = Value & 0xFFFF;
 390:guest.c       ****             else
 391:guest.c       ****                 GuestRegisters[RAN_EDX] = Value & 0xFF;
 392:guest.c       ****             break;
 1474              		.loc 1 392 0
 1475 0f14 E9750100 		jmp	.L50
 1475      00
 1476              	.L66:
 388:guest.c       ****             else if (W)
 1477              		.loc 1 388 0
 1478 0f19 807DF000 		cmp	BYTE PTR [ebp-16], 0
 1479 0f1d 7410     		je	.L68
 389:guest.c       ****             else
 1480              		.loc 1 389 0
 1481 0f1f 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1482 0f22 0FB7C0   		movzx	eax, ax
 1483 0f25 A3080000 		mov	DWORD PTR GuestRegisters+8, eax
 1483      00
 1484              		.loc 1 392 0
 1485 0f2a E95F0100 		jmp	.L50
 1485      00
 1486              	.L68:
 391:guest.c       ****             break;
 1487              		.loc 1 391 0
 1488 0f2f 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1489 0f32 0FB6C0   		movzx	eax, al
 1490 0f35 A3080000 		mov	DWORD PTR GuestRegisters+8, eax
 1490      00
 1491              		.loc 1 392 0
 1492 0f3a E94F0100 		jmp	.L50
 1492      00
 1493              	.L55:
 393:guest.c       ****         case MODRM_REG_EBX:
 394:guest.c       ****             if (DW)
 1494              		.loc 1 394 0
 1495 0f3f 807DF400 		cmp	BYTE PTR [ebp-12], 0
 1496 0f43 740D     		je	.L69
 395:guest.c       ****                 GuestRegisters[RAN_EBX] = Value;
 1497              		.loc 1 395 0
 1498 0f45 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1499 0f48 A3000000 		mov	DWORD PTR GuestRegisters, eax
 1499      00
 396:guest.c       ****             else if (W)
 397:guest.c       ****                 GuestRegisters[RAN_EBX] = Value & 0xFFFF;
 398:guest.c       ****             else
 399:guest.c       ****                 GuestRegisters[RAN_EBX] = Value & 0xFF;
 400:guest.c       ****             break;
 1500              		.loc 1 400 0
 1501 0f4d E93C0100 		jmp	.L50
 1501      00
 1502              	.L69:
 396:guest.c       ****             else if (W)
 1503              		.loc 1 396 0
 1504 0f52 807DF000 		cmp	BYTE PTR [ebp-16], 0
 1505 0f56 7410     		je	.L71
 397:guest.c       ****             else
 1506              		.loc 1 397 0
 1507 0f58 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1508 0f5b 0FB7C0   		movzx	eax, ax
 1509 0f5e A3000000 		mov	DWORD PTR GuestRegisters, eax
 1509      00
 1510              		.loc 1 400 0
 1511 0f63 E9260100 		jmp	.L50
 1511      00
 1512              	.L71:
 399:guest.c       ****             break;
 1513              		.loc 1 399 0
 1514 0f68 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1515 0f6b 0FB6C0   		movzx	eax, al
 1516 0f6e A3000000 		mov	DWORD PTR GuestRegisters, eax
 1516      00
 1517              		.loc 1 400 0
 1518 0f73 E9160100 		jmp	.L50
 1518      00
 1519              	.L56:
 401:guest.c       ****         case MODRM_REG_ESP:
 402:guest.c       ****             if (DW)
 1520              		.loc 1 402 0
 1521 0f78 807DF400 		cmp	BYTE PTR [ebp-12], 0
 1522 0f7c 741F     		je	.L72
 403:guest.c       ****                 guest.vmcb->rsp = Value;
 1523              		.loc 1 403 0
 1524 0f7e 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1524      0000
 1525 0f84 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1526 0f87 BA000000 		mov	edx, 0
 1526      00
 1527 0f8c 8981D805 		mov	DWORD PTR [ecx+1496], eax
 1527      0000
 1528 0f92 8991DC05 		mov	DWORD PTR [ecx+1500], edx
 1528      0000
 404:guest.c       ****             else if (W)
 405:guest.c       ****                 guest.vmcb->rsp = Value & 0xFFFF;
 406:guest.c       ****             else
 407:guest.c       ****                 guest.vmcb->rsp = Value & 0xFF;
 408:guest.c       ****             break;
 1529              		.loc 1 408 0
 1530 0f98 E9F10000 		jmp	.L50
 1530      00
 1531              	.L72:
 404:guest.c       ****             else if (W)
 1532              		.loc 1 404 0
 1533 0f9d 807DF000 		cmp	BYTE PTR [ebp-16], 0
 1534 0fa1 7433     		je	.L74
 405:guest.c       ****             else
 1535              		.loc 1 405 0
 1536 0fa3 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1536      0000
 1537 0fa9 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1538 0fac BA000000 		mov	edx, 0
 1538      00
 1539 0fb1 0FB7D8   		movzx	ebx, ax
 1540 0fb4 895DD8   		mov	DWORD PTR [ebp-40], ebx
 1541 0fb7 89D0     		mov	eax, edx
 1542 0fb9 83E000   		and	eax, 0
 1543 0fbc 8945DC   		mov	DWORD PTR [ebp-36], eax
 1544 0fbf 8B45D8   		mov	eax, DWORD PTR [ebp-40]
 1545 0fc2 8B55DC   		mov	edx, DWORD PTR [ebp-36]
 1546 0fc5 8981D805 		mov	DWORD PTR [ecx+1496], eax
 1546      0000
 1547 0fcb 8991DC05 		mov	DWORD PTR [ecx+1500], edx
 1547      0000
 1548              		.loc 1 408 0
 1549 0fd1 E9B80000 		jmp	.L50
 1549      00
 1550              	.L74:
 407:guest.c       ****             break;
 1551              		.loc 1 407 0
 1552 0fd6 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1552      0000
 1553 0fdc 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1554 0fdf BA000000 		mov	edx, 0
 1554      00
 1555 0fe4 0FB6D8   		movzx	ebx, al
 1556 0fe7 89D0     		mov	eax, edx
 1557 0fe9 83E000   		and	eax, 0
 1558 0fec 89C6     		mov	esi, eax
 1559 0fee 8999D805 		mov	DWORD PTR [ecx+1496], ebx
 1559      0000
 1560 0ff4 89B1DC05 		mov	DWORD PTR [ecx+1500], esi
 1560      0000
 1561              		.loc 1 408 0
 1562 0ffa E98F0000 		jmp	.L50
 1562      00
 1563              	.L57:
 409:guest.c       ****         case MODRM_REG_EBP:
 410:guest.c       ****             if (DW)
 1564              		.loc 1 410 0
 1565 0fff 807DF400 		cmp	BYTE PTR [ebp-12], 0
 1566 1003 740A     		je	.L75
 411:guest.c       ****                 GuestRegisters[RAN_EBP] = Value;
 1567              		.loc 1 411 0
 1568 1005 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1569 1008 A3140000 		mov	DWORD PTR GuestRegisters+20, eax
 1569      00
 412:guest.c       ****             else if (W)
 413:guest.c       ****                 GuestRegisters[RAN_EBP] = Value & 0xFFFF;
 414:guest.c       ****             else
 415:guest.c       ****                 GuestRegisters[RAN_EBP] = Value & 0xFF;
 416:guest.c       ****             break;
 1570              		.loc 1 416 0
 1571 100d EB7F     		jmp	.L50
 1572              	.L75:
 412:guest.c       ****             else if (W)
 1573              		.loc 1 412 0
 1574 100f 807DF000 		cmp	BYTE PTR [ebp-16], 0
 1575 1013 740D     		je	.L77
 413:guest.c       ****             else
 1576              		.loc 1 413 0
 1577 1015 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1578 1018 0FB7C0   		movzx	eax, ax
 1579 101b A3140000 		mov	DWORD PTR GuestRegisters+20, eax
 1579      00
 1580              		.loc 1 416 0
 1581 1020 EB6C     		jmp	.L50
 1582              	.L77:
 415:guest.c       ****             break;
 1583              		.loc 1 415 0
 1584 1022 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1585 1025 0FB6C0   		movzx	eax, al
 1586 1028 A3140000 		mov	DWORD PTR GuestRegisters+20, eax
 1586      00
 1587              		.loc 1 416 0
 1588 102d EB5F     		jmp	.L50
 1589              	.L58:
 417:guest.c       ****         case MODRM_REG_ESI:
 418:guest.c       ****             if (DW)
 1590              		.loc 1 418 0
 1591 102f 807DF400 		cmp	BYTE PTR [ebp-12], 0
 1592 1033 740A     		je	.L78
 419:guest.c       ****                 GuestRegisters[RAN_ESI] = Value;
 1593              		.loc 1 419 0
 1594 1035 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1595 1038 A30C0000 		mov	DWORD PTR GuestRegisters+12, eax
 1595      00
 420:guest.c       ****             else if (W)
 421:guest.c       ****                 GuestRegisters[RAN_ESI] = Value & 0xFFFF;
 422:guest.c       ****             else
 423:guest.c       ****                 GuestRegisters[RAN_ESI] = Value & 0xFF;
 424:guest.c       ****             break;
 1596              		.loc 1 424 0
 1597 103d EB4F     		jmp	.L50
 1598              	.L78:
 420:guest.c       ****             else if (W)
 1599              		.loc 1 420 0
 1600 103f 807DF000 		cmp	BYTE PTR [ebp-16], 0
 1601 1043 740D     		je	.L80
 421:guest.c       ****             else
 1602              		.loc 1 421 0
 1603 1045 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1604 1048 0FB7C0   		movzx	eax, ax
 1605 104b A30C0000 		mov	DWORD PTR GuestRegisters+12, eax
 1605      00
 1606              		.loc 1 424 0
 1607 1050 EB3C     		jmp	.L50
 1608              	.L80:
 423:guest.c       ****             break;
 1609              		.loc 1 423 0
 1610 1052 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1611 1055 0FB6C0   		movzx	eax, al
 1612 1058 A30C0000 		mov	DWORD PTR GuestRegisters+12, eax
 1612      00
 1613              		.loc 1 424 0
 1614 105d EB2F     		jmp	.L50
 1615              	.L59:
 425:guest.c       ****         case MODRM_REG_EDI:
 426:guest.c       ****             if (DW)
 1616              		.loc 1 426 0
 1617 105f 807DF400 		cmp	BYTE PTR [ebp-12], 0
 1618 1063 740A     		je	.L81
 427:guest.c       ****                 GuestRegisters[RAN_EDI] = Value;
 1619              		.loc 1 427 0
 1620 1065 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1621 1068 A3100000 		mov	DWORD PTR GuestRegisters+16, eax
 1621      00
 428:guest.c       ****             else if (W)
 429:guest.c       ****                 GuestRegisters[RAN_EDI] = Value & 0xFFFF;
 430:guest.c       ****             else
 431:guest.c       ****                 GuestRegisters[RAN_EDI] = Value & 0xFF;
 432:guest.c       ****             break;
 1622              		.loc 1 432 0
 1623 106d EB1E     		jmp	.L85
 1624              	.L81:
 428:guest.c       ****             else if (W)
 1625              		.loc 1 428 0
 1626 106f 807DF000 		cmp	BYTE PTR [ebp-16], 0
 1627 1073 740D     		je	.L83
 429:guest.c       ****             else
 1628              		.loc 1 429 0
 1629 1075 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1630 1078 0FB7C0   		movzx	eax, ax
 1631 107b A3100000 		mov	DWORD PTR GuestRegisters+16, eax
 1631      00
 1632              		.loc 1 432 0
 1633 1080 EB0B     		jmp	.L85
 1634              	.L83:
 431:guest.c       ****             break;
 1635              		.loc 1 431 0
 1636 1082 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1637 1085 0FB6C0   		movzx	eax, al
 1638 1088 A3100000 		mov	DWORD PTR GuestRegisters+16, eax
 1638      00
 1639              	.L85:
 1640              		.loc 1 432 0
 1641 108d 90       		nop
 1642              	.L50:
 1643              	.L84:
 433:guest.c       ****     }    
 434:guest.c       **** }
 1644              		.loc 1 434 0
 1645 108e 90       		nop
 1646 108f 83C420   		add	esp, 32
 1647 1092 5B       		pop	ebx
 1648              		.cfi_restore 3
 1649 1093 5E       		pop	esi
 1650              		.cfi_restore 6
 1651 1094 5D       		pop	ebp
 1652              		.cfi_restore 5
 1653              		.cfi_def_cfa 4, 4
 1654 1095 C3       		ret
 1655              		.cfi_endproc
 1656              	.LFE11:
 1658              		.globl	GetGPRValue
 1660              	GetGPRValue:
 1661              	.LFB12:
 435:guest.c       **** DWORD GetGPRValue(int GPRNumber, bool DW, bool W)
 436:guest.c       **** {
 1662              		.loc 1 436 0
 1663              		.cfi_startproc
 1664 1096 55       		push	ebp
 1665              		.cfi_def_cfa_offset 8
 1666              		.cfi_offset 5, -8
 1667 1097 89E5     		mov	ebp, esp
 1668              		.cfi_def_cfa_register 5
 1669 1099 83EC08   		sub	esp, 8
 1670 109c 8B550C   		mov	edx, DWORD PTR [ebp+12]
 1671 109f 8B4510   		mov	eax, DWORD PTR [ebp+16]
 1672 10a2 8855FC   		mov	BYTE PTR [ebp-4], dl
 1673 10a5 8845F8   		mov	BYTE PTR [ebp-8], al
 437:guest.c       ****     switch (GPRNumber)
 1674              		.loc 1 437 0
 1675 10a8 837D0807 		cmp	DWORD PTR [ebp+8], 7
 1676 10ac 0F87C801 		ja	.L87
 1676      0000
 1677 10b2 8B4508   		mov	eax, DWORD PTR [ebp+8]
 1678 10b5 C1E002   		sal	eax, 2
 1679 10b8 05200000 		add	eax, OFFSET FLAT:.L89
 1679      00
 1680 10bd 8B00     		mov	eax, DWORD PTR [eax]
 1681 10bf FFE0     		jmp	eax
 1682              		.section	.rodata
 1683              		.align 4
 1684              		.align 4
 1685              	.L89:
 1686 0020 C1100000 		.long	.L88
 1687 0024 15110000 		.long	.L90
 1688 0028 45110000 		.long	.L91
 1689 002c 75110000 		.long	.L92
 1690 0030 A5110000 		.long	.L93
 1691 0034 F9110000 		.long	.L94
 1692 0038 29120000 		.long	.L95
 1693 003c 53120000 		.long	.L96
 1694              		.text
 1695              	.L88:
 438:guest.c       ****     {
 439:guest.c       ****         case MODRM_REG_EAX:
 440:guest.c       ****             if (DW)
 1696              		.loc 1 440 0
 1697 10c1 807DFC00 		cmp	BYTE PTR [ebp-4], 0
 1698 10c5 7416     		je	.L97
 441:guest.c       ****                 return guest.vmcb->rax & 0xffffffff;
 1699              		.loc 1 441 0
 1700 10c7 A1040000 		mov	eax, DWORD PTR guest+4
 1700      00
 1701 10cc 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 1701      0000
 1702 10d2 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 1702      0000
 1703 10d8 E9E60100 		jmp	.L98
 1703      00
 1704              	.L97:
 442:guest.c       ****             else if (W)
 1705              		.loc 1 442 0
 1706 10dd 807DF800 		cmp	BYTE PTR [ebp-8], 0
 1707 10e1 7419     		je	.L99
 443:guest.c       ****                 return guest.vmcb->rax & 0xffff;
 1708              		.loc 1 443 0
 1709 10e3 A1040000 		mov	eax, DWORD PTR guest+4
 1709      00
 1710 10e8 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 1710      0000
 1711 10ee 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 1711      0000
 1712 10f4 0FB7C0   		movzx	eax, ax
 1713 10f7 E9C70100 		jmp	.L98
 1713      00
 1714              	.L99:
 444:guest.c       ****             else
 445:guest.c       ****                 return guest.vmcb->rax & 0xff;
 1715              		.loc 1 445 0
 1716 10fc A1040000 		mov	eax, DWORD PTR guest+4
 1716      00
 1717 1101 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 1717      0000
 1718 1107 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 1718      0000
 1719 110d 0FB6C0   		movzx	eax, al
 1720 1110 E9AE0100 		jmp	.L98
 1720      00
 1721              	.L90:
 446:guest.c       ****         case MODRM_REG_ECX:
 447:guest.c       ****             if (DW)
 1722              		.loc 1 447 0
 1723 1115 807DFC00 		cmp	BYTE PTR [ebp-4], 0
 1724 1119 740A     		je	.L100
 448:guest.c       ****                 return GuestRegisters[RAN_ECX] & 0xFFFFFFFF;
 1725              		.loc 1 448 0
 1726 111b A1040000 		mov	eax, DWORD PTR GuestRegisters+4
 1726      00
 1727 1120 E99E0100 		jmp	.L98
 1727      00
 1728              	.L100:
 449:guest.c       ****             else if (W)
 1729              		.loc 1 449 0
 1730 1125 807DF800 		cmp	BYTE PTR [ebp-8], 0
 1731 1129 740D     		je	.L101
 450:guest.c       ****                 return GuestRegisters[RAN_ECX] & 0xFFFF;
 1732              		.loc 1 450 0
 1733 112b A1040000 		mov	eax, DWORD PTR GuestRegisters+4
 1733      00
 1734 1130 0FB7C0   		movzx	eax, ax
 1735 1133 E98B0100 		jmp	.L98
 1735      00
 1736              	.L101:
 451:guest.c       ****             else
 452:guest.c       ****                 return GuestRegisters[RAN_ECX] & 0xFF;
 1737              		.loc 1 452 0
 1738 1138 A1040000 		mov	eax, DWORD PTR GuestRegisters+4
 1738      00
 1739 113d 0FB6C0   		movzx	eax, al
 1740 1140 E97E0100 		jmp	.L98
 1740      00
 1741              	.L91:
 453:guest.c       ****         case MODRM_REG_EDX:
 454:guest.c       ****             if (DW)
 1742              		.loc 1 454 0
 1743 1145 807DFC00 		cmp	BYTE PTR [ebp-4], 0
 1744 1149 740A     		je	.L102
 455:guest.c       ****                 return GuestRegisters[RAN_EDX] & 0xFFFFFFFF;
 1745              		.loc 1 455 0
 1746 114b A1080000 		mov	eax, DWORD PTR GuestRegisters+8
 1746      00
 1747 1150 E96E0100 		jmp	.L98
 1747      00
 1748              	.L102:
 456:guest.c       ****             else if (W)
 1749              		.loc 1 456 0
 1750 1155 807DF800 		cmp	BYTE PTR [ebp-8], 0
 1751 1159 740D     		je	.L103
 457:guest.c       ****                 return GuestRegisters[RAN_EDX] & 0xFFFF;
 1752              		.loc 1 457 0
 1753 115b A1080000 		mov	eax, DWORD PTR GuestRegisters+8
 1753      00
 1754 1160 0FB7C0   		movzx	eax, ax
 1755 1163 E95B0100 		jmp	.L98
 1755      00
 1756              	.L103:
 458:guest.c       ****             else
 459:guest.c       ****                 return GuestRegisters[RAN_EDX] & 0xFF;
 1757              		.loc 1 459 0
 1758 1168 A1080000 		mov	eax, DWORD PTR GuestRegisters+8
 1758      00
 1759 116d 0FB6C0   		movzx	eax, al
 1760 1170 E94E0100 		jmp	.L98
 1760      00
 1761              	.L92:
 460:guest.c       ****         case MODRM_REG_EBX:
 461:guest.c       ****             if (DW)
 1762              		.loc 1 461 0
 1763 1175 807DFC00 		cmp	BYTE PTR [ebp-4], 0
 1764 1179 740A     		je	.L104
 462:guest.c       ****                 return GuestRegisters[RAN_EBX] & 0xFFFFFFFF;
 1765              		.loc 1 462 0
 1766 117b A1000000 		mov	eax, DWORD PTR GuestRegisters
 1766      00
 1767 1180 E93E0100 		jmp	.L98
 1767      00
 1768              	.L104:
 463:guest.c       ****             else if (W)
 1769              		.loc 1 463 0
 1770 1185 807DF800 		cmp	BYTE PTR [ebp-8], 0
 1771 1189 740D     		je	.L105
 464:guest.c       ****                 return GuestRegisters[RAN_EBX] & 0xFFFF;
 1772              		.loc 1 464 0
 1773 118b A1000000 		mov	eax, DWORD PTR GuestRegisters
 1773      00
 1774 1190 0FB7C0   		movzx	eax, ax
 1775 1193 E92B0100 		jmp	.L98
 1775      00
 1776              	.L105:
 465:guest.c       ****             else
 466:guest.c       ****                 return GuestRegisters[RAN_EBX] & 0xFF;
 1777              		.loc 1 466 0
 1778 1198 A1000000 		mov	eax, DWORD PTR GuestRegisters
 1778      00
 1779 119d 0FB6C0   		movzx	eax, al
 1780 11a0 E91E0100 		jmp	.L98
 1780      00
 1781              	.L93:
 467:guest.c       ****         case MODRM_REG_ESP:
 468:guest.c       ****             if (DW)
 1782              		.loc 1 468 0
 1783 11a5 807DFC00 		cmp	BYTE PTR [ebp-4], 0
 1784 11a9 7416     		je	.L106
 469:guest.c       ****                 return guest.vmcb->rsp & 0xffffffff;
 1785              		.loc 1 469 0
 1786 11ab A1040000 		mov	eax, DWORD PTR guest+4
 1786      00
 1787 11b0 8B90DC05 		mov	edx, DWORD PTR [eax+1500]
 1787      0000
 1788 11b6 8B80D805 		mov	eax, DWORD PTR [eax+1496]
 1788      0000
 1789 11bc E9020100 		jmp	.L98
 1789      00
 1790              	.L106:
 470:guest.c       ****             else if (W)
 1791              		.loc 1 470 0
 1792 11c1 807DF800 		cmp	BYTE PTR [ebp-8], 0
 1793 11c5 7419     		je	.L107
 471:guest.c       ****                 return guest.vmcb->rsp & 0xffff;
 1794              		.loc 1 471 0
 1795 11c7 A1040000 		mov	eax, DWORD PTR guest+4
 1795      00
 1796 11cc 8B90DC05 		mov	edx, DWORD PTR [eax+1500]
 1796      0000
 1797 11d2 8B80D805 		mov	eax, DWORD PTR [eax+1496]
 1797      0000
 1798 11d8 0FB7C0   		movzx	eax, ax
 1799 11db E9E30000 		jmp	.L98
 1799      00
 1800              	.L107:
 472:guest.c       ****             else
 473:guest.c       ****                 return guest.vmcb->rsp & 0xff;
 1801              		.loc 1 473 0
 1802 11e0 A1040000 		mov	eax, DWORD PTR guest+4
 1802      00
 1803 11e5 8B90DC05 		mov	edx, DWORD PTR [eax+1500]
 1803      0000
 1804 11eb 8B80D805 		mov	eax, DWORD PTR [eax+1496]
 1804      0000
 1805 11f1 0FB6C0   		movzx	eax, al
 1806 11f4 E9CA0000 		jmp	.L98
 1806      00
 1807              	.L94:
 474:guest.c       ****         case MODRM_REG_EBP:
 475:guest.c       ****             if (DW)
 1808              		.loc 1 475 0
 1809 11f9 807DFC00 		cmp	BYTE PTR [ebp-4], 0
 1810 11fd 740A     		je	.L108
 476:guest.c       ****                 return GuestRegisters[RAN_EBP] & 0xFFFFFFFF;
 1811              		.loc 1 476 0
 1812 11ff A1140000 		mov	eax, DWORD PTR GuestRegisters+20
 1812      00
 1813 1204 E9BA0000 		jmp	.L98
 1813      00
 1814              	.L108:
 477:guest.c       ****             else if (W)
 1815              		.loc 1 477 0
 1816 1209 807DF800 		cmp	BYTE PTR [ebp-8], 0
 1817 120d 740D     		je	.L109
 478:guest.c       ****                 return GuestRegisters[RAN_EBP] & 0xFFFF;
 1818              		.loc 1 478 0
 1819 120f A1140000 		mov	eax, DWORD PTR GuestRegisters+20
 1819      00
 1820 1214 0FB7C0   		movzx	eax, ax
 1821 1217 E9A70000 		jmp	.L98
 1821      00
 1822              	.L109:
 479:guest.c       ****             else
 480:guest.c       ****                 return GuestRegisters[RAN_EBP] & 0xFF;
 1823              		.loc 1 480 0
 1824 121c A1140000 		mov	eax, DWORD PTR GuestRegisters+20
 1824      00
 1825 1221 0FB6C0   		movzx	eax, al
 1826 1224 E99A0000 		jmp	.L98
 1826      00
 1827              	.L95:
 481:guest.c       ****         case MODRM_REG_ESI:
 482:guest.c       ****             if (DW)
 1828              		.loc 1 482 0
 1829 1229 807DFC00 		cmp	BYTE PTR [ebp-4], 0
 1830 122d 740A     		je	.L110
 483:guest.c       ****                 return GuestRegisters[RAN_ESI] & 0xFFFFFFFF;
 1831              		.loc 1 483 0
 1832 122f A10C0000 		mov	eax, DWORD PTR GuestRegisters+12
 1832      00
 1833 1234 E98A0000 		jmp	.L98
 1833      00
 1834              	.L110:
 484:guest.c       ****             else if (W)
 1835              		.loc 1 484 0
 1836 1239 807DF800 		cmp	BYTE PTR [ebp-8], 0
 1837 123d 740A     		je	.L111
 485:guest.c       ****                 return GuestRegisters[RAN_ESI] & 0xFFFF;
 1838              		.loc 1 485 0
 1839 123f A10C0000 		mov	eax, DWORD PTR GuestRegisters+12
 1839      00
 1840 1244 0FB7C0   		movzx	eax, ax
 1841 1247 EB7A     		jmp	.L98
 1842              	.L111:
 486:guest.c       ****             else
 487:guest.c       ****                 return GuestRegisters[RAN_ESI] & 0xFF;
 1843              		.loc 1 487 0
 1844 1249 A10C0000 		mov	eax, DWORD PTR GuestRegisters+12
 1844      00
 1845 124e 0FB6C0   		movzx	eax, al
 1846 1251 EB70     		jmp	.L98
 1847              	.L96:
 488:guest.c       ****         case MODRM_REG_EDI:
 489:guest.c       ****             if (DW)
 1848              		.loc 1 489 0
 1849 1253 807DFC00 		cmp	BYTE PTR [ebp-4], 0
 1850 1257 7407     		je	.L112
 490:guest.c       ****                 return GuestRegisters[RAN_EDI] & 0xFFFFFFFF;
 1851              		.loc 1 490 0
 1852 1259 A1100000 		mov	eax, DWORD PTR GuestRegisters+16
 1852      00
 1853 125e EB63     		jmp	.L98
 1854              	.L112:
 491:guest.c       ****             else if (W)
 1855              		.loc 1 491 0
 1856 1260 807DF800 		cmp	BYTE PTR [ebp-8], 0
 1857 1264 740A     		je	.L113
 492:guest.c       ****                 return GuestRegisters[RAN_EDI] & 0xFFFF;
 1858              		.loc 1 492 0
 1859 1266 A1100000 		mov	eax, DWORD PTR GuestRegisters+16
 1859      00
 1860 126b 0FB7C0   		movzx	eax, ax
 1861 126e EB53     		jmp	.L98
 1862              	.L113:
 493:guest.c       ****             else
 494:guest.c       ****                 return GuestRegisters[RAN_EDI] & 0xFF;
 1863              		.loc 1 494 0
 1864 1270 A1100000 		mov	eax, DWORD PTR GuestRegisters+16
 1864      00
 1865 1275 0FB6C0   		movzx	eax, al
 1866 1278 EB49     		jmp	.L98
 1867              	.L87:
 495:guest.c       ****         default:
 496:guest.c       ****             if (DW)
 1868              		.loc 1 496 0
 1869 127a 807DFC00 		cmp	BYTE PTR [ebp-4], 0
 1870 127e 7413     		je	.L114
 497:guest.c       ****                 return guest.vmcb->rax & 0xffffffff;
 1871              		.loc 1 497 0
 1872 1280 A1040000 		mov	eax, DWORD PTR guest+4
 1872      00
 1873 1285 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 1873      0000
 1874 128b 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 1874      0000
 1875 1291 EB30     		jmp	.L98
 1876              	.L114:
 498:guest.c       ****             else if (W)
 1877              		.loc 1 498 0
 1878 1293 807DF800 		cmp	BYTE PTR [ebp-8], 0
 1879 1297 7416     		je	.L115
 499:guest.c       ****                 return guest.vmcb->rax & 0xffff;
 1880              		.loc 1 499 0
 1881 1299 A1040000 		mov	eax, DWORD PTR guest+4
 1881      00
 1882 129e 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 1882      0000
 1883 12a4 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 1883      0000
 1884 12aa 0FB7C0   		movzx	eax, ax
 1885 12ad EB14     		jmp	.L98
 1886              	.L115:
 500:guest.c       ****             else
 501:guest.c       ****                 return guest.vmcb->rax & 0xff;
 1887              		.loc 1 501 0
 1888 12af A1040000 		mov	eax, DWORD PTR guest+4
 1888      00
 1889 12b4 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 1889      0000
 1890 12ba 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 1890      0000
 1891 12c0 0FB6C0   		movzx	eax, al
 1892              	.L98:
 502:guest.c       ****     }
 503:guest.c       **** }
 1893              		.loc 1 503 0
 1894 12c3 C9       		leave
 1895              		.cfi_restore 5
 1896              		.cfi_def_cfa 4, 4
 1897 12c4 C3       		ret
 1898              		.cfi_endproc
 1899              	.LFE12:
 1901              		.globl	HandleCR3Write
 1903              	HandleCR3Write:
 1904              	.LFB13:
 504:guest.c       **** 
 505:guest.c       **** void HandleCR3Write()
 506:guest.c       **** {
 1905              		.loc 1 506 0
 1906              		.cfi_startproc
 1907 12c5 55       		push	ebp
 1908              		.cfi_def_cfa_offset 8
 1909              		.cfi_offset 5, -8
 1910 12c6 89E5     		mov	ebp, esp
 1911              		.cfi_def_cfa_register 5
 1912 12c8 83EC08   		sub	esp, 8
 507:guest.c       ****     if ( (guest.vmcb->exitinfo1 & 0x8000000000000000) == 0x8000000000000000)   //Instruction was a 
 1913              		.loc 1 507 0
 1914 12cb A1040000 		mov	eax, DWORD PTR guest+4
 1914      00
 1915 12d0 8B507C   		mov	edx, DWORD PTR [eax+124]
 1916 12d3 8B4078   		mov	eax, DWORD PTR [eax+120]
 1917 12d6 85D2     		test	edx, edx
 1918 12d8 7925     		jns	.L117
 508:guest.c       ****             guest.requestedCR3 = GetGPRValue(guest.vmcb->exitinfo1 & 0xFF, true, false);
 1919              		.loc 1 508 0
 1920 12da A1040000 		mov	eax, DWORD PTR guest+4
 1920      00
 1921 12df 8B507C   		mov	edx, DWORD PTR [eax+124]
 1922 12e2 8B4078   		mov	eax, DWORD PTR [eax+120]
 1923 12e5 0FB6C0   		movzx	eax, al
 1924 12e8 83EC04   		sub	esp, 4
 1925 12eb 6A00     		push	0
 1926 12ed 6A01     		push	1
 1927 12ef 50       		push	eax
 1928 12f0 E8FCFFFF 		call	GetGPRValue
 1928      FF
 1929 12f5 83C410   		add	esp, 16
 1930 12f8 A30C0000 		mov	DWORD PTR guest+12, eax
 1930      00
 1931 12fd EB16     		jmp	.L118
 1932              	.L117:
 509:guest.c       ****     else
 510:guest.c       ****         guest.requestedCR3 = GetGuestMODRegGenRegValue(2,true,false);
 1933              		.loc 1 510 0
 1934 12ff 83EC04   		sub	esp, 4
 1935 1302 6A00     		push	0
 1936 1304 6A01     		push	1
 1937 1306 6A02     		push	2
 1938 1308 E8FCFFFF 		call	GetGuestMODRegGenRegValue
 1938      FF
 1939 130d 83C410   		add	esp, 16
 1940 1310 A30C0000 		mov	DWORD PTR guest+12, eax
 1940      00
 1941              	.L118:
 511:guest.c       **** 
 512:guest.c       ****     //If guest paging is enabled and guest is in pmode then make the VMCB CR3
 513:guest.c       ****     //equal to the guest's previously requested CR3
 514:guest.c       ****     if (guestViewPMode && guestViewPaging)
 1942              		.loc 1 514 0
 1943 1315 A1140000 		mov	eax, DWORD PTR guest+20
 1943      00
 1944 131a 83E001   		and	eax, 1
 1945 131d 85C0     		test	eax, eax
 1946 131f 7425     		je	.L119
 1947              		.loc 1 514 0 is_stmt 0 discriminator 1
 1948 1321 A1140000 		mov	eax, DWORD PTR guest+20
 1948      00
 1949 1326 85C0     		test	eax, eax
 1950 1328 791C     		jns	.L119
 515:guest.c       ****     {
 516:guest.c       ****         guest.vmcb->cr3 = guest.requestedCR3;
 1951              		.loc 1 516 0 is_stmt 1
 1952 132a 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1952      0000
 1953 1330 A10C0000 		mov	eax, DWORD PTR guest+12
 1953      00
 1954 1335 BA000000 		mov	edx, 0
 1954      00
 1955 133a 89815005 		mov	DWORD PTR [ecx+1360], eax
 1955      0000
 1956 1340 89915405 		mov	DWORD PTR [ecx+1364], edx
 1956      0000
 1957              	.L119:
 517:guest.c       ****         //guest.vmcb->tlb_control = 0x07;
 518:guest.c       ****     }
 519:guest.c       ****     guest.vmcb->rip = guest.vmcb->nextrip;
 1958              		.loc 1 519 0
 1959 1346 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1959      0000
 1960 134c A1040000 		mov	eax, DWORD PTR guest+4
 1960      00
 1961 1351 8B90CC00 		mov	edx, DWORD PTR [eax+204]
 1961      0000
 1962 1357 8B80C800 		mov	eax, DWORD PTR [eax+200]
 1962      0000
 1963 135d 89817805 		mov	DWORD PTR [ecx+1400], eax
 1963      0000
 1964 1363 89917C05 		mov	DWORD PTR [ecx+1404], edx
 1964      0000
 520:guest.c       **** }
 1965              		.loc 1 520 0
 1966 1369 90       		nop
 1967 136a C9       		leave
 1968              		.cfi_restore 5
 1969              		.cfi_def_cfa 4, 4
 1970 136b C3       		ret
 1971              		.cfi_endproc
 1972              	.LFE13:
 1974              		.globl	HandleCR3Read
 1976              	HandleCR3Read:
 1977              	.LFB14:
 521:guest.c       **** 
 522:guest.c       **** void HandleCR3Read()
 523:guest.c       **** {
 1978              		.loc 1 523 0
 1979              		.cfi_startproc
 1980 136c 55       		push	ebp
 1981              		.cfi_def_cfa_offset 8
 1982              		.cfi_offset 5, -8
 1983 136d 89E5     		mov	ebp, esp
 1984              		.cfi_def_cfa_register 5
 1985 136f 83EC08   		sub	esp, 8
 524:guest.c       ****     if ( (guest.vmcb->exitinfo1 & 0x8000000000000000) == 0x8000000000000000)   //Instruction was a 
 1986              		.loc 1 524 0
 1987 1372 A1040000 		mov	eax, DWORD PTR guest+4
 1987      00
 1988 1377 8B507C   		mov	edx, DWORD PTR [eax+124]
 1989 137a 8B4078   		mov	eax, DWORD PTR [eax+120]
 1990 137d 85D2     		test	edx, edx
 1991 137f 7924     		jns	.L121
 525:guest.c       ****         SetGPRValue(guest.vmcb->exitinfo1 & 0xFF, guest.requestedCR3, true, false);
 1992              		.loc 1 525 0
 1993 1381 8B0D0C00 		mov	ecx, DWORD PTR guest+12
 1993      0000
 1994 1387 A1040000 		mov	eax, DWORD PTR guest+4
 1994      00
 1995 138c 8B507C   		mov	edx, DWORD PTR [eax+124]
 1996 138f 8B4078   		mov	eax, DWORD PTR [eax+120]
 1997 1392 0FB6C0   		movzx	eax, al
 1998 1395 6A00     		push	0
 1999 1397 6A01     		push	1
 2000 1399 51       		push	ecx
 2001 139a 50       		push	eax
 2002 139b E8FCFFFF 		call	SetGPRValue
 2002      FF
 2003 13a0 83C410   		add	esp, 16
 2004 13a3 EB14     		jmp	.L122
 2005              	.L121:
 526:guest.c       **** else
 527:guest.c       ****     SetGuestMODRegGenRegValue(2,guest.requestedCR3, true, false);
 2006              		.loc 1 527 0
 2007 13a5 A10C0000 		mov	eax, DWORD PTR guest+12
 2007      00
 2008 13aa 6A00     		push	0
 2009 13ac 6A01     		push	1
 2010 13ae 50       		push	eax
 2011 13af 6A02     		push	2
 2012 13b1 E8FCFFFF 		call	SetGuestMODRegGenRegValue
 2012      FF
 2013 13b6 83C410   		add	esp, 16
 2014              	.L122:
 528:guest.c       **** guest.vmcb->rip = guest.vmcb->nextrip;
 2015              		.loc 1 528 0
 2016 13b9 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2016      0000
 2017 13bf A1040000 		mov	eax, DWORD PTR guest+4
 2017      00
 2018 13c4 8B90CC00 		mov	edx, DWORD PTR [eax+204]
 2018      0000
 2019 13ca 8B80C800 		mov	eax, DWORD PTR [eax+200]
 2019      0000
 2020 13d0 89817805 		mov	DWORD PTR [ecx+1400], eax
 2020      0000
 2021 13d6 89917C05 		mov	DWORD PTR [ecx+1404], edx
 2021      0000
 529:guest.c       **** }
 2022              		.loc 1 529 0
 2023 13dc 90       		nop
 2024 13dd C9       		leave
 2025              		.cfi_restore 5
 2026              		.cfi_def_cfa 4, 4
 2027 13de C3       		ret
 2028              		.cfi_endproc
 2029              	.LFE14:
 2031              		.globl	GetGuestMODRegGenRegValue
 2033              	GetGuestMODRegGenRegValue:
 2034              	.LFB15:
 530:guest.c       **** 
 531:guest.c       **** DWORD GetGuestMODRegGenRegValue(BYTE RegOffsetFromCurrIns, bool DW, bool W)
 532:guest.c       **** {
 2035              		.loc 1 532 0
 2036              		.cfi_startproc
 2037 13df 55       		push	ebp
 2038              		.cfi_def_cfa_offset 8
 2039              		.cfi_offset 5, -8
 2040 13e0 89E5     		mov	ebp, esp
 2041              		.cfi_def_cfa_register 5
 2042 13e2 83EC28   		sub	esp, 40
 2043 13e5 8B4D08   		mov	ecx, DWORD PTR [ebp+8]
 2044 13e8 8B550C   		mov	edx, DWORD PTR [ebp+12]
 2045 13eb 8B4510   		mov	eax, DWORD PTR [ebp+16]
 2046 13ee 884DE4   		mov	BYTE PTR [ebp-28], cl
 2047 13f1 8855E0   		mov	BYTE PTR [ebp-32], dl
 2048 13f4 8845DC   		mov	BYTE PTR [ebp-36], al
 533:guest.c       **** 	BYTE reg = 0;
 2049              		.loc 1 533 0
 2050 13f7 C645F700 		mov	BYTE PTR [ebp-9], 0
 534:guest.c       **** 	
 535:guest.c       ****         reg = GetMemB(guest.vmcb->cs.base + guest.vmcb->rip + RegOffsetFromCurrIns,true);
 2051              		.loc 1 535 0
 2052 13fb A1040000 		mov	eax, DWORD PTR guest+4
 2052      00
 2053 1400 8B901C04 		mov	edx, DWORD PTR [eax+1052]
 2053      0000
 2054 1406 8B801804 		mov	eax, DWORD PTR [eax+1048]
 2054      0000
 2055 140c 89C1     		mov	ecx, eax
 2056 140e A1040000 		mov	eax, DWORD PTR guest+4
 2056      00
 2057 1413 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 2057      0000
 2058 1419 8B807805 		mov	eax, DWORD PTR [eax+1400]
 2058      0000
 2059 141f 8D1401   		lea	edx, [ecx+eax]
 2060 1422 0FB645E4 		movzx	eax, BYTE PTR [ebp-28]
 2061 1426 01D0     		add	eax, edx
 2062 1428 83EC08   		sub	esp, 8
 2063 142b 6A01     		push	1
 2064 142d 50       		push	eax
 2065 142e E8FCFFFF 		call	GetMemB
 2065      FF
 2066 1433 83C410   		add	esp, 16
 2067 1436 8845F7   		mov	BYTE PTR [ebp-9], al
 536:guest.c       **** 
 537:guest.c       **** 	switch ( reg & 0x7) //ModRM specifies general register
 2068              		.loc 1 537 0
 2069 1439 0FB645F7 		movzx	eax, BYTE PTR [ebp-9]
 2070 143d 83E007   		and	eax, 7
 2071 1440 83F807   		cmp	eax, 7
 2072 1443 0F87B601 		ja	.L124
 2072      0000
 2073 1449 8B048540 		mov	eax, DWORD PTR .L126[0+eax*4]
 2073      000000
 2074 1450 FFE0     		jmp	eax
 2075              		.section	.rodata
 2076              		.align 4
 2077              		.align 4
 2078              	.L126:
 2079 0040 52140000 		.long	.L125
 2080 0044 A9140000 		.long	.L127
 2081 0048 D9140000 		.long	.L128
 2082 004c 09150000 		.long	.L129
 2083 0050 39150000 		.long	.L130
 2084 0054 8A150000 		.long	.L131
 2085 0058 B1150000 		.long	.L132
 2086 005c D8150000 		.long	.L133
 2087              		.text
 2088              	.L125:
 538:guest.c       **** 	{
 539:guest.c       **** 		case MODRM_REG_EAX:
 540:guest.c       **** 			if (DW)
 2089              		.loc 1 540 0
 2090 1452 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2091 1456 7419     		je	.L134
 541:guest.c       **** 				return (BYTE)guest.vmcb->rax;
 2092              		.loc 1 541 0
 2093 1458 A1040000 		mov	eax, DWORD PTR guest+4
 2093      00
 2094 145d 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2094      0000
 2095 1463 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2095      0000
 2096 1469 0FB6C0   		movzx	eax, al
 2097 146c E9930100 		jmp	.L135
 2097      00
 2098              	.L134:
 542:guest.c       **** 			else if (W)
 2099              		.loc 1 542 0
 2100 1471 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2101 1475 7419     		je	.L136
 543:guest.c       **** 				return (BYTE)guest.vmcb->rax;
 2102              		.loc 1 543 0
 2103 1477 A1040000 		mov	eax, DWORD PTR guest+4
 2103      00
 2104 147c 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2104      0000
 2105 1482 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2105      0000
 2106 1488 0FB6C0   		movzx	eax, al
 2107 148b E9740100 		jmp	.L135
 2107      00
 2108              	.L136:
 544:guest.c       **** 			else
 545:guest.c       **** 				return (BYTE)guest.vmcb->rax;
 2109              		.loc 1 545 0
 2110 1490 A1040000 		mov	eax, DWORD PTR guest+4
 2110      00
 2111 1495 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2111      0000
 2112 149b 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2112      0000
 2113 14a1 0FB6C0   		movzx	eax, al
 2114 14a4 E95B0100 		jmp	.L135
 2114      00
 2115              	.L127:
 546:guest.c       **** 		case MODRM_REG_ECX:
 547:guest.c       **** 			if (DW)
 2116              		.loc 1 547 0
 2117 14a9 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2118 14ad 740A     		je	.L137
 548:guest.c       **** 				return GuestRegisters[RAN_ECX]; 
 2119              		.loc 1 548 0
 2120 14af A1040000 		mov	eax, DWORD PTR GuestRegisters+4
 2120      00
 2121 14b4 E94B0100 		jmp	.L135
 2121      00
 2122              	.L137:
 549:guest.c       **** 			else if (W)
 2123              		.loc 1 549 0
 2124 14b9 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2125 14bd 740D     		je	.L138
 550:guest.c       **** 				return (WORD)GuestRegisters[RAN_ECX]; 
 2126              		.loc 1 550 0
 2127 14bf A1040000 		mov	eax, DWORD PTR GuestRegisters+4
 2127      00
 2128 14c4 0FB7C0   		movzx	eax, ax
 2129 14c7 E9380100 		jmp	.L135
 2129      00
 2130              	.L138:
 551:guest.c       **** 			else
 552:guest.c       **** 				return (BYTE)GuestRegisters[RAN_ECX]; 
 2131              		.loc 1 552 0
 2132 14cc A1040000 		mov	eax, DWORD PTR GuestRegisters+4
 2132      00
 2133 14d1 0FB6C0   		movzx	eax, al
 2134 14d4 E92B0100 		jmp	.L135
 2134      00
 2135              	.L128:
 553:guest.c       **** 		case MODRM_REG_EDX:
 554:guest.c       **** 			if (DW)
 2136              		.loc 1 554 0
 2137 14d9 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2138 14dd 740A     		je	.L139
 555:guest.c       **** 				return GuestRegisters[RAN_EDX]; 
 2139              		.loc 1 555 0
 2140 14df A1080000 		mov	eax, DWORD PTR GuestRegisters+8
 2140      00
 2141 14e4 E91B0100 		jmp	.L135
 2141      00
 2142              	.L139:
 556:guest.c       **** 			else if (W)
 2143              		.loc 1 556 0
 2144 14e9 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2145 14ed 740D     		je	.L140
 557:guest.c       **** 				return (WORD)GuestRegisters[RAN_EDX]; 
 2146              		.loc 1 557 0
 2147 14ef A1080000 		mov	eax, DWORD PTR GuestRegisters+8
 2147      00
 2148 14f4 0FB7C0   		movzx	eax, ax
 2149 14f7 E9080100 		jmp	.L135
 2149      00
 2150              	.L140:
 558:guest.c       **** 			else
 559:guest.c       **** 				return (BYTE)GuestRegisters[RAN_EDX]; 
 2151              		.loc 1 559 0
 2152 14fc A1080000 		mov	eax, DWORD PTR GuestRegisters+8
 2152      00
 2153 1501 0FB6C0   		movzx	eax, al
 2154 1504 E9FB0000 		jmp	.L135
 2154      00
 2155              	.L129:
 560:guest.c       **** 		case MODRM_REG_EBX:
 561:guest.c       **** 			if (DW)
 2156              		.loc 1 561 0
 2157 1509 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2158 150d 740A     		je	.L141
 562:guest.c       **** 				return GuestRegisters[RAN_EBX]; 
 2159              		.loc 1 562 0
 2160 150f A1000000 		mov	eax, DWORD PTR GuestRegisters
 2160      00
 2161 1514 E9EB0000 		jmp	.L135
 2161      00
 2162              	.L141:
 563:guest.c       **** 			else if (W)
 2163              		.loc 1 563 0
 2164 1519 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2165 151d 740D     		je	.L142
 564:guest.c       **** 				return (WORD)GuestRegisters[RAN_EBX]; 
 2166              		.loc 1 564 0
 2167 151f A1000000 		mov	eax, DWORD PTR GuestRegisters
 2167      00
 2168 1524 0FB7C0   		movzx	eax, ax
 2169 1527 E9D80000 		jmp	.L135
 2169      00
 2170              	.L142:
 565:guest.c       **** 			else
 566:guest.c       **** 				return (BYTE)GuestRegisters[RAN_EBX]; 
 2171              		.loc 1 566 0
 2172 152c A1000000 		mov	eax, DWORD PTR GuestRegisters
 2172      00
 2173 1531 0FB6C0   		movzx	eax, al
 2174 1534 E9CB0000 		jmp	.L135
 2174      00
 2175              	.L130:
 567:guest.c       **** 		case MODRM_REG_ESP:
 568:guest.c       **** 			if (DW)
 2176              		.loc 1 568 0
 2177 1539 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2178 153d 7416     		je	.L143
 569:guest.c       **** 				return guest.vmcb->rsp;
 2179              		.loc 1 569 0
 2180 153f A1040000 		mov	eax, DWORD PTR guest+4
 2180      00
 2181 1544 8B90DC05 		mov	edx, DWORD PTR [eax+1500]
 2181      0000
 2182 154a 8B80D805 		mov	eax, DWORD PTR [eax+1496]
 2182      0000
 2183 1550 E9AF0000 		jmp	.L135
 2183      00
 2184              	.L143:
 570:guest.c       **** 			else if (W)
 2185              		.loc 1 570 0
 2186 1555 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2187 1559 7419     		je	.L144
 571:guest.c       **** 				return (WORD)guest.vmcb->rsp;
 2188              		.loc 1 571 0
 2189 155b A1040000 		mov	eax, DWORD PTR guest+4
 2189      00
 2190 1560 8B90DC05 		mov	edx, DWORD PTR [eax+1500]
 2190      0000
 2191 1566 8B80D805 		mov	eax, DWORD PTR [eax+1496]
 2191      0000
 2192 156c 0FB7C0   		movzx	eax, ax
 2193 156f E9900000 		jmp	.L135
 2193      00
 2194              	.L144:
 572:guest.c       **** 			else
 573:guest.c       **** 				return (BYTE)guest.vmcb->rsp;
 2195              		.loc 1 573 0
 2196 1574 A1040000 		mov	eax, DWORD PTR guest+4
 2196      00
 2197 1579 8B90DC05 		mov	edx, DWORD PTR [eax+1500]
 2197      0000
 2198 157f 8B80D805 		mov	eax, DWORD PTR [eax+1496]
 2198      0000
 2199 1585 0FB6C0   		movzx	eax, al
 2200 1588 EB7A     		jmp	.L135
 2201              	.L131:
 574:guest.c       **** 		case MODRM_REG_EBP:
 575:guest.c       **** 			if (DW)
 2202              		.loc 1 575 0
 2203 158a 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2204 158e 7407     		je	.L145
 576:guest.c       **** 				return GuestRegisters[RAN_EBP]; 
 2205              		.loc 1 576 0
 2206 1590 A1140000 		mov	eax, DWORD PTR GuestRegisters+20
 2206      00
 2207 1595 EB6D     		jmp	.L135
 2208              	.L145:
 577:guest.c       **** 			else if (W)
 2209              		.loc 1 577 0
 2210 1597 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2211 159b 740A     		je	.L146
 578:guest.c       **** 				return (WORD)GuestRegisters[RAN_EBP]; 
 2212              		.loc 1 578 0
 2213 159d A1140000 		mov	eax, DWORD PTR GuestRegisters+20
 2213      00
 2214 15a2 0FB7C0   		movzx	eax, ax
 2215 15a5 EB5D     		jmp	.L135
 2216              	.L146:
 579:guest.c       **** 			else
 580:guest.c       **** 				return (BYTE)GuestRegisters[RAN_EBP]; 
 2217              		.loc 1 580 0
 2218 15a7 A1140000 		mov	eax, DWORD PTR GuestRegisters+20
 2218      00
 2219 15ac 0FB6C0   		movzx	eax, al
 2220 15af EB53     		jmp	.L135
 2221              	.L132:
 581:guest.c       **** 		case MODRM_REG_ESI:
 582:guest.c       **** 			if (DW)
 2222              		.loc 1 582 0
 2223 15b1 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2224 15b5 7407     		je	.L147
 583:guest.c       **** 				return GuestRegisters[RAN_ESI]; 
 2225              		.loc 1 583 0
 2226 15b7 A10C0000 		mov	eax, DWORD PTR GuestRegisters+12
 2226      00
 2227 15bc EB46     		jmp	.L135
 2228              	.L147:
 584:guest.c       **** 			else if (W)
 2229              		.loc 1 584 0
 2230 15be 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2231 15c2 740A     		je	.L148
 585:guest.c       **** 				return (WORD)GuestRegisters[RAN_ESI]; 
 2232              		.loc 1 585 0
 2233 15c4 A10C0000 		mov	eax, DWORD PTR GuestRegisters+12
 2233      00
 2234 15c9 0FB7C0   		movzx	eax, ax
 2235 15cc EB36     		jmp	.L135
 2236              	.L148:
 586:guest.c       **** 			else
 587:guest.c       **** 				return (BYTE)GuestRegisters[RAN_ESI]; 
 2237              		.loc 1 587 0
 2238 15ce A10C0000 		mov	eax, DWORD PTR GuestRegisters+12
 2238      00
 2239 15d3 0FB6C0   		movzx	eax, al
 2240 15d6 EB2C     		jmp	.L135
 2241              	.L133:
 588:guest.c       **** 		case MODRM_REG_EDI:
 589:guest.c       **** 			if (DW)
 2242              		.loc 1 589 0
 2243 15d8 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2244 15dc 7407     		je	.L149
 590:guest.c       **** 				return GuestRegisters[RAN_EDI]; 
 2245              		.loc 1 590 0
 2246 15de A1100000 		mov	eax, DWORD PTR GuestRegisters+16
 2246      00
 2247 15e3 EB1F     		jmp	.L135
 2248              	.L149:
 591:guest.c       **** 			else if (W)
 2249              		.loc 1 591 0
 2250 15e5 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2251 15e9 740A     		je	.L150
 592:guest.c       **** 				return (WORD)GuestRegisters[RAN_EDI]; 
 2252              		.loc 1 592 0
 2253 15eb A1100000 		mov	eax, DWORD PTR GuestRegisters+16
 2253      00
 2254 15f0 0FB7C0   		movzx	eax, ax
 2255 15f3 EB0F     		jmp	.L135
 2256              	.L150:
 593:guest.c       **** 			else
 594:guest.c       **** 				return (BYTE)GuestRegisters[RAN_EDI]; 
 2257              		.loc 1 594 0
 2258 15f5 A1100000 		mov	eax, DWORD PTR GuestRegisters+16
 2258      00
 2259 15fa 0FB6C0   		movzx	eax, al
 2260 15fd EB05     		jmp	.L135
 2261              	.L124:
 595:guest.c       **** 	}
 596:guest.c       **** 	return 0xED;
 2262              		.loc 1 596 0
 2263 15ff B8ED0000 		mov	eax, 237
 2263      00
 2264              	.L135:
 597:guest.c       **** }
 2265              		.loc 1 597 0
 2266 1604 C9       		leave
 2267              		.cfi_restore 5
 2268              		.cfi_def_cfa 4, 4
 2269 1605 C3       		ret
 2270              		.cfi_endproc
 2271              	.LFE15:
 2273              		.globl	SetGuestMODRegGenRegValue
 2275              	SetGuestMODRegGenRegValue:
 2276              	.LFB16:
 598:guest.c       **** 
 599:guest.c       **** void SetGuestMODRegGenRegValue(BYTE RegOffsetFromCurrIns, DWORD Value, bool DW, bool W)
 600:guest.c       **** {
 2277              		.loc 1 600 0
 2278              		.cfi_startproc
 2279 1606 55       		push	ebp
 2280              		.cfi_def_cfa_offset 8
 2281              		.cfi_offset 5, -8
 2282 1607 89E5     		mov	ebp, esp
 2283              		.cfi_def_cfa_register 5
 2284 1609 53       		push	ebx
 2285 160a 83EC24   		sub	esp, 36
 2286              		.cfi_offset 3, -12
 2287 160d 8B4D08   		mov	ecx, DWORD PTR [ebp+8]
 2288 1610 8B5510   		mov	edx, DWORD PTR [ebp+16]
 2289 1613 8B4514   		mov	eax, DWORD PTR [ebp+20]
 2290 1616 884DE4   		mov	BYTE PTR [ebp-28], cl
 2291 1619 8855E0   		mov	BYTE PTR [ebp-32], dl
 2292 161c 8845DC   		mov	BYTE PTR [ebp-36], al
 601:guest.c       **** 	BYTE reg = 0;
 2293              		.loc 1 601 0
 2294 161f C645F700 		mov	BYTE PTR [ebp-9], 0
 602:guest.c       **** 
 603:guest.c       ****         reg = GetMemB(guest.vmcb->cs.base + guest.vmcb->rip + RegOffsetFromCurrIns,true);
 2295              		.loc 1 603 0
 2296 1623 A1040000 		mov	eax, DWORD PTR guest+4
 2296      00
 2297 1628 8B901C04 		mov	edx, DWORD PTR [eax+1052]
 2297      0000
 2298 162e 8B801804 		mov	eax, DWORD PTR [eax+1048]
 2298      0000
 2299 1634 89C1     		mov	ecx, eax
 2300 1636 A1040000 		mov	eax, DWORD PTR guest+4
 2300      00
 2301 163b 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 2301      0000
 2302 1641 8B807805 		mov	eax, DWORD PTR [eax+1400]
 2302      0000
 2303 1647 8D1401   		lea	edx, [ecx+eax]
 2304 164a 0FB645E4 		movzx	eax, BYTE PTR [ebp-28]
 2305 164e 01D0     		add	eax, edx
 2306 1650 83EC08   		sub	esp, 8
 2307 1653 6A01     		push	1
 2308 1655 50       		push	eax
 2309 1656 E8FCFFFF 		call	GetMemB
 2309      FF
 2310 165b 83C410   		add	esp, 16
 2311 165e 8845F7   		mov	BYTE PTR [ebp-9], al
 604:guest.c       **** 
 605:guest.c       **** 	switch ( reg & 0x7 )
 2312              		.loc 1 605 0
 2313 1661 0FB645F7 		movzx	eax, BYTE PTR [ebp-9]
 2314 1665 83E007   		and	eax, 7
 2315 1668 83F807   		cmp	eax, 7
 2316 166b 0F873202 		ja	.L186
 2316      0000
 2317 1671 8B048560 		mov	eax, DWORD PTR .L154[0+eax*4]
 2317      000000
 2318 1678 FFE0     		jmp	eax
 2319              		.section	.rodata
 2320              		.align 4
 2321              		.align 4
 2322              	.L154:
 2323 0060 7A160000 		.long	.L153
 2324 0064 26170000 		.long	.L155
 2325 0068 5F170000 		.long	.L156
 2326 006c ED160000 		.long	.L157
 2327 0070 0A180000 		.long	.L158
 2328 0074 74180000 		.long	.L159
 2329 0078 98170000 		.long	.L160
 2330 007c D1170000 		.long	.L161
 2331              		.text
 2332              	.L153:
 606:guest.c       **** 	{
 607:guest.c       ****             case MODRM_REG_EAX:
 608:guest.c       ****                     if (DW)
 2333              		.loc 1 608 0
 2334 167a 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2335 167e 741F     		je	.L162
 609:guest.c       ****                             guest.vmcb->rax = Value;
 2336              		.loc 1 609 0
 2337 1680 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2337      0000
 2338 1686 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2339 1689 BA000000 		mov	edx, 0
 2339      00
 2340 168e 8981F805 		mov	DWORD PTR [ecx+1528], eax
 2340      0000
 2341 1694 8991FC05 		mov	DWORD PTR [ecx+1532], edx
 2341      0000
 610:guest.c       ****                     else if (W)
 611:guest.c       ****                             guest.vmcb->rax = (WORD)Value;
 612:guest.c       ****                     else
 613:guest.c       ****                             guest.vmcb->rax = (BYTE)Value;
 614:guest.c       ****                     break;
 2342              		.loc 1 614 0
 2343 169a E9040200 		jmp	.L152
 2343      00
 2344              	.L162:
 610:guest.c       ****                     else if (W)
 2345              		.loc 1 610 0
 2346 169f 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2347 16a3 7424     		je	.L164
 611:guest.c       ****                     else
 2348              		.loc 1 611 0
 2349 16a5 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2349      0000
 2350 16ab 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2351 16ae 89C3     		mov	ebx, eax
 2352 16b0 0FB7C3   		movzx	eax, bx
 2353 16b3 BA000000 		mov	edx, 0
 2353      00
 2354 16b8 8981F805 		mov	DWORD PTR [ecx+1528], eax
 2354      0000
 2355 16be 8991FC05 		mov	DWORD PTR [ecx+1532], edx
 2355      0000
 2356              		.loc 1 614 0
 2357 16c4 E9DA0100 		jmp	.L152
 2357      00
 2358              	.L164:
 613:guest.c       ****                     break;
 2359              		.loc 1 613 0
 2360 16c9 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2360      0000
 2361 16cf 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2362 16d2 89C3     		mov	ebx, eax
 2363 16d4 0FB6C3   		movzx	eax, bl
 2364 16d7 BA000000 		mov	edx, 0
 2364      00
 2365 16dc 8981F805 		mov	DWORD PTR [ecx+1528], eax
 2365      0000
 2366 16e2 8991FC05 		mov	DWORD PTR [ecx+1532], edx
 2366      0000
 2367              		.loc 1 614 0
 2368 16e8 E9B60100 		jmp	.L152
 2368      00
 2369              	.L157:
 615:guest.c       ****             case MODRM_REG_EBX:
 616:guest.c       ****                     if (DW)
 2370              		.loc 1 616 0
 2371 16ed 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2372 16f1 740D     		je	.L165
 617:guest.c       ****                             GuestRegisters[0] = Value; 
 2373              		.loc 1 617 0
 2374 16f3 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2375 16f6 A3000000 		mov	DWORD PTR GuestRegisters, eax
 2375      00
 618:guest.c       ****                     else if (W)
 619:guest.c       ****                             GuestRegisters[0] = (WORD)Value;
 620:guest.c       ****                     else
 621:guest.c       ****                             GuestRegisters[0] = (BYTE)Value;
 622:guest.c       ****                     break;
 2376              		.loc 1 622 0
 2377 16fb E9A30100 		jmp	.L152
 2377      00
 2378              	.L165:
 618:guest.c       ****                     else if (W)
 2379              		.loc 1 618 0
 2380 1700 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2381 1704 7410     		je	.L167
 619:guest.c       ****                     else
 2382              		.loc 1 619 0
 2383 1706 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2384 1709 0FB7C0   		movzx	eax, ax
 2385 170c A3000000 		mov	DWORD PTR GuestRegisters, eax
 2385      00
 2386              		.loc 1 622 0
 2387 1711 E98D0100 		jmp	.L152
 2387      00
 2388              	.L167:
 621:guest.c       ****                     break;
 2389              		.loc 1 621 0
 2390 1716 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2391 1719 0FB6C0   		movzx	eax, al
 2392 171c A3000000 		mov	DWORD PTR GuestRegisters, eax
 2392      00
 2393              		.loc 1 622 0
 2394 1721 E97D0100 		jmp	.L152
 2394      00
 2395              	.L155:
 623:guest.c       ****             case MODRM_REG_ECX:
 624:guest.c       ****                     if (DW)
 2396              		.loc 1 624 0
 2397 1726 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2398 172a 740D     		je	.L168
 625:guest.c       ****                             GuestRegisters[1] = Value; 
 2399              		.loc 1 625 0
 2400 172c 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2401 172f A3040000 		mov	DWORD PTR GuestRegisters+4, eax
 2401      00
 626:guest.c       ****                     else if (W)
 627:guest.c       ****                             GuestRegisters[1] = (WORD)Value;
 628:guest.c       ****                     else
 629:guest.c       ****                             GuestRegisters[1] = (BYTE)Value;
 630:guest.c       ****                     break;
 2402              		.loc 1 630 0
 2403 1734 E96A0100 		jmp	.L152
 2403      00
 2404              	.L168:
 626:guest.c       ****                     else if (W)
 2405              		.loc 1 626 0
 2406 1739 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2407 173d 7410     		je	.L170
 627:guest.c       ****                     else
 2408              		.loc 1 627 0
 2409 173f 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2410 1742 0FB7C0   		movzx	eax, ax
 2411 1745 A3040000 		mov	DWORD PTR GuestRegisters+4, eax
 2411      00
 2412              		.loc 1 630 0
 2413 174a E9540100 		jmp	.L152
 2413      00
 2414              	.L170:
 629:guest.c       ****                     break;
 2415              		.loc 1 629 0
 2416 174f 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2417 1752 0FB6C0   		movzx	eax, al
 2418 1755 A3040000 		mov	DWORD PTR GuestRegisters+4, eax
 2418      00
 2419              		.loc 1 630 0
 2420 175a E9440100 		jmp	.L152
 2420      00
 2421              	.L156:
 631:guest.c       ****             case MODRM_REG_EDX:
 632:guest.c       ****                     if (DW)
 2422              		.loc 1 632 0
 2423 175f 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2424 1763 740D     		je	.L171
 633:guest.c       ****                             GuestRegisters[2] = Value; 
 2425              		.loc 1 633 0
 2426 1765 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2427 1768 A3080000 		mov	DWORD PTR GuestRegisters+8, eax
 2427      00
 634:guest.c       ****                     else if (W)
 635:guest.c       ****                             GuestRegisters[2] = (WORD)Value;
 636:guest.c       ****                     else
 637:guest.c       ****                             GuestRegisters[2] = (BYTE)Value;
 638:guest.c       ****                     break;
 2428              		.loc 1 638 0
 2429 176d E9310100 		jmp	.L152
 2429      00
 2430              	.L171:
 634:guest.c       ****                     else if (W)
 2431              		.loc 1 634 0
 2432 1772 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2433 1776 7410     		je	.L173
 635:guest.c       ****                     else
 2434              		.loc 1 635 0
 2435 1778 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2436 177b 0FB7C0   		movzx	eax, ax
 2437 177e A3080000 		mov	DWORD PTR GuestRegisters+8, eax
 2437      00
 2438              		.loc 1 638 0
 2439 1783 E91B0100 		jmp	.L152
 2439      00
 2440              	.L173:
 637:guest.c       ****                     break;
 2441              		.loc 1 637 0
 2442 1788 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2443 178b 0FB6C0   		movzx	eax, al
 2444 178e A3080000 		mov	DWORD PTR GuestRegisters+8, eax
 2444      00
 2445              		.loc 1 638 0
 2446 1793 E90B0100 		jmp	.L152
 2446      00
 2447              	.L160:
 639:guest.c       ****             case MODRM_REG_ESI:
 640:guest.c       ****                     if (DW)
 2448              		.loc 1 640 0
 2449 1798 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2450 179c 740D     		je	.L174
 641:guest.c       ****                             GuestRegisters[3] = Value; 
 2451              		.loc 1 641 0
 2452 179e 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2453 17a1 A30C0000 		mov	DWORD PTR GuestRegisters+12, eax
 2453      00
 642:guest.c       ****                     else if (W)
 643:guest.c       ****                             GuestRegisters[3] = (WORD)Value;
 644:guest.c       ****                     else
 645:guest.c       ****                             GuestRegisters[3] = (BYTE)Value;
 646:guest.c       ****                     break;
 2454              		.loc 1 646 0
 2455 17a6 E9F80000 		jmp	.L152
 2455      00
 2456              	.L174:
 642:guest.c       ****                     else if (W)
 2457              		.loc 1 642 0
 2458 17ab 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2459 17af 7410     		je	.L176
 643:guest.c       ****                     else
 2460              		.loc 1 643 0
 2461 17b1 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2462 17b4 0FB7C0   		movzx	eax, ax
 2463 17b7 A30C0000 		mov	DWORD PTR GuestRegisters+12, eax
 2463      00
 2464              		.loc 1 646 0
 2465 17bc E9E20000 		jmp	.L152
 2465      00
 2466              	.L176:
 645:guest.c       ****                     break;
 2467              		.loc 1 645 0
 2468 17c1 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2469 17c4 0FB6C0   		movzx	eax, al
 2470 17c7 A30C0000 		mov	DWORD PTR GuestRegisters+12, eax
 2470      00
 2471              		.loc 1 646 0
 2472 17cc E9D20000 		jmp	.L152
 2472      00
 2473              	.L161:
 647:guest.c       ****             case MODRM_REG_EDI:
 648:guest.c       ****                     if (DW)
 2474              		.loc 1 648 0
 2475 17d1 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2476 17d5 740D     		je	.L177
 649:guest.c       ****                             GuestRegisters[4] = Value; 
 2477              		.loc 1 649 0
 2478 17d7 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2479 17da A3100000 		mov	DWORD PTR GuestRegisters+16, eax
 2479      00
 650:guest.c       ****                     else if (W)
 651:guest.c       ****                             GuestRegisters[4] = (WORD)Value;
 652:guest.c       ****                     else
 653:guest.c       ****                             GuestRegisters[4] = (BYTE)Value;
 654:guest.c       ****                     break;
 2480              		.loc 1 654 0
 2481 17df E9BF0000 		jmp	.L152
 2481      00
 2482              	.L177:
 650:guest.c       ****                     else if (W)
 2483              		.loc 1 650 0
 2484 17e4 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2485 17e8 7410     		je	.L179
 651:guest.c       ****                     else
 2486              		.loc 1 651 0
 2487 17ea 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2488 17ed 0FB7C0   		movzx	eax, ax
 2489 17f0 A3100000 		mov	DWORD PTR GuestRegisters+16, eax
 2489      00
 2490              		.loc 1 654 0
 2491 17f5 E9A90000 		jmp	.L152
 2491      00
 2492              	.L179:
 653:guest.c       ****                     break;
 2493              		.loc 1 653 0
 2494 17fa 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2495 17fd 0FB6C0   		movzx	eax, al
 2496 1800 A3100000 		mov	DWORD PTR GuestRegisters+16, eax
 2496      00
 2497              		.loc 1 654 0
 2498 1805 E9990000 		jmp	.L152
 2498      00
 2499              	.L158:
 655:guest.c       ****             case MODRM_REG_ESP:
 656:guest.c       ****                     if (DW)
 2500              		.loc 1 656 0
 2501 180a 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2502 180e 741C     		je	.L180
 657:guest.c       ****                             guest.vmcb->rsp = Value;
 2503              		.loc 1 657 0
 2504 1810 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2504      0000
 2505 1816 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2506 1819 BA000000 		mov	edx, 0
 2506      00
 2507 181e 8981D805 		mov	DWORD PTR [ecx+1496], eax
 2507      0000
 2508 1824 8991DC05 		mov	DWORD PTR [ecx+1500], edx
 2508      0000
 658:guest.c       ****                     else if (W)
 659:guest.c       ****                             guest.vmcb->rsp = (WORD)Value;
 660:guest.c       ****                     else
 661:guest.c       ****                             guest.vmcb->rsp = (BYTE)Value;
 662:guest.c       ****                     break;
 2509              		.loc 1 662 0
 2510 182a EB77     		jmp	.L152
 2511              	.L180:
 658:guest.c       ****                     else if (W)
 2512              		.loc 1 658 0
 2513 182c 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2514 1830 7421     		je	.L182
 659:guest.c       ****                     else
 2515              		.loc 1 659 0
 2516 1832 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2516      0000
 2517 1838 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2518 183b 89C3     		mov	ebx, eax
 2519 183d 0FB7C3   		movzx	eax, bx
 2520 1840 BA000000 		mov	edx, 0
 2520      00
 2521 1845 8981D805 		mov	DWORD PTR [ecx+1496], eax
 2521      0000
 2522 184b 8991DC05 		mov	DWORD PTR [ecx+1500], edx
 2522      0000
 2523              		.loc 1 662 0
 2524 1851 EB50     		jmp	.L152
 2525              	.L182:
 661:guest.c       ****                     break;
 2526              		.loc 1 661 0
 2527 1853 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2527      0000
 2528 1859 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2529 185c 89C3     		mov	ebx, eax
 2530 185e 0FB6C3   		movzx	eax, bl
 2531 1861 BA000000 		mov	edx, 0
 2531      00
 2532 1866 8981D805 		mov	DWORD PTR [ecx+1496], eax
 2532      0000
 2533 186c 8991DC05 		mov	DWORD PTR [ecx+1500], edx
 2533      0000
 2534              		.loc 1 662 0
 2535 1872 EB2F     		jmp	.L152
 2536              	.L159:
 663:guest.c       ****             case MODRM_REG_EBP:
 664:guest.c       ****                     if (DW)
 2537              		.loc 1 664 0
 2538 1874 807DE000 		cmp	BYTE PTR [ebp-32], 0
 2539 1878 740A     		je	.L183
 665:guest.c       ****                             GuestRegisters[5] = Value; 
 2540              		.loc 1 665 0
 2541 187a 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2542 187d A3140000 		mov	DWORD PTR GuestRegisters+20, eax
 2542      00
 666:guest.c       ****                     else if (W)
 667:guest.c       ****                             GuestRegisters[5] = (WORD)Value;
 668:guest.c       ****                     else
 669:guest.c       ****                             GuestRegisters[5] = (BYTE)Value;
 670:guest.c       ****                     break;
 2543              		.loc 1 670 0
 2544 1882 EB1E     		jmp	.L187
 2545              	.L183:
 666:guest.c       ****                     else if (W)
 2546              		.loc 1 666 0
 2547 1884 807DDC00 		cmp	BYTE PTR [ebp-36], 0
 2548 1888 740D     		je	.L185
 667:guest.c       ****                     else
 2549              		.loc 1 667 0
 2550 188a 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2551 188d 0FB7C0   		movzx	eax, ax
 2552 1890 A3140000 		mov	DWORD PTR GuestRegisters+20, eax
 2552      00
 2553              		.loc 1 670 0
 2554 1895 EB0B     		jmp	.L187
 2555              	.L185:
 669:guest.c       ****                     break;
 2556              		.loc 1 669 0
 2557 1897 8B450C   		mov	eax, DWORD PTR [ebp+12]
 2558 189a 0FB6C0   		movzx	eax, al
 2559 189d A3140000 		mov	DWORD PTR GuestRegisters+20, eax
 2559      00
 2560              	.L187:
 2561              		.loc 1 670 0
 2562 18a2 90       		nop
 2563              	.L152:
 2564              	.L186:
 671:guest.c       **** 	}
 672:guest.c       **** }
 2565              		.loc 1 672 0
 2566 18a3 90       		nop
 2567 18a4 8B5DFC   		mov	ebx, DWORD PTR [ebp-4]
 2568 18a7 C9       		leave
 2569              		.cfi_restore 5
 2570              		.cfi_restore 3
 2571              		.cfi_def_cfa 4, 4
 2572 18a8 C3       		ret
 2573              		.cfi_endproc
 2574              	.LFE16:
 2576              		.globl	HandleGuestIO
 2578              	HandleGuestIO:
 2579              	.LFB17:
 673:guest.c       **** 
 674:guest.c       **** void HandleGuestIO()	
 675:guest.c       **** {
 2580              		.loc 1 675 0
 2581              		.cfi_startproc
 2582 18a9 55       		push	ebp
 2583              		.cfi_def_cfa_offset 8
 2584              		.cfi_offset 5, -8
 2585 18aa 89E5     		mov	ebp, esp
 2586              		.cfi_def_cfa_register 5
 2587 18ac 57       		push	edi
 2588 18ad 56       		push	esi
 2589 18ae 53       		push	ebx
 2590 18af 83EC3C   		sub	esp, 60
 2591              		.cfi_offset 7, -12
 2592              		.cfi_offset 6, -16
 2593              		.cfi_offset 3, -20
 676:guest.c       ****         ioio_info_t t;
 677:guest.c       ****         t.bytes = guest.vmcb->exitinfo1;
 2594              		.loc 1 677 0
 2595 18b2 A1040000 		mov	eax, DWORD PTR guest+4
 2595      00
 2596 18b7 8B507C   		mov	edx, DWORD PTR [eax+124]
 2597 18ba 8B4078   		mov	eax, DWORD PTR [eax+120]
 2598 18bd 8945E0   		mov	DWORD PTR [ebp-32], eax
 2599 18c0 8955E4   		mov	DWORD PTR [ebp-28], edx
 678:guest.c       **** 	switch (t.fields.port)
 2600              		.loc 1 678 0
 2601 18c3 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2602 18c7 0FB7C0   		movzx	eax, ax
 2603 18ca 83F871   		cmp	eax, 113
 2604 18cd 0F84CA00 		je	.L190
 2604      0000
 2605 18d3 3D920000 		cmp	eax, 146
 2605      00
 2606 18d8 0F841501 		je	.L191
 2606      0000
 2607 18de 83F870   		cmp	eax, 112
 2608 18e1 0F85BE01 		jne	.L189
 2608      0000
 679:guest.c       **** 	{
 680:guest.c       ****             case 0x70:  //0070	w	CMOS RAM index register port (ISA, EISA) - write only
 681:guest.c       ****                     //17h 	23 	1 byte 	Extended Memory Low Order Byte - Least significant byte
 682:guest.c       ****                     //18h 	24 	1 byte 	Extended Memory High Order Byte - Most significant byte
 683:guest.c       ****                     if (t.fields.type != PORT_DIRECTION_IN)
 2609              		.loc 1 683 0
 2610 18e7 0FB645E0 		movzx	eax, BYTE PTR [ebp-32]
 2611 18eb 83E001   		and	eax, 1
 2612 18ee 84C0     		test	al, al
 2613 18f0 0F85E403 		jne	.L208
 2613      0000
 684:guest.c       ****                     {
 685:guest.c       ****                             if ( (guest.vmcb->rax & 0x17) == 0x17 )
 2614              		.loc 1 685 0
 2615 18f6 A1040000 		mov	eax, DWORD PTR guest+4
 2615      00
 2616 18fb 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2616      0000
 2617 1901 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2617      0000
 2618 1907 89C3     		mov	ebx, eax
 2619 1909 83E317   		and	ebx, 23
 2620 190c 89DE     		mov	esi, ebx
 2621 190e 89D0     		mov	eax, edx
 2622 1910 83E000   		and	eax, 0
 2623 1913 89C7     		mov	edi, eax
 2624 1915 89F0     		mov	eax, esi
 2625 1917 83F017   		xor	eax, 23
 2626 191a 09F8     		or	eax, edi
 2627 191c 85C0     		test	eax, eax
 2628 191e 7524     		jne	.L194
 686:guest.c       ****                             {
 687:guest.c       ****                                     IOPortInValue = (BYTE)(((guest.memSize - 0x100000) / 0x400) & 0
 2629              		.loc 1 687 0
 2630 1920 A1000000 		mov	eax, DWORD PTR guest
 2630      00
 2631 1925 2D000010 		sub	eax, 1048576
 2631      00
 2632 192a C1E80A   		shr	eax, 10
 2633 192d 0FB6C0   		movzx	eax, al
 2634 1930 A3040000 		mov	DWORD PTR IOPortInValue, eax
 2634      00
 688:guest.c       ****                                     IOPortInValueSet = true;
 2635              		.loc 1 688 0
 2636 1935 C7050800 		mov	DWORD PTR IOPortInValueSet, 1
 2636      00000100 
 2636      0000
 689:guest.c       ****                                     goto lblReturn;
 2637              		.loc 1 689 0
 2638 193f E9970300 		jmp	.L195
 2638      00
 2639              	.L194:
 690:guest.c       ****                             }
 691:guest.c       ****                             else if ( (guest.vmcb->rax & 0x18) == 0x18 )
 2640              		.loc 1 691 0
 2641 1944 A1040000 		mov	eax, DWORD PTR guest+4
 2641      00
 2642 1949 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2642      0000
 2643 194f 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2643      0000
 2644 1955 89C7     		mov	edi, eax
 2645 1957 83E718   		and	edi, 24
 2646 195a 897DD0   		mov	DWORD PTR [ebp-48], edi
 2647 195d 89D0     		mov	eax, edx
 2648 195f 83E000   		and	eax, 0
 2649 1962 8945D4   		mov	DWORD PTR [ebp-44], eax
 2650 1965 8B45D0   		mov	eax, DWORD PTR [ebp-48]
 2651 1968 83F018   		xor	eax, 24
 2652 196b 0B45D4   		or	eax, DWORD PTR [ebp-44]
 2653 196e 85C0     		test	eax, eax
 2654 1970 0F852B01 		jne	.L209
 2654      0000
 692:guest.c       ****                             {
 693:guest.c       ****                                     IOPortInValue = (BYTE)((((guest.memSize - 0x100000) / 0x400) >>
 2655              		.loc 1 693 0
 2656 1976 A1000000 		mov	eax, DWORD PTR guest
 2656      00
 2657 197b 2D000010 		sub	eax, 1048576
 2657      00
 2658 1980 C1E80A   		shr	eax, 10
 2659 1983 C1E808   		shr	eax, 8
 2660 1986 0FB6C0   		movzx	eax, al
 2661 1989 A3040000 		mov	DWORD PTR IOPortInValue, eax
 2661      00
 694:guest.c       ****                                     IOPortInValueSet = true;
 2662              		.loc 1 694 0
 2663 198e C7050800 		mov	DWORD PTR IOPortInValueSet, 1
 2663      00000100 
 2663      0000
 695:guest.c       ****                                     goto lblReturn;
 2664              		.loc 1 695 0
 2665 1998 E93E0300 		jmp	.L195
 2665      00
 2666              	.L190:
 696:guest.c       ****                             }
 697:guest.c       ****                             //IO port was 70, direction out, but index wasn't 17 or 18 so do standa
 698:guest.c       ****                     }
 699:guest.c       ****                     else
 700:guest.c       ****                             //Invalid, port 70 is write (OUT) only so do nothing
 701:guest.c       ****                             goto lblReturn;
 702:guest.c       **** 
 703:guest.c       ****                     break;
 704:guest.c       ****             case 0x71: //CMOS data port
 705:guest.c       ****                     if (t.fields.type == PORT_DIRECTION_IN)
 2667              		.loc 1 705 0
 2668 199d 0FB645E0 		movzx	eax, BYTE PTR [ebp-32]
 2669 19a1 83E001   		and	eax, 1
 2670 19a4 84C0     		test	al, al
 2671 19a6 0F84F800 		je	.L210
 2671      0000
 706:guest.c       ****                     {
 707:guest.c       ****                             if (IOPortInValueSet)
 2672              		.loc 1 707 0
 2673 19ac A1080000 		mov	eax, DWORD PTR IOPortInValueSet
 2673      00
 2674 19b1 85C0     		test	eax, eax
 2675 19b3 0F84EB00 		je	.L210
 2675      0000
 708:guest.c       ****                             {
 709:guest.c       ****                                     //NOTE: Port 71 only returns 1 byte
 710:guest.c       ****                                 guest.vmcb->rax = (BYTE)IOPortInValue;
 2676              		.loc 1 710 0
 2677 19b9 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2677      0000
 2678 19bf A1040000 		mov	eax, DWORD PTR IOPortInValue
 2678      00
 2679 19c4 89C3     		mov	ebx, eax
 2680 19c6 0FB6C3   		movzx	eax, bl
 2681 19c9 BA000000 		mov	edx, 0
 2681      00
 2682 19ce 8981F805 		mov	DWORD PTR [ecx+1528], eax
 2682      0000
 2683 19d4 8991FC05 		mov	DWORD PTR [ecx+1532], edx
 2683      0000
 711:guest.c       ****                                 IOPortInValue = 0;
 2684              		.loc 1 711 0
 2685 19da C7050400 		mov	DWORD PTR IOPortInValue, 0
 2685      00000000 
 2685      0000
 712:guest.c       ****                                 IOPortInValueSet = false;
 2686              		.loc 1 712 0
 2687 19e4 C7050800 		mov	DWORD PTR IOPortInValueSet, 0
 2687      00000000 
 2687      0000
 713:guest.c       ****                                 goto lblReturn;
 2688              		.loc 1 713 0
 2689 19ee E9E80200 		jmp	.L195
 2689      00
 2690              	.L191:
 714:guest.c       ****                             }
 715:guest.c       ****                             //Port 71 but prior read from port 70 wasn't 17 or 18 so do standard st
 716:guest.c       ****                     }
 717:guest.c       ****                     //IO port was 71 but direction was out so do standard stuff
 718:guest.c       ****                     break;
 719:guest.c       ****             case 0x92:
 720:guest.c       ****                 if (t.fields.type == PORT_DIRECTION_OUT)
 2691              		.loc 1 720 0
 2692 19f3 0FB645E0 		movzx	eax, BYTE PTR [ebp-32]
 2693 19f7 83E001   		and	eax, 1
 2694 19fa 84C0     		test	al, al
 2695 19fc 753F     		jne	.L198
 721:guest.c       ****                 {
 722:guest.c       ****                     guest.port92Value = guest.vmcb->rax & (t.fields.sz8?0xFF:0xFFFF);
 2696              		.loc 1 722 0
 2697 19fe A1040000 		mov	eax, DWORD PTR guest+4
 2697      00
 2698 1a03 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2698      0000
 2699 1a09 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2699      0000
 2700 1a0f A2190000 		mov	BYTE PTR guest+25, al
 2700      00
 723:guest.c       ****                     //asm("xchg bx,bx\n");
 724:guest.c       ****                     if ((guest.port92Value & 0x2) == 0x2)
 2701              		.loc 1 724 0
 2702 1a14 0FB60519 		movzx	eax, BYTE PTR guest+25
 2702      000000
 2703 1a1b 0FB6C0   		movzx	eax, al
 2704 1a1e 83E002   		and	eax, 2
 2705 1a21 85C0     		test	eax, eax
 2706 1a23 740C     		je	.L199
 725:guest.c       ****                         guest.A20Enabled = true;
 2707              		.loc 1 725 0
 2708 1a25 C6051800 		mov	BYTE PTR guest+24, 1
 2708      000001
 726:guest.c       ****                     else
 727:guest.c       ****                         guest.A20Enabled = false;
 728:guest.c       ****                 }
 729:guest.c       ****                 else
 730:guest.c       ****                 {
 731:guest.c       ****                         guest.vmcb->rax = (guest.vmcb->rax & 0xFFFFFF00) | guest.port92Value;
 732:guest.c       ****                     //asm("xchg bx,bx\n");
 733:guest.c       ****                 }
 734:guest.c       ****                 goto lblReturn;
 2709              		.loc 1 734 0
 2710 1a2c E9AA0200 		jmp	.L195
 2710      00
 2711              	.L199:
 727:guest.c       ****                 }
 2712              		.loc 1 727 0
 2713 1a31 C6051800 		mov	BYTE PTR guest+24, 0
 2713      000000
 2714              		.loc 1 734 0
 2715 1a38 E99E0200 		jmp	.L195
 2715      00
 2716              	.L198:
 731:guest.c       ****                     //asm("xchg bx,bx\n");
 2717              		.loc 1 731 0
 2718 1a3d 8B1D0400 		mov	ebx, DWORD PTR guest+4
 2718      0000
 2719 1a43 A1040000 		mov	eax, DWORD PTR guest+4
 2719      00
 2720 1a48 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2720      0000
 2721 1a4e 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2721      0000
 2722 1a54 89C7     		mov	edi, eax
 2723 1a56 81E700FF 		and	edi, -256
 2723      FFFF
 2724 1a5c 897DC8   		mov	DWORD PTR [ebp-56], edi
 2725 1a5f 89D0     		mov	eax, edx
 2726 1a61 83E000   		and	eax, 0
 2727 1a64 8945CC   		mov	DWORD PTR [ebp-52], eax
 2728 1a67 0FB60D19 		movzx	ecx, BYTE PTR guest+25
 2728      000000
 2729 1a6e 0FB6C1   		movzx	eax, cl
 2730 1a71 BA000000 		mov	edx, 0
 2730      00
 2731 1a76 8B75C8   		mov	esi, DWORD PTR [ebp-56]
 2732 1a79 8B7DCC   		mov	edi, DWORD PTR [ebp-52]
 2733 1a7c 89F1     		mov	ecx, esi
 2734 1a7e 09C1     		or	ecx, eax
 2735 1a80 894DC0   		mov	DWORD PTR [ebp-64], ecx
 2736 1a83 89D0     		mov	eax, edx
 2737 1a85 09F8     		or	eax, edi
 2738 1a87 8945C4   		mov	DWORD PTR [ebp-60], eax
 2739 1a8a 8B45C0   		mov	eax, DWORD PTR [ebp-64]
 2740 1a8d 8B55C4   		mov	edx, DWORD PTR [ebp-60]
 2741 1a90 8983F805 		mov	DWORD PTR [ebx+1528], eax
 2741      0000
 2742 1a96 8993FC05 		mov	DWORD PTR [ebx+1532], edx
 2742      0000
 2743              		.loc 1 734 0
 2744 1a9c E93A0200 		jmp	.L195
 2744      00
 2745              	.L209:
 703:guest.c       ****             case 0x71: //CMOS data port
 2746              		.loc 1 703 0
 2747 1aa1 90       		nop
 2748 1aa2 EB01     		jmp	.L189
 2749              	.L210:
 718:guest.c       ****             case 0x92:
 2750              		.loc 1 718 0
 2751 1aa4 90       		nop
 2752              	.L189:
 735:guest.c       **** 	}
 736:guest.c       **** 	
 737:guest.c       **** 	//Forward the In/Out to the real CMOS
 738:guest.c       **** 	if (t.fields.type == PORT_DIRECTION_IN)
 2753              		.loc 1 738 0
 2754 1aa5 0FB645E0 		movzx	eax, BYTE PTR [ebp-32]
 2755 1aa9 83E001   		and	eax, 1
 2756 1aac 84C0     		test	al, al
 2757 1aae 0F842F01 		je	.L202
 2757      0000
 739:guest.c       **** 	{
 740:guest.c       **** 		if (t.fields.sz8)
 2758              		.loc 1 740 0
 2759 1ab4 0FB645E0 		movzx	eax, BYTE PTR [ebp-32]
 2760 1ab8 83E010   		and	eax, 16
 2761 1abb 84C0     		test	al, al
 2762 1abd 7434     		je	.L203
 741:guest.c       **** 		{
 742:guest.c       **** 			guest.vmcb->rax = inb(t.fields.port);
 2763              		.loc 1 742 0
 2764 1abf 8B1D0400 		mov	ebx, DWORD PTR guest+4
 2764      0000
 2765 1ac5 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2766 1ac9 0FB7C0   		movzx	eax, ax
 2767 1acc 83EC0C   		sub	esp, 12
 2768 1acf 50       		push	eax
 2769 1ad0 E8FCFFFF 		call	inb
 2769      FF
 2770 1ad5 83C410   		add	esp, 16
 2771 1ad8 89C1     		mov	ecx, eax
 2772 1ada 0FB6C1   		movzx	eax, cl
 2773 1add BA000000 		mov	edx, 0
 2773      00
 2774 1ae2 8983F805 		mov	DWORD PTR [ebx+1528], eax
 2774      0000
 2775 1ae8 8993FC05 		mov	DWORD PTR [ebx+1532], edx
 2775      0000
 2776 1aee E9E80100 		jmp	.L195
 2776      00
 2777              	.L203:
 743:guest.c       **** 		}
 744:guest.c       **** 		else if (t.fields.sz16)
 2778              		.loc 1 744 0
 2779 1af3 0FB645E0 		movzx	eax, BYTE PTR [ebp-32]
 2780 1af7 83E020   		and	eax, 32
 2781 1afa 84C0     		test	al, al
 2782 1afc 7457     		je	.L205
 745:guest.c       **** 		{
 746:guest.c       **** 			guest.vmcb->rax = (WORD)((inb(t.fields.port+1) << 8) | inb(t.fields.port));
 2783              		.loc 1 746 0
 2784 1afe 8B1D0400 		mov	ebx, DWORD PTR guest+4
 2784      0000
 2785 1b04 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2786 1b08 83C001   		add	eax, 1
 2787 1b0b 0FB7C0   		movzx	eax, ax
 2788 1b0e 83EC0C   		sub	esp, 12
 2789 1b11 50       		push	eax
 2790 1b12 E8FCFFFF 		call	inb
 2790      FF
 2791 1b17 83C410   		add	esp, 16
 2792 1b1a 0FB6C0   		movzx	eax, al
 2793 1b1d C1E008   		sal	eax, 8
 2794 1b20 89C6     		mov	esi, eax
 2795 1b22 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2796 1b26 0FB7C0   		movzx	eax, ax
 2797 1b29 83EC0C   		sub	esp, 12
 2798 1b2c 50       		push	eax
 2799 1b2d E8FCFFFF 		call	inb
 2799      FF
 2800 1b32 83C410   		add	esp, 16
 2801 1b35 0FB6C0   		movzx	eax, al
 2802 1b38 09F0     		or	eax, esi
 2803 1b3a 89C1     		mov	ecx, eax
 2804 1b3c 0FB7C1   		movzx	eax, cx
 2805 1b3f BA000000 		mov	edx, 0
 2805      00
 2806 1b44 8983F805 		mov	DWORD PTR [ebx+1528], eax
 2806      0000
 2807 1b4a 8993FC05 		mov	DWORD PTR [ebx+1532], edx
 2807      0000
 2808 1b50 E9860100 		jmp	.L195
 2808      00
 2809              	.L205:
 747:guest.c       **** 		}
 748:guest.c       **** 		else
 749:guest.c       **** 		{
 750:guest.c       **** 			guest.vmcb->rax = (DWORD)((inb(t.fields.port+3) << 24) | (inb(t.fields.port+2) << 16) | (inb(t.f
 2810              		.loc 1 750 0
 2811 1b55 8B1D0400 		mov	ebx, DWORD PTR guest+4
 2811      0000
 2812 1b5b 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2813 1b5f 83C003   		add	eax, 3
 2814 1b62 0FB7C0   		movzx	eax, ax
 2815 1b65 83EC0C   		sub	esp, 12
 2816 1b68 50       		push	eax
 2817 1b69 E8FCFFFF 		call	inb
 2817      FF
 2818 1b6e 83C410   		add	esp, 16
 2819 1b71 0FB6C0   		movzx	eax, al
 2820 1b74 C1E018   		sal	eax, 24
 2821 1b77 89C6     		mov	esi, eax
 2822 1b79 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2823 1b7d 83C002   		add	eax, 2
 2824 1b80 0FB7C0   		movzx	eax, ax
 2825 1b83 83EC0C   		sub	esp, 12
 2826 1b86 50       		push	eax
 2827 1b87 E8FCFFFF 		call	inb
 2827      FF
 2828 1b8c 83C410   		add	esp, 16
 2829 1b8f 0FB6C0   		movzx	eax, al
 2830 1b92 C1E010   		sal	eax, 16
 2831 1b95 09C6     		or	esi, eax
 2832 1b97 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2833 1b9b 83C001   		add	eax, 1
 2834 1b9e 0FB7C0   		movzx	eax, ax
 2835 1ba1 83EC0C   		sub	esp, 12
 2836 1ba4 50       		push	eax
 2837 1ba5 E8FCFFFF 		call	inb
 2837      FF
 2838 1baa 83C410   		add	esp, 16
 751:guest.c       ****                                 port+1) << 8) | inb(t.fields.port));
 2839              		.loc 1 751 0
 2840 1bad 0FB6C0   		movzx	eax, al
 2841 1bb0 C1E008   		sal	eax, 8
 750:guest.c       ****                                 port+1) << 8) | inb(t.fields.port));
 2842              		.loc 1 750 0
 2843 1bb3 09C6     		or	esi, eax
 2844              		.loc 1 751 0
 2845 1bb5 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2846 1bb9 0FB7C0   		movzx	eax, ax
 2847 1bbc 83EC0C   		sub	esp, 12
 2848 1bbf 50       		push	eax
 2849 1bc0 E8FCFFFF 		call	inb
 2849      FF
 2850 1bc5 83C410   		add	esp, 16
 2851 1bc8 0FB6C0   		movzx	eax, al
 2852 1bcb 09F0     		or	eax, esi
 750:guest.c       ****                                 port+1) << 8) | inb(t.fields.port));
 2853              		.loc 1 750 0
 2854 1bcd BA000000 		mov	edx, 0
 2854      00
 2855 1bd2 8983F805 		mov	DWORD PTR [ebx+1528], eax
 2855      0000
 2856 1bd8 8993FC05 		mov	DWORD PTR [ebx+1532], edx
 2856      0000
 2857 1bde E9F80000 		jmp	.L195
 2857      00
 2858              	.L202:
 752:guest.c       **** 		}
 753:guest.c       **** 	}
 754:guest.c       **** 	else //195b
 755:guest.c       **** 	{
 756:guest.c       **** 		if (t.fields.sz8)
 2859              		.loc 1 756 0
 2860 1be3 0FB645E0 		movzx	eax, BYTE PTR [ebp-32]
 2861 1be7 83E010   		and	eax, 16
 2862 1bea 84C0     		test	al, al
 2863 1bec 742D     		je	.L206
 757:guest.c       **** 			outb(t.fields.port, (BYTE)guest.vmcb->rax & 0xFF); 
 2864              		.loc 1 757 0
 2865 1bee A1040000 		mov	eax, DWORD PTR guest+4
 2865      00
 2866 1bf3 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2866      0000
 2867 1bf9 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2867      0000
 2868 1bff 0FB6D0   		movzx	edx, al
 2869 1c02 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2870 1c06 0FB7C0   		movzx	eax, ax
 2871 1c09 83EC08   		sub	esp, 8
 2872 1c0c 52       		push	edx
 2873 1c0d 50       		push	eax
 2874 1c0e E8FCFFFF 		call	outb
 2874      FF
 2875 1c13 83C410   		add	esp, 16
 2876 1c16 E9C00000 		jmp	.L195
 2876      00
 2877              	.L206:
 758:guest.c       **** 		else if (t.fields.sz16)
 2878              		.loc 1 758 0
 2879 1c1b 0FB645E0 		movzx	eax, BYTE PTR [ebp-32]
 2880 1c1f 83E020   		and	eax, 32
 2881 1c22 84C0     		test	al, al
 2882 1c24 7442     		je	.L207
 759:guest.c       **** 		{
 760:guest.c       **** 			outb(t.fields.port, (BYTE)guest.vmcb->rax & 0xFF); 
 2883              		.loc 1 760 0
 2884 1c26 A1040000 		mov	eax, DWORD PTR guest+4
 2884      00
 2885 1c2b 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2885      0000
 2886 1c31 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2886      0000
 2887 1c37 0FB6D0   		movzx	edx, al
 2888 1c3a 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2889 1c3e 0FB7C0   		movzx	eax, ax
 2890 1c41 83EC08   		sub	esp, 8
 2891 1c44 52       		push	edx
 2892 1c45 50       		push	eax
 2893 1c46 E8FCFFFF 		call	outb
 2893      FF
 2894 1c4b 83C410   		add	esp, 16
 761:guest.c       **** 			outb(t.fields.port+1, (BYTE)(guest.vmcb->rax & 0xFF00) >> 8);
 2895              		.loc 1 761 0
 2896 1c4e 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2897 1c52 83C001   		add	eax, 1
 2898 1c55 0FB7C0   		movzx	eax, ax
 2899 1c58 83EC08   		sub	esp, 8
 2900 1c5b 6A00     		push	0
 2901 1c5d 50       		push	eax
 2902 1c5e E8FCFFFF 		call	outb
 2902      FF
 2903 1c63 83C410   		add	esp, 16
 2904 1c66 EB73     		jmp	.L195
 2905              	.L207:
 762:guest.c       **** 		}
 763:guest.c       **** 		else
 764:guest.c       **** 		{
 765:guest.c       **** 			outb(t.fields.port, (BYTE)guest.vmcb->rax & 0xFF); 
 2906              		.loc 1 765 0
 2907 1c68 A1040000 		mov	eax, DWORD PTR guest+4
 2907      00
 2908 1c6d 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2908      0000
 2909 1c73 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2909      0000
 2910 1c79 0FB6D0   		movzx	edx, al
 2911 1c7c 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2912 1c80 0FB7C0   		movzx	eax, ax
 2913 1c83 83EC08   		sub	esp, 8
 2914 1c86 52       		push	edx
 2915 1c87 50       		push	eax
 2916 1c88 E8FCFFFF 		call	outb
 2916      FF
 2917 1c8d 83C410   		add	esp, 16
 766:guest.c       **** 			outb(t.fields.port+1, (BYTE)(guest.vmcb->rax & 0xFF00) >> 8);
 2918              		.loc 1 766 0
 2919 1c90 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2920 1c94 83C001   		add	eax, 1
 2921 1c97 0FB7C0   		movzx	eax, ax
 2922 1c9a 83EC08   		sub	esp, 8
 2923 1c9d 6A00     		push	0
 2924 1c9f 50       		push	eax
 2925 1ca0 E8FCFFFF 		call	outb
 2925      FF
 2926 1ca5 83C410   		add	esp, 16
 767:guest.c       **** 			outb(t.fields.port+2, (BYTE)(guest.vmcb->rax & 0xFF0000) >> 16);
 2927              		.loc 1 767 0
 2928 1ca8 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2929 1cac 83C002   		add	eax, 2
 2930 1caf 0FB7C0   		movzx	eax, ax
 2931 1cb2 83EC08   		sub	esp, 8
 2932 1cb5 6A00     		push	0
 2933 1cb7 50       		push	eax
 2934 1cb8 E8FCFFFF 		call	outb
 2934      FF
 2935 1cbd 83C410   		add	esp, 16
 768:guest.c       **** 			outb(t.fields.port+3, (BYTE)(guest.vmcb->rax & 0xFF000000) >> 24);
 2936              		.loc 1 768 0
 2937 1cc0 0FB745E2 		movzx	eax, WORD PTR [ebp-30]
 2938 1cc4 83C003   		add	eax, 3
 2939 1cc7 0FB7C0   		movzx	eax, ax
 2940 1cca 83EC08   		sub	esp, 8
 2941 1ccd 6A00     		push	0
 2942 1ccf 50       		push	eax
 2943 1cd0 E8FCFFFF 		call	outb
 2943      FF
 2944 1cd5 83C410   		add	esp, 16
 2945 1cd8 EB01     		jmp	.L195
 2946              	.L208:
 701:guest.c       **** 
 2947              		.loc 1 701 0
 2948 1cda 90       		nop
 2949              	.L195:
 769:guest.c       **** 		}
 770:guest.c       **** 	}
 771:guest.c       **** lblReturn:
 772:guest.c       ****         guest.vmcb->rip = guest.vmcb->exitinfo2;
 2950              		.loc 1 772 0
 2951 1cdb 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2951      0000
 2952 1ce1 A1040000 		mov	eax, DWORD PTR guest+4
 2952      00
 2953 1ce6 8B908400 		mov	edx, DWORD PTR [eax+132]
 2953      0000
 2954 1cec 8B808000 		mov	eax, DWORD PTR [eax+128]
 2954      0000
 2955 1cf2 89817805 		mov	DWORD PTR [ecx+1400], eax
 2955      0000
 2956 1cf8 89917C05 		mov	DWORD PTR [ecx+1404], edx
 2956      0000
 773:guest.c       **** }
 2957              		.loc 1 773 0
 2958 1cfe 90       		nop
 2959 1cff 8D65F4   		lea	esp, [ebp-12]
 2960 1d02 5B       		pop	ebx
 2961              		.cfi_restore 3
 2962 1d03 5E       		pop	esi
 2963              		.cfi_restore 6
 2964 1d04 5F       		pop	edi
 2965              		.cfi_restore 7
 2966 1d05 5D       		pop	ebp
 2967              		.cfi_restore 5
 2968              		.cfi_def_cfa 4, 4
 2969 1d06 C3       		ret
 2970              		.cfi_endproc
 2971              	.LFE17:
 2973              		.globl	InitializeGuest
 2975              	InitializeGuest:
 2976              	.LFB18:
 774:guest.c       **** 
 775:guest.c       **** void InitializeGuest()
 776:guest.c       **** {
 2977              		.loc 1 776 0
 2978              		.cfi_startproc
 2979 1d07 55       		push	ebp
 2980              		.cfi_def_cfa_offset 8
 2981              		.cfi_offset 5, -8
 2982 1d08 89E5     		mov	ebp, esp
 2983              		.cfi_def_cfa_register 5
 777:guest.c       ****     //The shadow CR0 represents what the guest thinks the CR0 is, so no paging when we first boot
 778:guest.c       ****     guest.guestViewCR0 = 0x10010; //WP bit and extension bit sest
 2984              		.loc 1 778 0
 2985 1d0a C7051400 		mov	DWORD PTR guest+20, 65552
 2985      00001000 
 2985      0100
 779:guest.c       ****     guest.requestedCR3 = 0x0;
 2986              		.loc 1 779 0
 2987 1d14 C7050C00 		mov	DWORD PTR guest+12, 0
 2987      00000000 
 2987      0000
 780:guest.c       **** 
 781:guest.c       ****     //Configure the vmcb
 782:guest.c       ****     guest.vmcb = (struct vmcb_struct*)vhost.VMCBOffset;  //OFFSET is from DS base
 2988              		.loc 1 782 0
 2989 1d1e A1080000 		mov	eax, DWORD PTR vhost+8
 2989      00
 2990 1d23 A3040000 		mov	DWORD PTR guest+4, eax
 2990      00
 783:guest.c       ****     guest.vmcb->cr0 = 0x00000000 | guest.guestViewCR0;
 2991              		.loc 1 783 0
 2992 1d28 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2992      0000
 2993 1d2e A1140000 		mov	eax, DWORD PTR guest+20
 2993      00
 2994 1d33 BA000000 		mov	edx, 0
 2994      00
 2995 1d38 89815805 		mov	DWORD PTR [ecx+1368], eax
 2995      0000
 2996 1d3e 89915C05 		mov	DWORD PTR [ecx+1372], edx
 2996      0000
 784:guest.c       ****     guest.vmcb->nested_cr3 = vhost.CodeBase + vhost.NestedCR3;  //Vid Bios is 0xFFFF bytes
 2997              		.loc 1 784 0
 2998 1d44 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2998      0000
 2999 1d4a 8B150000 		mov	edx, DWORD PTR vhost
 2999      0000
 3000 1d50 A1240000 		mov	eax, DWORD PTR vhost+36
 3000      00
 3001 1d55 01D0     		add	eax, edx
 3002 1d57 BA000000 		mov	edx, 0
 3002      00
 3003 1d5c 8981B000 		mov	DWORD PTR [ecx+176], eax
 3003      0000
 3004 1d62 8991B400 		mov	DWORD PTR [ecx+180], edx
 3004      0000
 785:guest.c       ****     guest.nonPagingCR3 = guest.vmcb->nested_cr3;
 3005              		.loc 1 785 0
 3006 1d68 A1040000 		mov	eax, DWORD PTR guest+4
 3006      00
 3007 1d6d 8B90B400 		mov	edx, DWORD PTR [eax+180]
 3007      0000
 3008 1d73 8B80B000 		mov	eax, DWORD PTR [eax+176]
 3008      0000
 3009 1d79 A3100000 		mov	DWORD PTR guest+16, eax
 3009      00
 786:guest.c       ****     guest.vmcb->cr_intercepts = 0x0; //0x90009; //(0x1 << CR3_INTERCEPT_WRITE_ENABLE) | (0x1 << CR3
 3010              		.loc 1 786 0
 3011 1d7e A1040000 		mov	eax, DWORD PTR guest+4
 3011      00
 3012 1d83 C7000000 		mov	DWORD PTR [eax], 0
 3012      0000
 787:guest.c       ****     guest.vmcb->exception_intercepts=0x0;
 3013              		.loc 1 787 0
 3014 1d89 A1040000 		mov	eax, DWORD PTR guest+4
 3014      00
 3015 1d8e C7400800 		mov	DWORD PTR [eax+8], 0
 3015      000000
 788:guest.c       ****     guest.vmcb->general1_intercepts = 0x200000; /*INT*///0x89240000; //HLT, IOIO, Shutdown, Int, CP
 3016              		.loc 1 788 0
 3017 1d95 A1040000 		mov	eax, DWORD PTR guest+4
 3017      00
 3018 1d9a C7400C00 		mov	DWORD PTR [eax+12], 2097152
 3018      002000
 789:guest.c       ****     guest.vmcb->general2_intercepts = 0x1; //0x1FFF; Appears that vmrun has to be set
 3019              		.loc 1 789 0
 3020 1da1 A1040000 		mov	eax, DWORD PTR guest+4
 3020      00
 3021 1da6 C7401001 		mov	DWORD PTR [eax+16], 1
 3021      000000
 790:guest.c       ****     //guest starts with nested paging off and paging intercepts on
 791:guest.c       ****     guest.vmcb->exception_intercepts = 0x0 ;//0x6000;  //also GPF - exception 13
 3022              		.loc 1 791 0
 3023 1dad A1040000 		mov	eax, DWORD PTR guest+4
 3023      00
 3024 1db2 C7400800 		mov	DWORD PTR [eax+8], 0
 3024      000000
 792:guest.c       ****     guest.vmcb->np_enable = false;
 3025              		.loc 1 792 0
 3026 1db9 A1040000 		mov	eax, DWORD PTR guest+4
 3026      00
 3027 1dbe C7809000 		mov	DWORD PTR [eax+144], 0
 3027      00000000 
 3027      0000
 3028 1dc8 C7809400 		mov	DWORD PTR [eax+148], 0
 3028      00000000 
 3028      0000
 793:guest.c       ****     guest.vmcb->guest_asid = 0x1;
 3029              		.loc 1 793 0
 3030 1dd2 A1040000 		mov	eax, DWORD PTR guest+4
 3030      00
 3031 1dd7 C7405801 		mov	DWORD PTR [eax+88], 1
 3031      000000
 794:guest.c       ****     guest.vmcb->tlb_control = 0x1;
 3032              		.loc 1 794 0
 3033 1dde A1040000 		mov	eax, DWORD PTR guest+4
 3033      00
 3034 1de3 C6405C01 		mov	BYTE PTR [eax+92], 1
 795:guest.c       ****     guest.vmcb->cs.base = 0x0;
 3035              		.loc 1 795 0
 3036 1de7 A1040000 		mov	eax, DWORD PTR guest+4
 3036      00
 3037 1dec C7801804 		mov	DWORD PTR [eax+1048], 0
 3037      00000000 
 3037      0000
 3038 1df6 C7801C04 		mov	DWORD PTR [eax+1052], 0
 3038      00000000 
 3038      0000
 796:guest.c       ****     guest.vmcb->cs.limit = 0xffffffff;
 3039              		.loc 1 796 0
 3040 1e00 A1040000 		mov	eax, DWORD PTR guest+4
 3040      00
 3041 1e05 C7801404 		mov	DWORD PTR [eax+1044], -1
 3041      0000FFFF 
 3041      FFFF
 797:guest.c       ****     guest.vmcb->cs.attr.bytes = 0x93;
 3042              		.loc 1 797 0
 3043 1e0f A1040000 		mov	eax, DWORD PTR guest+4
 3043      00
 3044 1e14 66C78012 		mov	WORD PTR [eax+1042], 147
 3044      04000093 
 3044      00
 798:guest.c       ****     guest.vmcb->ds.base = 0x0;
 3045              		.loc 1 798 0
 3046 1e1d A1040000 		mov	eax, DWORD PTR guest+4
 3046      00
 3047 1e22 C7803804 		mov	DWORD PTR [eax+1080], 0
 3047      00000000 
 3047      0000
 3048 1e2c C7803C04 		mov	DWORD PTR [eax+1084], 0
 3048      00000000 
 3048      0000
 799:guest.c       ****     guest.vmcb->ds.limit = 0xffffffff;
 3049              		.loc 1 799 0
 3050 1e36 A1040000 		mov	eax, DWORD PTR guest+4
 3050      00
 3051 1e3b C7803404 		mov	DWORD PTR [eax+1076], -1
 3051      0000FFFF 
 3051      FFFF
 800:guest.c       ****     guest.vmcb->ds.attr.bytes = 0x93;
 3052              		.loc 1 800 0
 3053 1e45 A1040000 		mov	eax, DWORD PTR guest+4
 3053      00
 3054 1e4a 66C78032 		mov	WORD PTR [eax+1074], 147
 3054      04000093 
 3054      00
 801:guest.c       ****     guest.vmcb->es.base = 0x0;
 3055              		.loc 1 801 0
 3056 1e53 A1040000 		mov	eax, DWORD PTR guest+4
 3056      00
 3057 1e58 C7800804 		mov	DWORD PTR [eax+1032], 0
 3057      00000000 
 3057      0000
 3058 1e62 C7800C04 		mov	DWORD PTR [eax+1036], 0
 3058      00000000 
 3058      0000
 802:guest.c       ****     guest.vmcb->es.limit = 0xffffffff;
 3059              		.loc 1 802 0
 3060 1e6c A1040000 		mov	eax, DWORD PTR guest+4
 3060      00
 3061 1e71 C7800404 		mov	DWORD PTR [eax+1028], -1
 3061      0000FFFF 
 3061      FFFF
 803:guest.c       ****     guest.vmcb->es.attr.bytes = 0x93;
 3062              		.loc 1 803 0
 3063 1e7b A1040000 		mov	eax, DWORD PTR guest+4
 3063      00
 3064 1e80 66C78002 		mov	WORD PTR [eax+1026], 147
 3064      04000093 
 3064      00
 804:guest.c       ****     guest.vmcb->fs.base = 0x0;
 3065              		.loc 1 804 0
 3066 1e89 A1040000 		mov	eax, DWORD PTR guest+4
 3066      00
 3067 1e8e C7804804 		mov	DWORD PTR [eax+1096], 0
 3067      00000000 
 3067      0000
 3068 1e98 C7804C04 		mov	DWORD PTR [eax+1100], 0
 3068      00000000 
 3068      0000
 805:guest.c       ****     guest.vmcb->fs.limit = 0xffffffff;
 3069              		.loc 1 805 0
 3070 1ea2 A1040000 		mov	eax, DWORD PTR guest+4
 3070      00
 3071 1ea7 C7804404 		mov	DWORD PTR [eax+1092], -1
 3071      0000FFFF 
 3071      FFFF
 806:guest.c       ****     guest.vmcb->fs.attr.bytes = 0x93;
 3072              		.loc 1 806 0
 3073 1eb1 A1040000 		mov	eax, DWORD PTR guest+4
 3073      00
 3074 1eb6 66C78042 		mov	WORD PTR [eax+1090], 147
 3074      04000093 
 3074      00
 807:guest.c       ****     guest.vmcb->gs.base = 0x0;
 3075              		.loc 1 807 0
 3076 1ebf A1040000 		mov	eax, DWORD PTR guest+4
 3076      00
 3077 1ec4 C7805804 		mov	DWORD PTR [eax+1112], 0
 3077      00000000 
 3077      0000
 3078 1ece C7805C04 		mov	DWORD PTR [eax+1116], 0
 3078      00000000 
 3078      0000
 808:guest.c       ****     guest.vmcb->gs.limit = 0xffffffff;
 3079              		.loc 1 808 0
 3080 1ed8 A1040000 		mov	eax, DWORD PTR guest+4
 3080      00
 3081 1edd C7805404 		mov	DWORD PTR [eax+1108], -1
 3081      0000FFFF 
 3081      FFFF
 809:guest.c       ****     guest.vmcb->gs.attr.bytes = 0x93;
 3082              		.loc 1 809 0
 3083 1ee7 A1040000 		mov	eax, DWORD PTR guest+4
 3083      00
 3084 1eec 66C78052 		mov	WORD PTR [eax+1106], 147
 3084      04000093 
 3084      00
 810:guest.c       ****     guest.vmcb->ss.base = 0x0;
 3085              		.loc 1 810 0
 3086 1ef5 A1040000 		mov	eax, DWORD PTR guest+4
 3086      00
 3087 1efa C7802804 		mov	DWORD PTR [eax+1064], 0
 3087      00000000 
 3087      0000
 3088 1f04 C7802C04 		mov	DWORD PTR [eax+1068], 0
 3088      00000000 
 3088      0000
 811:guest.c       ****     guest.vmcb->ss.limit = 0xffffffff;
 3089              		.loc 1 811 0
 3090 1f0e A1040000 		mov	eax, DWORD PTR guest+4
 3090      00
 3091 1f13 C7802404 		mov	DWORD PTR [eax+1060], -1
 3091      0000FFFF 
 3091      FFFF
 812:guest.c       ****     guest.vmcb->ss.attr.bytes = 0x93;
 3092              		.loc 1 812 0
 3093 1f1d A1040000 		mov	eax, DWORD PTR guest+4
 3093      00
 3094 1f22 66C78022 		mov	WORD PTR [eax+1058], 147
 3094      04000093 
 3094      00
 813:guest.c       ****     guest.vmcb->idtr.limit = 0xffff;
 3095              		.loc 1 813 0
 3096 1f2b A1040000 		mov	eax, DWORD PTR guest+4
 3096      00
 3097 1f30 C7808404 		mov	DWORD PTR [eax+1156], 65535
 3097      0000FFFF 
 3097      0000
 814:guest.c       ****     guest.vmcb->cpl = 3;
 3098              		.loc 1 814 0
 3099 1f3a A1040000 		mov	eax, DWORD PTR guest+4
 3099      00
 3100 1f3f C680CB04 		mov	BYTE PTR [eax+1227], 3
 3100      000003
 815:guest.c       ****     guest.vmcb->efer = 0x1000;
 3101              		.loc 1 815 0
 3102 1f46 A1040000 		mov	eax, DWORD PTR guest+4
 3102      00
 3103 1f4b C780D004 		mov	DWORD PTR [eax+1232], 4096
 3103      00000010 
 3103      0000
 3104 1f55 C780D404 		mov	DWORD PTR [eax+1236], 0
 3104      00000000 
 3104      0000
 816:guest.c       ****     //see above for CR0
 817:guest.c       ****     guest.vmcb->cr2 = 0x0;
 3105              		.loc 1 817 0
 3106 1f5f A1040000 		mov	eax, DWORD PTR guest+4
 3106      00
 3107 1f64 C7804006 		mov	DWORD PTR [eax+1600], 0
 3107      00000000 
 3107      0000
 3108 1f6e C7804406 		mov	DWORD PTR [eax+1604], 0
 3108      00000000 
 3108      0000
 818:guest.c       ****     //Session starts in paged-real mode so we'll point the guest at the nested page tables
 819:guest.c       ****     //that we will use later for the real nested paging
 820:guest.c       ****     guest.vmcb->cr3 = guest.vmcb->nested_cr3;
 3109              		.loc 1 820 0
 3110 1f78 8B0D0400 		mov	ecx, DWORD PTR guest+4
 3110      0000
 3111 1f7e A1040000 		mov	eax, DWORD PTR guest+4
 3111      00
 3112 1f83 8B90B400 		mov	edx, DWORD PTR [eax+180]
 3112      0000
 3113 1f89 8B80B000 		mov	eax, DWORD PTR [eax+176]
 3113      0000
 3114 1f8f 89815005 		mov	DWORD PTR [ecx+1360], eax
 3114      0000
 3115 1f95 89915405 		mov	DWORD PTR [ecx+1364], edx
 3115      0000
 821:guest.c       ****     guest.vmcb->cr4 = 0x0;
 3116              		.loc 1 821 0
 3117 1f9b A1040000 		mov	eax, DWORD PTR guest+4
 3117      00
 3118 1fa0 C7804805 		mov	DWORD PTR [eax+1352], 0
 3118      00000000 
 3118      0000
 3119 1faa C7804C05 		mov	DWORD PTR [eax+1356], 0
 3119      00000000 
 3119      0000
 822:guest.c       ****     guest.vmcb->rflags = 0x82;
 3120              		.loc 1 822 0
 3121 1fb4 A1040000 		mov	eax, DWORD PTR guest+4
 3121      00
 3122 1fb9 C7807005 		mov	DWORD PTR [eax+1392], 130
 3122      00008200 
 3122      0000
 3123 1fc3 C7807405 		mov	DWORD PTR [eax+1396], 0
 3123      00000000 
 3123      0000
 823:guest.c       ****     guest.vmcb->rsp = 0xffd6;
 3124              		.loc 1 823 0
 3125 1fcd A1040000 		mov	eax, DWORD PTR guest+4
 3125      00
 3126 1fd2 C780D805 		mov	DWORD PTR [eax+1496], 65494
 3126      0000D6FF 
 3126      0000
 3127 1fdc C780DC05 		mov	DWORD PTR [eax+1500], 0
 3127      00000000 
 3127      0000
 824:guest.c       ****     guest.vmcb->rip = 0x7c00;
 3128              		.loc 1 824 0
 3129 1fe6 A1040000 		mov	eax, DWORD PTR guest+4
 3129      00
 3130 1feb C7807805 		mov	DWORD PTR [eax+1400], 31744
 3130      0000007C 
 3130      0000
 3131 1ff5 C7807C05 		mov	DWORD PTR [eax+1404], 0
 3131      00000000 
 3131      0000
 825:guest.c       ****     guest.vmcb->rax = 0xaa55;
 3132              		.loc 1 825 0
 3133 1fff A1040000 		mov	eax, DWORD PTR guest+4
 3133      00
 3134 2004 C780F805 		mov	DWORD PTR [eax+1528], 43605
 3134      000055AA 
 3134      0000
 3135 200e C780FC05 		mov	DWORD PTR [eax+1532], 0
 3135      00000000 
 3135      0000
 826:guest.c       **** }
 3136              		.loc 1 826 0
 3137 2018 90       		nop
 3138 2019 5D       		pop	ebp
 3139              		.cfi_restore 5
 3140              		.cfi_def_cfa 4, 4
 3141 201a C3       		ret
 3142              		.cfi_endproc
 3143              	.LFE18:
 3145              		.globl	SetIOIOPort
 3147              	SetIOIOPort:
 3148              	.LFB19:
 827:guest.c       **** 
 828:guest.c       **** void SetIOIOPort(int PortNum, bool Value)
 829:guest.c       **** {
 3149              		.loc 1 829 0
 3150              		.cfi_startproc
 3151 201b 55       		push	ebp
 3152              		.cfi_def_cfa_offset 8
 3153              		.cfi_offset 5, -8
 3154 201c 89E5     		mov	ebp, esp
 3155              		.cfi_def_cfa_register 5
 3156 201e 53       		push	ebx
 3157 201f 83EC1C   		sub	esp, 28
 3158              		.cfi_offset 3, -12
 3159 2022 8B450C   		mov	eax, DWORD PTR [ebp+12]
 3160 2025 8845E4   		mov	BYTE PTR [ebp-28], al
 830:guest.c       ****     BYTE * ioBytes = (BYTE *) (DWORD)guest.vmcb->iopm_base_pa;
 3161              		.loc 1 830 0
 3162 2028 A1040000 		mov	eax, DWORD PTR guest+4
 3162      00
 3163 202d 8B5044   		mov	edx, DWORD PTR [eax+68]
 3164 2030 8B4040   		mov	eax, DWORD PTR [eax+64]
 3165 2033 8945F4   		mov	DWORD PTR [ebp-12], eax
 831:guest.c       ****     bool lValue = Value;
 3166              		.loc 1 831 0
 3167 2036 0FB645E4 		movzx	eax, BYTE PTR [ebp-28]
 3168 203a 8845F3   		mov	BYTE PTR [ebp-13], al
 832:guest.c       ****     BYTE lTheByte = 0;
 3169              		.loc 1 832 0
 3170 203d C645F200 		mov	BYTE PTR [ebp-14], 0
 833:guest.c       ****     
 834:guest.c       ****     OPEN_UP_DS
 3171              		.loc 1 834 0
 3172              	#APP
 3173              	# 834 "guest.c" 1
 835 2042 B8100000 	    lTheByte = ioBytes[PortNum/8];
 835      00
 836 2047 50       	    lTheByte |= ((lValue & 0x1) << (PortNum%8));
 837 2048 1F       	    ioBytes[PortNum/8] = lTheByte;
 838 2049 58       	    RESTORE_DS
 839              	}
 840              	
 835:guest.c       ****     lTheByte |= ((lValue & 0x1) << (PortNum%8));
 3174              		push eax
 3175              	 mov eax, 0x10
 3176              	 push eax
 3177              	 pop ds
 3178              	 pop eax
 3179              	
 3180              	# 0 "" 2
 3181              		.loc 1 835 0
 3182              	#NO_APP
 3183 204a 8B4508   		mov	eax, DWORD PTR [ebp+8]
 3184 204d 8D5007   		lea	edx, [eax+7]
 3185 2050 85C0     		test	eax, eax
 3186 2052 0F48C2   		cmovs	eax, edx
 3187 2055 C1F803   		sar	eax, 3
 3188 2058 89C2     		mov	edx, eax
 3189 205a 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 3190 205d 01D0     		add	eax, edx
 3191 205f 0FB600   		movzx	eax, BYTE PTR [eax]
 3192 2062 8845F2   		mov	BYTE PTR [ebp-14], al
 836:guest.c       ****     ioBytes[PortNum/8] = lTheByte;
 3193              		.loc 1 836 0
 3194 2065 0FB645F3 		movzx	eax, BYTE PTR [ebp-13]
 3195 2069 83E001   		and	eax, 1
 3196 206c 89C3     		mov	ebx, eax
 3197 206e 8B4508   		mov	eax, DWORD PTR [ebp+8]
 3198 2071 99       		cdq
 3199 2072 C1EA1D   		shr	edx, 29
 3200 2075 01D0     		add	eax, edx
 3201 2077 83E007   		and	eax, 7
 3202 207a 29D0     		sub	eax, edx
 3203 207c 89C1     		mov	ecx, eax
 3204 207e D3E3     		sal	ebx, cl
 3205 2080 89D8     		mov	eax, ebx
 3206 2082 89C2     		mov	edx, eax
 3207 2084 0FB645F2 		movzx	eax, BYTE PTR [ebp-14]
 3208 2088 09D0     		or	eax, edx
 3209 208a 8845F2   		mov	BYTE PTR [ebp-14], al
 837:guest.c       ****     RESTORE_DS
 3210              		.loc 1 837 0
 3211 208d 8B4508   		mov	eax, DWORD PTR [ebp+8]
 3212 2090 8D5007   		lea	edx, [eax+7]
 3213 2093 85C0     		test	eax, eax
 3214 2095 0F48C2   		cmovs	eax, edx
 3215 2098 C1F803   		sar	eax, 3
 3216 209b 89C2     		mov	edx, eax
 3217 209d 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 3218 20a0 01C2     		add	edx, eax
 3219 20a2 0FB645F2 		movzx	eax, BYTE PTR [ebp-14]
 3220 20a6 8802     		mov	BYTE PTR [edx], al
 838:guest.c       **** }
 3221              		.loc 1 838 0
 3222 20a8 B8380000 		mov	eax, 56
 3222      00
 3223              	#APP
 3224              	# 838 "guest.c" 1
 841 20b1 1F       	bool GetIOIOPort(int PortNum)
 842 20b2 58       	{
 843              	    BYTE * ioBytes = (BYTE *) (DWORD)guest.vmcb->iopm_base_pa;
 844              	    BYTE lTheByte = 0;
 839:guest.c       **** 
 3225              		push eax
 3226              	 mov eax, eax
 3227              	 push eax
 3228              	 pop ds
 3229              	 pop eax
 3230              	
 3231              	# 0 "" 2
 3232              		.loc 1 839 0
 3233              	#NO_APP
 3234 20b3 90       		nop
 3235 20b4 83C41C   		add	esp, 28
 3236 20b7 5B       		pop	ebx
 3237              		.cfi_restore 3
 3238 20b8 5D       		pop	ebp
 3239              		.cfi_restore 5
 3240              		.cfi_def_cfa 4, 4
 3241 20b9 C3       		ret
 3242              		.cfi_endproc
 3243              	.LFE19:
 3245              		.globl	GetIOIOPort
 3247              	GetIOIOPort:
 3248              	.LFB20:
 842:guest.c       ****     BYTE * ioBytes = (BYTE *) (DWORD)guest.vmcb->iopm_base_pa;
 3249              		.loc 1 842 0
 3250              		.cfi_startproc
 3251 20ba 55       		push	ebp
 3252              		.cfi_def_cfa_offset 8
 3253              		.cfi_offset 5, -8
 3254 20bb 89E5     		mov	ebp, esp
 3255              		.cfi_def_cfa_register 5
 3256 20bd 83EC10   		sub	esp, 16
 843:guest.c       ****     BYTE lTheByte = 0;
 3257              		.loc 1 843 0
 3258 20c0 A1040000 		mov	eax, DWORD PTR guest+4
 3258      00
 3259 20c5 8B5044   		mov	edx, DWORD PTR [eax+68]
 3260 20c8 8B4040   		mov	eax, DWORD PTR [eax+64]
 3261 20cb 8945FC   		mov	DWORD PTR [ebp-4], eax
 3262              		.loc 1 844 0
 3263 20ce C645FB00 		mov	BYTE PTR [ebp-5], 0
 845:guest.c       **** 
 846:guest.c       ****     OPEN_UP_DS
 3264              		.loc 1 846 0
 3265              	#APP
 3266              	# 846 "guest.c" 1
 847 20d3 B8100000 	    lTheByte = ioBytes[PortNum/8];
 847      00
 848 20d8 50       	    RESTORE_DS
 849 20d9 1F       	    return ( lTheByte >> (PortNum-1)) & 1;
 850 20da 58       	}
 851              	
 852              	//Guest paging requests will only come in paged-real mode (when the guest hasn't turned on paging)
 847:guest.c       ****     RESTORE_DS
 3267              		push eax
 3268              	 mov eax, 0x10
 3269              	 push eax
 3270              	 pop ds
 3271              	 pop eax
 3272              	
 3273              	# 0 "" 2
 3274              		.loc 1 847 0
 3275              	#NO_APP
 3276 20db 8B4508   		mov	eax, DWORD PTR [ebp+8]
 3277 20de 8D5007   		lea	edx, [eax+7]
 3278 20e1 85C0     		test	eax, eax
 3279 20e3 0F48C2   		cmovs	eax, edx
 3280 20e6 C1F803   		sar	eax, 3
 3281 20e9 89C2     		mov	edx, eax
 3282 20eb 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 3283 20ee 01D0     		add	eax, edx
 3284 20f0 0FB600   		movzx	eax, BYTE PTR [eax]
 3285 20f3 8845FB   		mov	BYTE PTR [ebp-5], al
 848:guest.c       ****     return ( lTheByte >> (PortNum-1)) & 1;
 3286              		.loc 1 848 0
 3287 20f6 B8380000 		mov	eax, 56
 3287      00
 3288              	#APP
 3289              	# 848 "guest.c" 1
 853              	//In this case as long as the request is < guest's memory size, dont' do anything.
 854              	//If the request is > the guest's memory size then inject a paging exception into the guest and
 849:guest.c       **** }
 3290              		push eax
 3291              	 mov eax, eax
 3292              	 push eax
 3293              	 pop ds
 3294              	 pop eax
 3295              	
 3296              	# 0 "" 2
 3297              		.loc 1 849 0
 3298              	#NO_APP
 3299 2101 0FB655FB 		movzx	edx, BYTE PTR [ebp-5]
 3300 2105 8B4508   		mov	eax, DWORD PTR [ebp+8]
 3301 2108 83E801   		sub	eax, 1
 3302 210b 89C1     		mov	ecx, eax
 3303 210d D3FA     		sar	edx, cl
 3304 210f 89D0     		mov	eax, edx
 3305 2111 83E001   		and	eax, 1
 3306 2114 85C0     		test	eax, eax
 3307 2116 0F95C0   		setne	al
 850:guest.c       **** 
 3308              		.loc 1 850 0
 3309 2119 C9       		leave
 3310              		.cfi_restore 5
 3311              		.cfi_def_cfa 4, 4
 3312 211a C3       		ret
 3313              		.cfi_endproc
 3314              	.LFE20:
 3316              		.globl	HandleGuestPagingException
 3318              	HandleGuestPagingException:
 3319              	.LFB21:
 855:guest.c       **** //set the CR2
 856:guest.c       **** //NOTE: #PF does not increment the IP ... it points to the offending instruction
 857:guest.c       **** void HandleGuestPagingException(DWORD guestAddress, DWORD exceptionCode)
 858:guest.c       **** {
 3320              		.loc 1 858 0
 3321              		.cfi_startproc
 3322 211b 55       		push	ebp
 3323              		.cfi_def_cfa_offset 8
 3324              		.cfi_offset 5, -8
 3325 211c 89E5     		mov	ebp, esp
 3326              		.cfi_def_cfa_register 5
 859:guest.c       ****     if (guestAddress < guest.memSize)
 3327              		.loc 1 859 0
 3328 211e A1000000 		mov	eax, DWORD PTR guest
 3328      00
 3329 2123 3B4508   		cmp	eax, DWORD PTR [ebp+8]
 3330 2126 776C     		ja	.L218
 860:guest.c       ****         return;
 861:guest.c       ****     
 862:guest.c       ****     guest.vmcb->eventinj.fields.v = true;
 3331              		.loc 1 862 0
 3332 2128 A1040000 		mov	eax, DWORD PTR guest+4
 3332      00
 3333 212d 0FB690AB 		movzx	edx, BYTE PTR [eax+171]
 3333      000000
 3334 2134 83CA80   		or	edx, -128
 3335 2137 8890AB00 		mov	BYTE PTR [eax+171], dl
 3335      0000
 863:guest.c       ****     guest.vmcb->eventinj.fields.ev = true;
 3336              		.loc 1 863 0
 3337 213d A1040000 		mov	eax, DWORD PTR guest+4
 3337      00
 3338 2142 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 3338      000000
 3339 2149 83CA08   		or	edx, 8
 3340 214c 8890A900 		mov	BYTE PTR [eax+169], dl
 3340      0000
 864:guest.c       ****     guest.vmcb->eventinj.fields.type = 3; //exception
 3341              		.loc 1 864 0
 3342 2152 A1040000 		mov	eax, DWORD PTR guest+4
 3342      00
 3343 2157 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 3343      000000
 3344 215e 83E2F8   		and	edx, -8
 3345 2161 83CA03   		or	edx, 3
 3346 2164 8890A900 		mov	BYTE PTR [eax+169], dl
 3346      0000
 865:guest.c       ****     guest.vmcb->eventinj.fields.errorcode = exceptionCode;
 3347              		.loc 1 865 0
 3348 216a A1040000 		mov	eax, DWORD PTR guest+4
 3348      00
 3349 216f 8B550C   		mov	edx, DWORD PTR [ebp+12]
 3350 2172 8990AC00 		mov	DWORD PTR [eax+172], edx
 3350      0000
 866:guest.c       ****     guest.vmcb->cr2 = guestAddress;
 3351              		.loc 1 866 0
 3352 2178 8B0D0400 		mov	ecx, DWORD PTR guest+4
 3352      0000
 3353 217e 8B4508   		mov	eax, DWORD PTR [ebp+8]
 3354 2181 BA000000 		mov	edx, 0
 3354      00
 3355 2186 89814006 		mov	DWORD PTR [ecx+1600], eax
 3355      0000
 3356 218c 89914406 		mov	DWORD PTR [ecx+1604], edx
 3356      0000
 3357 2192 EB01     		jmp	.L215
 3358              	.L218:
 860:guest.c       ****     
 3359              		.loc 1 860 0
 3360 2194 90       		nop
 3361              	.L215:
 867:guest.c       ****     //guest.vmcb->rip = guest.vmcb->nextrip;
 868:guest.c       **** }
 3362              		.loc 1 868 0
 3363 2195 5D       		pop	ebp
 3364              		.cfi_restore 5
 3365              		.cfi_def_cfa 4, 4
 3366 2196 C3       		ret
 3367              		.cfi_endproc
 3368              	.LFE21:
 3370              		.globl	HandleGuestCPUID
 3372              	HandleGuestCPUID:
 3373              	.LFB22:
 869:guest.c       **** void HandleGuestCPUID(int code, DWORD* a, DWORD* b, DWORD* c, DWORD* d)
 870:guest.c       **** {
 3374              		.loc 1 870 0
 3375              		.cfi_startproc
 3376 2197 55       		push	ebp
 3377              		.cfi_def_cfa_offset 8
 3378              		.cfi_offset 5, -8
 3379 2198 89E5     		mov	ebp, esp
 3380              		.cfi_def_cfa_register 5
 3381 219a 56       		push	esi
 3382 219b 53       		push	ebx
 3383              		.cfi_offset 6, -12
 3384              		.cfi_offset 3, -16
 871:guest.c       ****     
 872:guest.c       ****     asm volatile ( "cpuid" : "=a"(*a), "=d"(*d), "=c"(*c), "=b"(*b) : "0"(code));
 3385              		.loc 1 872 0
 3386 219c 8B4508   		mov	eax, DWORD PTR [ebp+8]
 3387              	#APP
 3388              	# 872 "guest.c" 1
 873              	    
 3389              		cpuid
 3390              	# 0 "" 2
 3391              	#NO_APP
 3392 21a1 8B750C   		mov	esi, DWORD PTR [ebp+12]
 3393 21a4 8906     		mov	DWORD PTR [esi], eax
 3394 21a6 8B4518   		mov	eax, DWORD PTR [ebp+24]
 3395 21a9 8910     		mov	DWORD PTR [eax], edx
 3396 21ab 8B4514   		mov	eax, DWORD PTR [ebp+20]
 3397 21ae 8908     		mov	DWORD PTR [eax], ecx
 3398 21b0 8B4510   		mov	eax, DWORD PTR [ebp+16]
 3399 21b3 8918     		mov	DWORD PTR [eax], ebx
 874:guest.c       **** }
 3400              		.loc 1 874 0
 3401 21b5 90       		nop
 3402 21b6 5B       		pop	ebx
 3403              		.cfi_restore 3
 3404 21b7 5E       		pop	esi
 3405              		.cfi_restore 6
 3406 21b8 5D       		pop	ebp
 3407              		.cfi_restore 5
 3408              		.cfi_def_cfa 4, 4
 3409 21b9 C3       		ret
 3410              		.cfi_endproc
 3411              	.LFE22:
 3413              	.Letext0:
 3414              		.file 2 "types.h"
 3415              		.file 3 "xen_types.h"
 3416              		.file 4 "x86_architecture.h"
 3417              		.file 5 "vmcb.h"
 3418              		.file 6 "host.h"
 3419              		.file 7 "guest.h"
 3420              		.file 8 "isr_wrapper.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 guest.c
     /tmp/ccb2vt7W.s:4      .text:0000000000000000 .Ltext0
                            *COM*:0000000000000002 _exception_number
                            *COM*:0000000000000002 _exc_CS
                            *COM*:0000000000000002 _exc_IP
                            *COM*:0000000000000044 vhost
                            *COM*:000000000000001c guest
                            *COM*:0000000000000038 GuestRegisters
                            *COM*:0000000000000004 lTempDest
                            *COM*:0000000000000004 lTempSource
     /tmp/ccb2vt7W.s:18     .data:0000000000000000 IntDetails
     /tmp/ccb2vt7W.s:25     .bss:0000000000000000 IntDetailsPtr
     /tmp/ccb2vt7W.s:28     .bss:0000000000000004 IOPortInValue
     /tmp/ccb2vt7W.s:30     .bss:0000000000000008 IOPortInValueSet
     /tmp/ccb2vt7W.s:34     .text:0000000000000000 GetCSIp
     /tmp/ccb2vt7W.s:35     .text:0000000000000000 .LFB0
     /tmp/ccb2vt7W.s:59     .text:000000000000002b .LFE0
     /tmp/ccb2vt7W.s:63     .text:000000000000002b IncrementGuestIP
     /tmp/ccb2vt7W.s:64     .text:000000000000002b .LFB1
     /tmp/ccb2vt7W.s:102    .text:0000000000000071 .LFE1
     /tmp/ccb2vt7W.s:106    .text:0000000000000071 SetupGuestBootMemory
     /tmp/ccb2vt7W.s:107    .text:0000000000000071 .LFB2
     /tmp/ccb2vt7W.s:176    .text:0000000000000115 .L5
     /tmp/ccb2vt7W.s:161    .text:00000000000000e9 .L6
     /tmp/ccb2vt7W.s:199    .text:000000000000012c .LFE2
     /tmp/ccb2vt7W.s:203    .text:000000000000012c DoGuestPageLookup
     /tmp/ccb2vt7W.s:204    .text:000000000000012c .LFB3
     /tmp/ccb2vt7W.s:234    .text:0000000000000166 .L8
     /tmp/ccb2vt7W.s:237    .text:000000000000016b .L9
     /tmp/ccb2vt7W.s:259    .text:00000000000001a8 .L10
     /tmp/ccb2vt7W.s:309    .text:0000000000000233 .L11
     /tmp/ccb2vt7W.s:323    .text:000000000000023b .LFE3
     /tmp/ccb2vt7W.s:327    .text:000000000000023b DoNestedPageLookup
     /tmp/ccb2vt7W.s:328    .text:000000000000023b .LFB4
     /tmp/ccb2vt7W.s:396    .text:00000000000002ee .L13
     /tmp/ccb2vt7W.s:350    .text:000000000000026d .LBB2
     /tmp/ccb2vt7W.s:400    .text:00000000000002f1 .L14
     /tmp/ccb2vt7W.s:397    .text:00000000000002ee .LBE2
     /tmp/ccb2vt7W.s:407    .text:00000000000002f3 .LFE4
     /tmp/ccb2vt7W.s:411    .text:00000000000002f3 CaptureInterruptDetails
     /tmp/ccb2vt7W.s:412    .text:00000000000002f3 .LFB5
     /tmp/ccb2vt7W.s:479    .text:00000000000003c5 .LFE5
     /tmp/ccb2vt7W.s:483    .text:00000000000003c5 HandleRealModeSWInterrupt
     /tmp/ccb2vt7W.s:484    .text:00000000000003c5 .LFB6
     /tmp/ccb2vt7W.s:523    .text:0000000000000420 .L18
     /tmp/ccb2vt7W.s:510    .text:00000000000003ef .L19
     /tmp/ccb2vt7W.s:516    .text:0000000000000402 .L20
     /tmp/ccb2vt7W.s:863    .text:00000000000008f4 .L17
     /tmp/ccb2vt7W.s:530    .text:000000000000043e .L21
     /tmp/ccb2vt7W.s:605    .text:000000000000055f .L22
     /tmp/ccb2vt7W.s:895    .text:000000000000096f .L23
     /tmp/ccb2vt7W.s:573    .text:00000000000004e0 .L24
     /tmp/ccb2vt7W.s:659    .text:0000000000000621 .L26
     /tmp/ccb2vt7W.s:632    .text:00000000000005bf .L27
     /tmp/ccb2vt7W.s:641    .text:00000000000005e3 .L28
     /tmp/ccb2vt7W.s:716    .text:00000000000006ea .L30
     /tmp/ccb2vt7W.s:799    .text:00000000000007f6 .L31
     /tmp/ccb2vt7W.s:840    .text:00000000000008a1 .L32
     /tmp/ccb2vt7W.s:910    .text:000000000000097b .LFE6
     /tmp/ccb2vt7W.s:914    .text:000000000000097b PopCSIPFlagsOffGuestStackReal16
     /tmp/ccb2vt7W.s:915    .text:000000000000097b .LFB7
     /tmp/ccb2vt7W.s:3318   .text:000000000000211b HandleGuestPagingException
     /tmp/ccb2vt7W.s:1021   .text:0000000000000ab7 .LFE7
     /tmp/ccb2vt7W.s:1025   .text:0000000000000ab7 HandleInterrutpReturn
     /tmp/ccb2vt7W.s:1026   .text:0000000000000ab7 .LFB8
     /tmp/ccb2vt7W.s:1044   .text:0000000000000ac5 .LFE8
     /tmp/ccb2vt7W.s:1048   .text:0000000000000ac5 HandleCR0Write
     /tmp/ccb2vt7W.s:1049   .text:0000000000000ac5 .LFB9
     /tmp/ccb2vt7W.s:1093   .text:0000000000000b1f .L36
     /tmp/ccb2vt7W.s:1660   .text:0000000000001096 GetGPRValue
     /tmp/ccb2vt7W.s:1132   .text:0000000000000bae .L37
     /tmp/ccb2vt7W.s:1125   .text:0000000000000b95 .L38
     /tmp/ccb2vt7W.s:1258   .text:0000000000000d5c .L35
     /tmp/ccb2vt7W.s:1163   .text:0000000000000c10 .L40
     /tmp/ccb2vt7W.s:1191   .text:0000000000000c64 .L42
     /tmp/ccb2vt7W.s:1221   .text:0000000000000cd1 .L43
     /tmp/ccb2vt7W.s:1250   .text:0000000000000d39 .L44
     /tmp/ccb2vt7W.s:1272   .text:0000000000000d64 .LFE9
     /tmp/ccb2vt7W.s:1276   .text:0000000000000d64 HandleCR0Read
     /tmp/ccb2vt7W.s:1277   .text:0000000000000d64 .LFB10
     /tmp/ccb2vt7W.s:1314   .text:0000000000000db7 .L46
     /tmp/ccb2vt7W.s:1355   .text:0000000000000e0f SetGPRValue
     /tmp/ccb2vt7W.s:1327   .text:0000000000000dd5 .L47
     /tmp/ccb2vt7W.s:2275   .text:0000000000001606 SetGuestMODRegGenRegValue
     /tmp/ccb2vt7W.s:1336   .text:0000000000000de9 .L48
     /tmp/ccb2vt7W.s:1351   .text:0000000000000e0f .LFE10
     /tmp/ccb2vt7W.s:1356   .text:0000000000000e0f .LFB11
     /tmp/ccb2vt7W.s:1643   .text:000000000000108e .L84
     /tmp/ccb2vt7W.s:1384   .rodata:0000000000000000 .L52
     /tmp/ccb2vt7W.s:1394   .text:0000000000000e3c .L51
     /tmp/ccb2vt7W.s:1441   .text:0000000000000ecd .L53
     /tmp/ccb2vt7W.s:1467   .text:0000000000000f06 .L54
     /tmp/ccb2vt7W.s:1493   .text:0000000000000f3f .L55
     /tmp/ccb2vt7W.s:1519   .text:0000000000000f78 .L56
     /tmp/ccb2vt7W.s:1563   .text:0000000000000fff .L57
     /tmp/ccb2vt7W.s:1589   .text:000000000000102f .L58
     /tmp/ccb2vt7W.s:1615   .text:000000000000105f .L59
     /tmp/ccb2vt7W.s:1406   .text:0000000000000e61 .L60
     /tmp/ccb2vt7W.s:1642   .text:000000000000108e .L50
     /tmp/ccb2vt7W.s:1425   .text:0000000000000e9a .L62
     /tmp/ccb2vt7W.s:1450   .text:0000000000000ee0 .L63
     /tmp/ccb2vt7W.s:1460   .text:0000000000000ef6 .L65
     /tmp/ccb2vt7W.s:1476   .text:0000000000000f19 .L66
     /tmp/ccb2vt7W.s:1486   .text:0000000000000f2f .L68
     /tmp/ccb2vt7W.s:1502   .text:0000000000000f52 .L69
     /tmp/ccb2vt7W.s:1512   .text:0000000000000f68 .L71
     /tmp/ccb2vt7W.s:1531   .text:0000000000000f9d .L72
     /tmp/ccb2vt7W.s:1550   .text:0000000000000fd6 .L74
     /tmp/ccb2vt7W.s:1572   .text:000000000000100f .L75
     /tmp/ccb2vt7W.s:1582   .text:0000000000001022 .L77
     /tmp/ccb2vt7W.s:1598   .text:000000000000103f .L78
     /tmp/ccb2vt7W.s:1608   .text:0000000000001052 .L80
     /tmp/ccb2vt7W.s:1624   .text:000000000000106f .L81
     /tmp/ccb2vt7W.s:1639   .text:000000000000108d .L85
     /tmp/ccb2vt7W.s:1634   .text:0000000000001082 .L83
     /tmp/ccb2vt7W.s:1656   .text:0000000000001096 .LFE11
     /tmp/ccb2vt7W.s:1661   .text:0000000000001096 .LFB12
     /tmp/ccb2vt7W.s:1867   .text:000000000000127a .L87
     /tmp/ccb2vt7W.s:1685   .rodata:0000000000000020 .L89
     /tmp/ccb2vt7W.s:1695   .text:00000000000010c1 .L88
     /tmp/ccb2vt7W.s:1721   .text:0000000000001115 .L90
     /tmp/ccb2vt7W.s:1741   .text:0000000000001145 .L91
     /tmp/ccb2vt7W.s:1761   .text:0000000000001175 .L92
     /tmp/ccb2vt7W.s:1781   .text:00000000000011a5 .L93
     /tmp/ccb2vt7W.s:1807   .text:00000000000011f9 .L94
     /tmp/ccb2vt7W.s:1827   .text:0000000000001229 .L95
     /tmp/ccb2vt7W.s:1847   .text:0000000000001253 .L96
     /tmp/ccb2vt7W.s:1704   .text:00000000000010dd .L97
     /tmp/ccb2vt7W.s:1892   .text:00000000000012c3 .L98
     /tmp/ccb2vt7W.s:1714   .text:00000000000010fc .L99
     /tmp/ccb2vt7W.s:1728   .text:0000000000001125 .L100
     /tmp/ccb2vt7W.s:1736   .text:0000000000001138 .L101
     /tmp/ccb2vt7W.s:1748   .text:0000000000001155 .L102
     /tmp/ccb2vt7W.s:1756   .text:0000000000001168 .L103
     /tmp/ccb2vt7W.s:1768   .text:0000000000001185 .L104
     /tmp/ccb2vt7W.s:1776   .text:0000000000001198 .L105
     /tmp/ccb2vt7W.s:1790   .text:00000000000011c1 .L106
     /tmp/ccb2vt7W.s:1800   .text:00000000000011e0 .L107
     /tmp/ccb2vt7W.s:1814   .text:0000000000001209 .L108
     /tmp/ccb2vt7W.s:1822   .text:000000000000121c .L109
     /tmp/ccb2vt7W.s:1834   .text:0000000000001239 .L110
     /tmp/ccb2vt7W.s:1842   .text:0000000000001249 .L111
     /tmp/ccb2vt7W.s:1854   .text:0000000000001260 .L112
     /tmp/ccb2vt7W.s:1862   .text:0000000000001270 .L113
     /tmp/ccb2vt7W.s:1876   .text:0000000000001293 .L114
     /tmp/ccb2vt7W.s:1886   .text:00000000000012af .L115
     /tmp/ccb2vt7W.s:1899   .text:00000000000012c5 .LFE12
     /tmp/ccb2vt7W.s:1903   .text:00000000000012c5 HandleCR3Write
     /tmp/ccb2vt7W.s:1904   .text:00000000000012c5 .LFB13
     /tmp/ccb2vt7W.s:1932   .text:00000000000012ff .L117
     /tmp/ccb2vt7W.s:1941   .text:0000000000001315 .L118
     /tmp/ccb2vt7W.s:2033   .text:00000000000013df GetGuestMODRegGenRegValue
     /tmp/ccb2vt7W.s:1957   .text:0000000000001346 .L119
     /tmp/ccb2vt7W.s:1972   .text:000000000000136c .LFE13
     /tmp/ccb2vt7W.s:1976   .text:000000000000136c HandleCR3Read
     /tmp/ccb2vt7W.s:1977   .text:000000000000136c .LFB14
     /tmp/ccb2vt7W.s:2005   .text:00000000000013a5 .L121
     /tmp/ccb2vt7W.s:2014   .text:00000000000013b9 .L122
     /tmp/ccb2vt7W.s:2029   .text:00000000000013df .LFE14
     /tmp/ccb2vt7W.s:2034   .text:00000000000013df .LFB15
     /tmp/ccb2vt7W.s:2261   .text:00000000000015ff .L124
     /tmp/ccb2vt7W.s:2078   .rodata:0000000000000040 .L126
     /tmp/ccb2vt7W.s:2088   .text:0000000000001452 .L125
     /tmp/ccb2vt7W.s:2115   .text:00000000000014a9 .L127
     /tmp/ccb2vt7W.s:2135   .text:00000000000014d9 .L128
     /tmp/ccb2vt7W.s:2155   .text:0000000000001509 .L129
     /tmp/ccb2vt7W.s:2175   .text:0000000000001539 .L130
     /tmp/ccb2vt7W.s:2201   .text:000000000000158a .L131
     /tmp/ccb2vt7W.s:2221   .text:00000000000015b1 .L132
     /tmp/ccb2vt7W.s:2241   .text:00000000000015d8 .L133
     /tmp/ccb2vt7W.s:2098   .text:0000000000001471 .L134
     /tmp/ccb2vt7W.s:2264   .text:0000000000001604 .L135
     /tmp/ccb2vt7W.s:2108   .text:0000000000001490 .L136
     /tmp/ccb2vt7W.s:2122   .text:00000000000014b9 .L137
     /tmp/ccb2vt7W.s:2130   .text:00000000000014cc .L138
     /tmp/ccb2vt7W.s:2142   .text:00000000000014e9 .L139
     /tmp/ccb2vt7W.s:2150   .text:00000000000014fc .L140
     /tmp/ccb2vt7W.s:2162   .text:0000000000001519 .L141
     /tmp/ccb2vt7W.s:2170   .text:000000000000152c .L142
     /tmp/ccb2vt7W.s:2184   .text:0000000000001555 .L143
     /tmp/ccb2vt7W.s:2194   .text:0000000000001574 .L144
     /tmp/ccb2vt7W.s:2208   .text:0000000000001597 .L145
     /tmp/ccb2vt7W.s:2216   .text:00000000000015a7 .L146
     /tmp/ccb2vt7W.s:2228   .text:00000000000015be .L147
     /tmp/ccb2vt7W.s:2236   .text:00000000000015ce .L148
     /tmp/ccb2vt7W.s:2248   .text:00000000000015e5 .L149
     /tmp/ccb2vt7W.s:2256   .text:00000000000015f5 .L150
     /tmp/ccb2vt7W.s:2271   .text:0000000000001606 .LFE15
     /tmp/ccb2vt7W.s:2276   .text:0000000000001606 .LFB16
     /tmp/ccb2vt7W.s:2564   .text:00000000000018a3 .L186
     /tmp/ccb2vt7W.s:2322   .rodata:0000000000000060 .L154
     /tmp/ccb2vt7W.s:2332   .text:000000000000167a .L153
     /tmp/ccb2vt7W.s:2395   .text:0000000000001726 .L155
     /tmp/ccb2vt7W.s:2421   .text:000000000000175f .L156
     /tmp/ccb2vt7W.s:2369   .text:00000000000016ed .L157
     /tmp/ccb2vt7W.s:2499   .text:000000000000180a .L158
     /tmp/ccb2vt7W.s:2536   .text:0000000000001874 .L159
     /tmp/ccb2vt7W.s:2447   .text:0000000000001798 .L160
     /tmp/ccb2vt7W.s:2473   .text:00000000000017d1 .L161
     /tmp/ccb2vt7W.s:2344   .text:000000000000169f .L162
     /tmp/ccb2vt7W.s:2563   .text:00000000000018a3 .L152
     /tmp/ccb2vt7W.s:2358   .text:00000000000016c9 .L164
     /tmp/ccb2vt7W.s:2378   .text:0000000000001700 .L165
     /tmp/ccb2vt7W.s:2388   .text:0000000000001716 .L167
     /tmp/ccb2vt7W.s:2404   .text:0000000000001739 .L168
     /tmp/ccb2vt7W.s:2414   .text:000000000000174f .L170
     /tmp/ccb2vt7W.s:2430   .text:0000000000001772 .L171
     /tmp/ccb2vt7W.s:2440   .text:0000000000001788 .L173
     /tmp/ccb2vt7W.s:2456   .text:00000000000017ab .L174
     /tmp/ccb2vt7W.s:2466   .text:00000000000017c1 .L176
     /tmp/ccb2vt7W.s:2482   .text:00000000000017e4 .L177
     /tmp/ccb2vt7W.s:2492   .text:00000000000017fa .L179
     /tmp/ccb2vt7W.s:2511   .text:000000000000182c .L180
     /tmp/ccb2vt7W.s:2525   .text:0000000000001853 .L182
     /tmp/ccb2vt7W.s:2545   .text:0000000000001884 .L183
     /tmp/ccb2vt7W.s:2560   .text:00000000000018a2 .L187
     /tmp/ccb2vt7W.s:2555   .text:0000000000001897 .L185
     /tmp/ccb2vt7W.s:2574   .text:00000000000018a9 .LFE16
     /tmp/ccb2vt7W.s:2578   .text:00000000000018a9 HandleGuestIO
     /tmp/ccb2vt7W.s:2579   .text:00000000000018a9 .LFB17
     /tmp/ccb2vt7W.s:2666   .text:000000000000199d .L190
     /tmp/ccb2vt7W.s:2690   .text:00000000000019f3 .L191
     /tmp/ccb2vt7W.s:2752   .text:0000000000001aa5 .L189
     /tmp/ccb2vt7W.s:2946   .text:0000000000001cda .L208
     /tmp/ccb2vt7W.s:2639   .text:0000000000001944 .L194
     /tmp/ccb2vt7W.s:2949   .text:0000000000001cdb .L195
     /tmp/ccb2vt7W.s:2745   .text:0000000000001aa1 .L209
     /tmp/ccb2vt7W.s:2749   .text:0000000000001aa4 .L210
     /tmp/ccb2vt7W.s:2716   .text:0000000000001a3d .L198
     /tmp/ccb2vt7W.s:2711   .text:0000000000001a31 .L199
     /tmp/ccb2vt7W.s:2858   .text:0000000000001be3 .L202
     /tmp/ccb2vt7W.s:2777   .text:0000000000001af3 .L203
     /tmp/ccb2vt7W.s:2809   .text:0000000000001b55 .L205
     /tmp/ccb2vt7W.s:2877   .text:0000000000001c1b .L206
     /tmp/ccb2vt7W.s:2905   .text:0000000000001c68 .L207
     /tmp/ccb2vt7W.s:2971   .text:0000000000001d07 .LFE17
     /tmp/ccb2vt7W.s:2975   .text:0000000000001d07 InitializeGuest
     /tmp/ccb2vt7W.s:2976   .text:0000000000001d07 .LFB18
     /tmp/ccb2vt7W.s:3143   .text:000000000000201b .LFE18
     /tmp/ccb2vt7W.s:3147   .text:000000000000201b SetIOIOPort
     /tmp/ccb2vt7W.s:3148   .text:000000000000201b .LFB19
     /tmp/ccb2vt7W.s:3243   .text:00000000000020ba .LFE19
     /tmp/ccb2vt7W.s:3247   .text:00000000000020ba GetIOIOPort
     /tmp/ccb2vt7W.s:3248   .text:00000000000020ba .LFB20
     /tmp/ccb2vt7W.s:3314   .text:000000000000211b .LFE20
     /tmp/ccb2vt7W.s:3319   .text:000000000000211b .LFB21
     /tmp/ccb2vt7W.s:3358   .text:0000000000002194 .L218
     /tmp/ccb2vt7W.s:3361   .text:0000000000002195 .L215
     /tmp/ccb2vt7W.s:3368   .text:0000000000002197 .LFE21
     /tmp/ccb2vt7W.s:3372   .text:0000000000002197 HandleGuestCPUID
     /tmp/ccb2vt7W.s:3373   .text:0000000000002197 .LFB22
     /tmp/ccb2vt7W.s:3411   .text:00000000000021ba .LFE22
     /tmp/ccb2vt7W.s:3413   .text:00000000000021ba .Letext0
     /tmp/ccb2vt7W.s:3422   .debug_info:0000000000000000 .Ldebug_info0
     /tmp/ccb2vt7W.s:5622   .debug_abbrev:0000000000000000 .Ldebug_abbrev0
     /tmp/ccb2vt7W.s:6668   .debug_str:00000000000005ab .LASF207
     /tmp/ccb2vt7W.s:6400   .debug_str:0000000000000063 .LASF208
     /tmp/ccb2vt7W.s:6542   .debug_str:000000000000031d .LASF209
     /tmp/ccb2vt7W.s:6382   .debug_line:0000000000000000 .Ldebug_line0
     /tmp/ccb2vt7W.s:6626   .debug_str:00000000000004e1 .LASF0
     /tmp/ccb2vt7W.s:6758   .debug_str:00000000000007f0 .LASF2
     /tmp/ccb2vt7W.s:6634   .debug_str:0000000000000503 .LASF1
     /tmp/ccb2vt7W.s:6784   .debug_str:000000000000088d .LASF3
     /tmp/ccb2vt7W.s:6490   .debug_str:000000000000023c .LASF4
     /tmp/ccb2vt7W.s:6736   .debug_str:0000000000000762 .LASF5
     /tmp/ccb2vt7W.s:6494   .debug_str:000000000000024c .LASF6
     /tmp/ccb2vt7W.s:6782   .debug_str:0000000000000881 .LASF7
     /tmp/ccb2vt7W.s:6678   .debug_str:0000000000000628 .LASF8
     /tmp/ccb2vt7W.s:6544   .debug_str:0000000000000341 .LASF9
     /tmp/ccb2vt7W.s:6602   .debug_str:0000000000000458 .LASF10
     /tmp/ccb2vt7W.s:6414   .debug_str:00000000000000bc .LASF11
     /tmp/ccb2vt7W.s:6616   .debug_str:000000000000049d .LASF12
     /tmp/ccb2vt7W.s:6672   .debug_str:000000000000060d .LASF13
     /tmp/ccb2vt7W.s:6594   .debug_str:0000000000000434 .LASF14
     /tmp/ccb2vt7W.s:6656   .debug_str:0000000000000576 .LASF15
     /tmp/ccb2vt7W.s:6460   .debug_str:00000000000001b9 .LASF16
     /tmp/ccb2vt7W.s:6700   .debug_str:0000000000000697 .LASF17
     /tmp/ccb2vt7W.s:6754   .debug_str:00000000000007e1 .LASF18
     /tmp/ccb2vt7W.s:6436   .debug_str:0000000000000146 .LASF19
     /tmp/ccb2vt7W.s:6682   .debug_str:000000000000063d .LASF20
     /tmp/ccb2vt7W.s:6562   .debug_str:0000000000000386 .LASF21
     /tmp/ccb2vt7W.s:6598   .debug_str:0000000000000447 .LASF22
     /tmp/ccb2vt7W.s:6622   .debug_str:00000000000004be .LASF23
     /tmp/ccb2vt7W.s:6582   .debug_str:00000000000003f1 .LASF47
     /tmp/ccb2vt7W.s:6514   .debug_str:00000000000002a2 .LASF24
     /tmp/ccb2vt7W.s:6434   .debug_str:0000000000000140 .LASF25
     /tmp/ccb2vt7W.s:6482   .debug_str:000000000000020a .LASF26
     /tmp/ccb2vt7W.s:6502   .debug_str:000000000000027e .LASF27
     /tmp/ccb2vt7W.s:6408   .debug_str:0000000000000095 .LASF28
     /tmp/ccb2vt7W.s:6492   .debug_str:0000000000000242 .LASF29
     /tmp/ccb2vt7W.s:6630   .debug_str:00000000000004eb .LASF30
     /tmp/ccb2vt7W.s:6768   .debug_str:0000000000000844 .LASF31
     /tmp/ccb2vt7W.s:6584   .debug_str:00000000000003fd .LASF32
     /tmp/ccb2vt7W.s:6538   .debug_str:000000000000030b .LASF33
     /tmp/ccb2vt7W.s:6770   .debug_str:000000000000084a .LASF34
     /tmp/ccb2vt7W.s:6704   .debug_str:00000000000006a9 .LASF35
     /tmp/ccb2vt7W.s:6772   .debug_str:0000000000000850 .LASF36
     /tmp/ccb2vt7W.s:6774   .debug_str:0000000000000856 .LASF37
     /tmp/ccb2vt7W.s:6394   .debug_str:0000000000000040 .LASF38
     /tmp/ccb2vt7W.s:6660   .debug_str:000000000000058a .LASF39
     /tmp/ccb2vt7W.s:6606   .debug_str:000000000000046c .LASF40
     /tmp/ccb2vt7W.s:6646   .debug_str:000000000000053f .LASF41
     /tmp/ccb2vt7W.s:6662   .debug_str:000000000000058f .LASF42
     /tmp/ccb2vt7W.s:6744   .debug_str:00000000000007a3 .LASF43
     /tmp/ccb2vt7W.s:6760   .debug_str:00000000000007fe .LASF44
     /tmp/ccb2vt7W.s:6528   .debug_str:00000000000002ec .LASF45
     /tmp/ccb2vt7W.s:6676   .debug_str:000000000000061e .LASF46
     /tmp/ccb2vt7W.s:6448   .debug_str:0000000000000185 .LASF48
     /tmp/ccb2vt7W.s:6688   .debug_str:0000000000000665 .LASF49
     /tmp/ccb2vt7W.s:6430   .debug_str:0000000000000126 .LASF50
     /tmp/ccb2vt7W.s:6570   .debug_str:00000000000003b0 .LASF51
     /tmp/ccb2vt7W.s:6638   .debug_str:0000000000000514 .LASF52
     /tmp/ccb2vt7W.s:6388   .debug_str:0000000000000010 .LASF53
     /tmp/ccb2vt7W.s:6456   .debug_str:00000000000001ad .LASF54
     /tmp/ccb2vt7W.s:6458   .debug_str:00000000000001b3 .LASF55
     /tmp/ccb2vt7W.s:6470   .debug_str:00000000000001da .LASF56
     /tmp/ccb2vt7W.s:6462   .debug_str:00000000000001c2 .LASF57
     /tmp/ccb2vt7W.s:6464   .debug_str:00000000000001c8 .LASF58
     /tmp/ccb2vt7W.s:6466   .debug_str:00000000000001ce .LASF59
     /tmp/ccb2vt7W.s:6708   .debug_str:00000000000006c2 .LASF60
     /tmp/ccb2vt7W.s:6748   .debug_str:00000000000007b4 .LASF61
     /tmp/ccb2vt7W.s:6420   .debug_str:00000000000000e7 .LASF62
     /tmp/ccb2vt7W.s:6666   .debug_str:00000000000005a0 .LASF63
     /tmp/ccb2vt7W.s:6636   .debug_str:0000000000000508 .LASF64
     /tmp/ccb2vt7W.s:6468   .debug_str:00000000000001d4 .LASF65
     /tmp/ccb2vt7W.s:6670   .debug_str:0000000000000607 .LASF66
     /tmp/ccb2vt7W.s:6422   .debug_str:00000000000000f2 .LASF67
     /tmp/ccb2vt7W.s:6802   .debug_str:0000000000000901 .LASF68
     /tmp/ccb2vt7W.s:6800   .debug_str:00000000000008f7 .LASF69
     /tmp/ccb2vt7W.s:6556   .debug_str:0000000000000368 .LASF70
     /tmp/ccb2vt7W.s:6710   .debug_str:00000000000006cf .LASF71
     /tmp/ccb2vt7W.s:6428   .debug_str:000000000000011c .LASF72
     /tmp/ccb2vt7W.s:6474   .debug_str:00000000000001e6 .LASF73
     /tmp/ccb2vt7W.s:6642   .debug_str:000000000000052f .LASF74
     /tmp/ccb2vt7W.s:6680   .debug_str:0000000000000632 .LASF75
     /tmp/ccb2vt7W.s:6432   .debug_str:0000000000000134 .LASF76
     /tmp/ccb2vt7W.s:6780   .debug_str:0000000000000876 .LASF77
     /tmp/ccb2vt7W.s:6472   .debug_str:00000000000001e0 .LASF78
     /tmp/ccb2vt7W.s:6486   .debug_str:0000000000000229 .LASF79
     /tmp/ccb2vt7W.s:6536   .debug_str:0000000000000304 .LASF80
     /tmp/ccb2vt7W.s:6574   .debug_str:00000000000003cb .LASF81
     /tmp/ccb2vt7W.s:6512   .debug_str:000000000000029d .LASF82
     /tmp/ccb2vt7W.s:6628   .debug_str:00000000000004e6 .LASF83
     /tmp/ccb2vt7W.s:6504   .debug_str:0000000000000285 .LASF84
     /tmp/ccb2vt7W.s:6506   .debug_str:000000000000028b .LASF85
     /tmp/ccb2vt7W.s:6508   .debug_str:0000000000000291 .LASF86
     /tmp/ccb2vt7W.s:6402   .debug_str:000000000000006b .LASF87
     /tmp/ccb2vt7W.s:6510   .debug_str:0000000000000297 .LASF88
     /tmp/ccb2vt7W.s:6644   .debug_str:0000000000000538 .LASF89
     /tmp/ccb2vt7W.s:6546   .debug_str:0000000000000347 .LASF90
     /tmp/ccb2vt7W.s:6548   .debug_str:000000000000034d .LASF91
     /tmp/ccb2vt7W.s:6530   .debug_str:00000000000002f3 .LASF92
     /tmp/ccb2vt7W.s:6438   .debug_str:000000000000014b .LASF93
     /tmp/ccb2vt7W.s:6524   .debug_str:00000000000002dc .LASF94
     /tmp/ccb2vt7W.s:6640   .debug_str:0000000000000528 .LASF95
     /tmp/ccb2vt7W.s:6488   .debug_str:0000000000000231 .LASF96
     /tmp/ccb2vt7W.s:6664   .debug_str:0000000000000594 .LASF97
     /tmp/ccb2vt7W.s:6586   .debug_str:0000000000000402 .LASF98
     /tmp/ccb2vt7W.s:6446   .debug_str:0000000000000178 .LASF99
     /tmp/ccb2vt7W.s:6692   .debug_str:000000000000067f .LASF100
     /tmp/ccb2vt7W.s:6694   .debug_str:0000000000000685 .LASF101
     /tmp/ccb2vt7W.s:6696   .debug_str:000000000000068b .LASF102
     /tmp/ccb2vt7W.s:6698   .debug_str:0000000000000691 .LASF103
     /tmp/ccb2vt7W.s:6722   .debug_str:0000000000000715 .LASF104
     /tmp/ccb2vt7W.s:6452   .debug_str:0000000000000199 .LASF105
     /tmp/ccb2vt7W.s:6730   .debug_str:000000000000073e .LASF106
     /tmp/ccb2vt7W.s:6738   .debug_str:0000000000000774 .LASF107
     /tmp/ccb2vt7W.s:6728   .debug_str:0000000000000730 .LASF108
     /tmp/ccb2vt7W.s:6706   .debug_str:00000000000006b6 .LASF109
     /tmp/ccb2vt7W.s:6516   .debug_str:00000000000002a7 .LASF110
     /tmp/ccb2vt7W.s:6734   .debug_str:0000000000000759 .LASF111
     /tmp/ccb2vt7W.s:6658   .debug_str:000000000000057f .LASF112
     /tmp/ccb2vt7W.s:6476   .debug_str:00000000000001ec .LASF113
     /tmp/ccb2vt7W.s:6786   .debug_str:00000000000008a0 .LASF114
     /tmp/ccb2vt7W.s:6558   .debug_str:0000000000000372 .LASF115
     /tmp/ccb2vt7W.s:6752   .debug_str:00000000000007d2 .LASF116
     /tmp/ccb2vt7W.s:6796   .debug_str:00000000000008e1 .LASF117
     /tmp/ccb2vt7W.s:6540   .debug_str:0000000000000313 .LASF118
     /tmp/ccb2vt7W.s:6684   .debug_str:0000000000000642 .LASF119
     /tmp/ccb2vt7W.s:6480   .debug_str:0000000000000201 .LASF120
     /tmp/ccb2vt7W.s:6650   .debug_str:0000000000000551 .LASF121
     /tmp/ccb2vt7W.s:6790   .debug_str:00000000000008c5 .LASF122
     /tmp/ccb2vt7W.s:6444   .debug_str:0000000000000168 .LASF123
     /tmp/ccb2vt7W.s:6724   .debug_str:000000000000071b .LASF124
     /tmp/ccb2vt7W.s:6426   .debug_str:0000000000000114 .LASF125
     /tmp/ccb2vt7W.s:6618   .debug_str:00000000000004ab .LASF126
     /tmp/ccb2vt7W.s:6794   .debug_str:00000000000008d5 .LASF127
     /tmp/ccb2vt7W.s:6566   .debug_str:00000000000003a6 .LASF128
     /tmp/ccb2vt7W.s:6762   .debug_str:000000000000080a .LASF129
     /tmp/ccb2vt7W.s:6648   .debug_str:0000000000000544 .LASF130
     /tmp/ccb2vt7W.s:6764   .debug_str:000000000000081f .LASF131
     /tmp/ccb2vt7W.s:6416   .debug_str:00000000000000c9 .LASF132
     /tmp/ccb2vt7W.s:6776   .debug_str:000000000000085c .LASF133
     /tmp/ccb2vt7W.s:6518   .debug_str:00000000000002ad .LASF134
     /tmp/ccb2vt7W.s:6550   .debug_str:0000000000000353 .LASF135
     /tmp/ccb2vt7W.s:6580   .debug_str:00000000000003e5 .LASF136
     /tmp/ccb2vt7W.s:6804   .debug_str:000000000000090a .LASF137
     /tmp/ccb2vt7W.s:6652   .debug_str:000000000000055b .LASF138
     /tmp/ccb2vt7W.s:6534   .debug_str:00000000000002fe .LASF139
     /tmp/ccb2vt7W.s:6572   .debug_str:00000000000003c5 .LASF140
     /tmp/ccb2vt7W.s:6412   .debug_str:00000000000000b6 .LASF141
     /tmp/ccb2vt7W.s:6498   .debug_str:000000000000026f .LASF142
     /tmp/ccb2vt7W.s:6440   .debug_str:0000000000000151 .LASF143
     /tmp/ccb2vt7W.s:6560   .debug_str:000000000000037d .LASF144
     /tmp/ccb2vt7W.s:6520   .debug_str:00000000000002b9 .LASF210
     /tmp/ccb2vt7W.s:6398   .debug_str:0000000000000052 .LASF158
     /tmp/ccb2vt7W.s:6578   .debug_str:00000000000003df .LASF147
     /tmp/ccb2vt7W.s:6654   .debug_str:0000000000000561 .LASF161
     /tmp/ccb2vt7W.s:6792   .debug_str:00000000000008cf .LASF145
     /tmp/ccb2vt7W.s:6716   .debug_str:00000000000006f4 .LASF146
     /tmp/ccb2vt7W.s:6718   .debug_str:00000000000006f9 .LASF155
     /tmp/ccb2vt7W.s:6702   .debug_str:00000000000006a0 .LASF148
     /tmp/ccb2vt7W.s:6576   .debug_str:00000000000003d0 .LASF149
     /tmp/ccb2vt7W.s:6454   .debug_str:00000000000001a5 .LASF150
     /tmp/ccb2vt7W.s:6712   .debug_str:00000000000006db .LASF151
     /tmp/ccb2vt7W.s:6806   .debug_str:0000000000000911 .LASF152
     /tmp/ccb2vt7W.s:6526   .debug_str:00000000000002e2 .LASF153
     /tmp/ccb2vt7W.s:6386   .debug_str:0000000000000008 .LASF154
     /tmp/ccb2vt7W.s:6590   .debug_str:0000000000000415 .LASF156
     /tmp/ccb2vt7W.s:6756   .debug_str:00000000000007e6 .LASF157
     /tmp/ccb2vt7W.s:6766   .debug_str:000000000000082c .LASF159
     /tmp/ccb2vt7W.s:6410   .debug_str:000000000000009c .LASF160
     /tmp/ccb2vt7W.s:6404   .debug_str:0000000000000070 .LASF162
     /tmp/ccb2vt7W.s:6788   .debug_str:00000000000008aa .LASF163
     /tmp/ccb2vt7W.s:6554   .debug_str:0000000000000361 .LASF164
     /tmp/ccb2vt7W.s:6392   .debug_str:0000000000000039 .LASF165
     /tmp/ccb2vt7W.s:6396   .debug_str:0000000000000048 .LASF166
     /tmp/ccb2vt7W.s:6686   .debug_str:000000000000064f .LASF176
     /tmp/ccb2vt7W.s:6608   .debug_str:0000000000000471 .LASF167
     /tmp/ccb2vt7W.s:6406   .debug_str:0000000000000090 .LASF168
     /tmp/ccb2vt7W.s:6496   .debug_str:0000000000000263 .LASF169
     /tmp/ccb2vt7W.s:6614   .debug_str:0000000000000496 .LASF170
     /tmp/ccb2vt7W.s:6624   .debug_str:00000000000004d3 .LASF171
     /tmp/ccb2vt7W.s:6478   .debug_str:00000000000001f5 .LASF172
     /tmp/ccb2vt7W.s:6732   .debug_str:000000000000074f .LASF173
     /tmp/ccb2vt7W.s:6532   .debug_str:00000000000002f8 .LASF174
     /tmp/ccb2vt7W.s:6592   .debug_str:0000000000000428 .LASF175
     /tmp/ccb2vt7W.s:6778   .debug_str:0000000000000867 .LASF177
     /tmp/ccb2vt7W.s:6604   .debug_str:000000000000045e .LASF178
     /tmp/ccb2vt7W.s:6484   .debug_str:000000000000020f .LASF179
     /tmp/ccb2vt7W.s:6390   .debug_str:0000000000000024 .LASF180
     /tmp/ccb2vt7W.s:6564   .debug_str:000000000000038c .LASF181
     /tmp/ccb2vt7W.s:6714   .debug_str:00000000000006e6 .LASF182
     /tmp/ccb2vt7W.s:6600   .debug_str:000000000000044e .LASF211
     /tmp/ccb2vt7W.s:6750   .debug_str:00000000000007c2 .LASF183
     /tmp/ccb2vt7W.s:6690   .debug_str:0000000000000673 .LASF184
     /tmp/ccb2vt7W.s:6450   .debug_str:0000000000000191 .LASF185
     /tmp/ccb2vt7W.s:6552   .debug_str:0000000000000359 .LASF186
     /tmp/ccb2vt7W.s:6610   .debug_str:0000000000000480 .LASF187
     /tmp/ccb2vt7W.s:6500   .debug_str:0000000000000275 .LASF188
     /tmp/ccb2vt7W.s:6746   .debug_str:00000000000007a8 .LASF189
     /tmp/ccb2vt7W.s:6522   .debug_str:00000000000002c1 .LASF190
     /tmp/ccb2vt7W.s:6632   .debug_str:00000000000004f6 .LASF191
     /tmp/ccb2vt7W.s:6442   .debug_str:000000000000015a .LASF192
     /tmp/ccb2vt7W.s:6424   .debug_str:0000000000000103 .LASF193
     /tmp/ccb2vt7W.s:6568   .debug_str:00000000000003ab .LASF194
     /tmp/ccb2vt7W.s:6596   .debug_str:0000000000000439 .LASF195
     /tmp/ccb2vt7W.s:6418   .debug_str:00000000000000d6 .LASF196
     /tmp/ccb2vt7W.s:6742   .debug_str:0000000000000791 .LASF197
     /tmp/ccb2vt7W.s:6384   .debug_str:0000000000000000 .LASF198
     /tmp/ccb2vt7W.s:6620   .debug_str:00000000000004b6 .LASF199
     /tmp/ccb2vt7W.s:6588   .debug_str:000000000000040f .LASF200
     /tmp/ccb2vt7W.s:6726   .debug_str:000000000000072a .LASF201
     /tmp/ccb2vt7W.s:6612   .debug_str:0000000000000487 .LASF202
     /tmp/ccb2vt7W.s:6720   .debug_str:000000000000070b .LASF203
     /tmp/ccb2vt7W.s:6798   .debug_str:00000000000008eb .LASF204
     /tmp/ccb2vt7W.s:6674   .debug_str:0000000000000613 .LASF205
     /tmp/ccb2vt7W.s:6740   .debug_str:0000000000000783 .LASF206

UNDEFINED SYMBOLS
GetMemD
GetMemW
GetMemB
inb
outb
   1              		.file	"host.c"
   2              		.intel_syntax noprefix
   3              		.text
   4              	.Ltext0:
   5              		.comm	guest,28,4
   6              		.comm	GuestRegisters,56,32
   7              		.comm	_exception_number,2,2
   8              		.comm	_exc_CS,2,2
   9              		.comm	_exc_IP,2,2
  10              		.comm	vhost,68,32
  11              		.comm	lTempDest,4,4
  12              		.comm	lTempSource,4,4
  13              		.comm	HostRegisters,56,32
  14              		.globl	HostExceptMsg
  15              		.data
  16              		.align 32
  19              	HostExceptMsg:
  20 0000 496E2068 		.string	"In host exception handler for err:                "
  20      6F737420 
  20      65786365 
  20      7074696F 
  20      6E206861 
  21 0033 00       		.string	""
  22              		.comm	HostTimerTicks,8,8
  23              		.comm	HostScancode,1,1
  24              		.comm	VMCBFinalAddress,4,4
  25              		.globl	gInterceptCode
  26              		.bss
  27              		.align 4
  30              	gInterceptCode:
  31 0000 00000000 		.zero	4
  32              		.globl	InterceptCount
  33 0004 00000000 		.align 8
  36              	InterceptCount:
  37 0008 00000000 		.zero	8
  37      00000000 
  38              		.section	.rodata
  39              	.LC0:
  40 0000 20202020 		.string	"                         "
  40      20202020 
  40      20202020 
  40      20202020 
  40      20202020 
  41              	.LC1:
  42 001a 3A00     		.string	":"
  43              		.text
  44              		.globl	host_isr_handler
  46              	host_isr_handler:
  47              	.LFB0:
  48              		.file 1 "host.c"
   1:host.c        **** #include "host.h"
   2:host.c        **** #include "stdio.h"
   3:host.c        **** #include "utility.h"
   4:host.c        **** 
   5:host.c        **** DWORD lTempDest, lTempSource;
   6:host.c        **** DWORD HostRegisters[14];
   7:host.c        **** extern DWORD GuestRegisters[14];
   8:host.c        **** char HostExceptMsg[] = "In host exception handler for err:                \0";  //blank is at 35
   9:host.c        **** QWORD HostTimerTicks;
  10:host.c        **** char HostScancode;
  11:host.c        **** extern struct visor_guest guest;
  12:host.c        **** DWORD VMCBFinalAddress;
  13:host.c        **** DWORD gInterceptCode = 0;
  14:host.c        **** QWORD InterceptCount = 0;
  15:host.c        **** 
  16:host.c        **** void InfiniteLoop(int InterceptCode);
  17:host.c        **** 
  18:host.c        **** /*
  19:host.c        **** BYTE GetVMCBB(DWORD Offset)
  20:host.c        **** {
  21:host.c        **** 	return GetMemB(VMCB_FINAL_ADDRESS + Offset,false);
  22:host.c        **** }
  23:host.c        **** 
  24:host.c        **** WORD GetVMCBW(DWORD Offset)
  25:host.c        **** {
  26:host.c        **** 	return GetMemW(VMCB_FINAL_ADDRESS + Offset, false);
  27:host.c        **** }
  28:host.c        **** 
  29:host.c        **** DWORD GetVMCBD(DWORD Offset)
  30:host.c        **** {
  31:host.c        **** 	return GetMemD(VMCB_FINAL_ADDRESS + Offset, false);
  32:host.c        **** }
  33:host.c        **** 
  34:host.c        **** void SetVMCBB(DWORD Offset, BYTE Value)
  35:host.c        **** {
  36:host.c        **** 	SetMemB(VMCB_FINAL_ADDRESS + Offset, Value, false);
  37:host.c        **** }
  38:host.c        **** 
  39:host.c        **** void SetVMCBW(DWORD Offset, WORD Value)
  40:host.c        **** {
  41:host.c        **** 	SetMemW(VMCB_FINAL_ADDRESS + Offset, Value, false);
  42:host.c        **** }
  43:host.c        **** 
  44:host.c        **** void SetVMCBD(DWORD Offset, DWORD Value)
  45:host.c        **** {
  46:host.c        **** 	SetMemD(VMCB_FINAL_ADDRESS + Offset, Value, false);
  47:host.c        **** }
  48:host.c        **** */
  49:host.c        **** 
  50:host.c        **** void host_isr_handler (WORD exc_no, WORD cs, DWORD ip, WORD error) 
  51:host.c        **** {
  49              		.loc 1 51 0
  50              		.cfi_startproc
  51 0000 55       		push	ebp
  52              		.cfi_def_cfa_offset 8
  53              		.cfi_offset 5, -8
  54 0001 89E5     		mov	ebp, esp
  55              		.cfi_def_cfa_register 5
  56 0003 83EC28   		sub	esp, 40
  57 0006 8B4D08   		mov	ecx, DWORD PTR [ebp+8]
  58 0009 8B550C   		mov	edx, DWORD PTR [ebp+12]
  59 000c 8B4514   		mov	eax, DWORD PTR [ebp+20]
  60 000f 66894DE4 		mov	WORD PTR [ebp-28], cx
  61 0013 668955E0 		mov	WORD PTR [ebp-32], dx
  62 0017 668945DC 		mov	WORD PTR [ebp-36], ax
  52:host.c        ****     
  53:host.c        ****     if (_exception_number == 1)
  63              		.loc 1 53 0
  64 001b 0FB70500 		movzx	eax, WORD PTR _exception_number
  64      000000
  65 0022 6683F801 		cmp	ax, 1
  66 0026 0F849F02 		je	.L42
  66      0000
  54:host.c        ****         return;
  55:host.c        **** 	char* pErr = "                         ";
  67              		.loc 1 55 0
  68 002c C745F400 		mov	DWORD PTR [ebp-12], OFFSET FLAT:.LC0
  68      000000
  56:host.c        **** 	asm("cli\n");
  69              		.loc 1 56 0
  70              	#APP
  71              	# 56 "host.c" 1
  57              		switch (exc_no)
  58              		{
  57:host.c        **** 	{
  72              		cli
  73              	
  74              	# 0 "" 2
  75              		.loc 1 57 0
  76              	#NO_APP
  77 0034 0FB745E4 		movzx	eax, WORD PTR [ebp-28]
  78 0038 83F821   		cmp	eax, 33
  79 003b 0F87F701 		ja	.L4
  79      0000
  80 0041 8B04851C 		mov	eax, DWORD PTR .L6[0+eax*4]
  80      000000
  81 0048 FFE0     		jmp	eax
  82              		.section	.rodata
  83              		.align 4
  84              		.align 4
  85              	.L6:
  86 001c 4A000000 		.long	.L5
  87 0020 56000000 		.long	.L7
  88 0024 62000000 		.long	.L8
  89 0028 6E000000 		.long	.L9
  90 002c 7A000000 		.long	.L10
  91 0030 86000000 		.long	.L11
  92 0034 92000000 		.long	.L12
  93 0038 9E000000 		.long	.L13
  94 003c AA000000 		.long	.L14
  95 0040 B6000000 		.long	.L15
  96 0044 C2000000 		.long	.L16
  97 0048 CE000000 		.long	.L17
  98 004c DA000000 		.long	.L18
  99 0050 E6000000 		.long	.L19
 100 0054 F2000000 		.long	.L20
 101 0058 FE000000 		.long	.L21
 102 005c 0A010000 		.long	.L22
 103 0060 1D010000 		.long	.L23
 104 0064 30010000 		.long	.L24
 105 0068 43010000 		.long	.L25
 106 006c 56010000 		.long	.L26
 107 0070 69010000 		.long	.L27
 108 0074 7C010000 		.long	.L28
 109 0078 8F010000 		.long	.L29
 110 007c A2010000 		.long	.L30
 111 0080 B5010000 		.long	.L31
 112 0084 C8010000 		.long	.L32
 113 0088 D8010000 		.long	.L33
 114 008c E8010000 		.long	.L34
 115 0090 F8010000 		.long	.L35
 116 0094 08020000 		.long	.L36
 117 0098 18020000 		.long	.L37
 118 009c 38020000 		.long	.L4
 119 00a0 28020000 		.long	.L38
 120              		.text
 121              	.L5:
  59:host.c        **** 		case 0x0:
  60:host.c        **** 			HostExceptMsg[35] = '0';
 122              		.loc 1 60 0
 123 004a C6052300 		mov	BYTE PTR HostExceptMsg+35, 48
 123      000030
  61:host.c        **** 			break;
 124              		.loc 1 61 0
 125 0051 E9F70100 		jmp	.L39
 125      00
 126              	.L7:
  62:host.c        **** 		case 0x1:
  63:host.c        **** 			HostExceptMsg[35] = '1';
 127              		.loc 1 63 0
 128 0056 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 128      000031
  64:host.c        **** 			break;
 129              		.loc 1 64 0
 130 005d E9EB0100 		jmp	.L39
 130      00
 131              	.L8:
  65:host.c        **** 		case 0x2:
  66:host.c        **** 			HostExceptMsg[35] = '2';
 132              		.loc 1 66 0
 133 0062 C6052300 		mov	BYTE PTR HostExceptMsg+35, 50
 133      000032
  67:host.c        **** 			break;
 134              		.loc 1 67 0
 135 0069 E9DF0100 		jmp	.L39
 135      00
 136              	.L9:
  68:host.c        **** 		case 0x3:
  69:host.c        **** 			HostExceptMsg[35] = '3';
 137              		.loc 1 69 0
 138 006e C6052300 		mov	BYTE PTR HostExceptMsg+35, 51
 138      000033
  70:host.c        **** 			break;
 139              		.loc 1 70 0
 140 0075 E9D30100 		jmp	.L39
 140      00
 141              	.L10:
  71:host.c        **** 		case 0x4:
  72:host.c        **** 			HostExceptMsg[35] = '4';
 142              		.loc 1 72 0
 143 007a C6052300 		mov	BYTE PTR HostExceptMsg+35, 52
 143      000034
  73:host.c        **** 			break;
 144              		.loc 1 73 0
 145 0081 E9C70100 		jmp	.L39
 145      00
 146              	.L11:
  74:host.c        **** 		case 0x5:
  75:host.c        **** 			HostExceptMsg[35] = '5';
 147              		.loc 1 75 0
 148 0086 C6052300 		mov	BYTE PTR HostExceptMsg+35, 53
 148      000035
  76:host.c        **** 			break;
 149              		.loc 1 76 0
 150 008d E9BB0100 		jmp	.L39
 150      00
 151              	.L12:
  77:host.c        **** 		case 0x6:
  78:host.c        **** 			HostExceptMsg[35] = '6';
 152              		.loc 1 78 0
 153 0092 C6052300 		mov	BYTE PTR HostExceptMsg+35, 54
 153      000036
  79:host.c        **** 			break;
 154              		.loc 1 79 0
 155 0099 E9AF0100 		jmp	.L39
 155      00
 156              	.L13:
  80:host.c        **** 		case 0x7:
  81:host.c        **** 			HostExceptMsg[35] = '7';
 157              		.loc 1 81 0
 158 009e C6052300 		mov	BYTE PTR HostExceptMsg+35, 55
 158      000037
  82:host.c        **** 			break;
 159              		.loc 1 82 0
 160 00a5 E9A30100 		jmp	.L39
 160      00
 161              	.L14:
  83:host.c        **** 		case 0x8:
  84:host.c        **** 			HostExceptMsg[35] = '8';
 162              		.loc 1 84 0
 163 00aa C6052300 		mov	BYTE PTR HostExceptMsg+35, 56
 163      000038
  85:host.c        **** 			break;
 164              		.loc 1 85 0
 165 00b1 E9970100 		jmp	.L39
 165      00
 166              	.L15:
  86:host.c        **** 		case 0x9:
  87:host.c        **** 			HostExceptMsg[35] = '9';
 167              		.loc 1 87 0
 168 00b6 C6052300 		mov	BYTE PTR HostExceptMsg+35, 57
 168      000039
  88:host.c        **** 			break;
 169              		.loc 1 88 0
 170 00bd E98B0100 		jmp	.L39
 170      00
 171              	.L16:
  89:host.c        **** 		case 0xa:
  90:host.c        **** 			HostExceptMsg[35] = 'A';
 172              		.loc 1 90 0
 173 00c2 C6052300 		mov	BYTE PTR HostExceptMsg+35, 65
 173      000041
  91:host.c        **** 			break;
 174              		.loc 1 91 0
 175 00c9 E97F0100 		jmp	.L39
 175      00
 176              	.L17:
  92:host.c        **** 		case 0xb:
  93:host.c        **** 			HostExceptMsg[35] = 'B';
 177              		.loc 1 93 0
 178 00ce C6052300 		mov	BYTE PTR HostExceptMsg+35, 66
 178      000042
  94:host.c        **** 			break;
 179              		.loc 1 94 0
 180 00d5 E9730100 		jmp	.L39
 180      00
 181              	.L18:
  95:host.c        **** 		case 0xc:
  96:host.c        **** 			HostExceptMsg[35] = 'C';
 182              		.loc 1 96 0
 183 00da C6052300 		mov	BYTE PTR HostExceptMsg+35, 67
 183      000043
  97:host.c        **** 			break;
 184              		.loc 1 97 0
 185 00e1 E9670100 		jmp	.L39
 185      00
 186              	.L19:
  98:host.c        **** 		case 0xd:
  99:host.c        **** 			HostExceptMsg[35] = 'D';
 187              		.loc 1 99 0
 188 00e6 C6052300 		mov	BYTE PTR HostExceptMsg+35, 68
 188      000044
 100:host.c        **** 			break;
 189              		.loc 1 100 0
 190 00ed E95B0100 		jmp	.L39
 190      00
 191              	.L20:
 101:host.c        **** 		case 0xe:
 102:host.c        **** 			HostExceptMsg[35] = 'E';
 192              		.loc 1 102 0
 193 00f2 C6052300 		mov	BYTE PTR HostExceptMsg+35, 69
 193      000045
 103:host.c        **** 			break;
 194              		.loc 1 103 0
 195 00f9 E94F0100 		jmp	.L39
 195      00
 196              	.L21:
 104:host.c        **** 		case 0xf:
 105:host.c        **** 			HostExceptMsg[35] = 'F';
 197              		.loc 1 105 0
 198 00fe C6052300 		mov	BYTE PTR HostExceptMsg+35, 70
 198      000046
 106:host.c        **** 			break;
 199              		.loc 1 106 0
 200 0105 E9430100 		jmp	.L39
 200      00
 201              	.L22:
 107:host.c        **** 		case 0x10:
 108:host.c        **** 			HostExceptMsg[35] = '1';
 202              		.loc 1 108 0
 203 010a C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 203      000031
 109:host.c        **** 			HostExceptMsg[36] = '0';
 204              		.loc 1 109 0
 205 0111 C6052400 		mov	BYTE PTR HostExceptMsg+36, 48
 205      000030
 110:host.c        **** 			break;
 206              		.loc 1 110 0
 207 0118 E9300100 		jmp	.L39
 207      00
 208              	.L23:
 111:host.c        **** 		case 0x11:
 112:host.c        **** 			HostExceptMsg[35] = '1';
 209              		.loc 1 112 0
 210 011d C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 210      000031
 113:host.c        **** 			HostExceptMsg[36] = '1';
 211              		.loc 1 113 0
 212 0124 C6052400 		mov	BYTE PTR HostExceptMsg+36, 49
 212      000031
 114:host.c        **** 			break;
 213              		.loc 1 114 0
 214 012b E91D0100 		jmp	.L39
 214      00
 215              	.L24:
 115:host.c        **** 		case 0x12:
 116:host.c        **** 			HostExceptMsg[35] = '1';
 216              		.loc 1 116 0
 217 0130 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 217      000031
 117:host.c        **** 			HostExceptMsg[36] = '2';
 218              		.loc 1 117 0
 219 0137 C6052400 		mov	BYTE PTR HostExceptMsg+36, 50
 219      000032
 118:host.c        **** 			break;
 220              		.loc 1 118 0
 221 013e E90A0100 		jmp	.L39
 221      00
 222              	.L25:
 119:host.c        **** 		case 0x13:
 120:host.c        **** 			HostExceptMsg[35] = '1';
 223              		.loc 1 120 0
 224 0143 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 224      000031
 121:host.c        **** 			HostExceptMsg[36] = '3';
 225              		.loc 1 121 0
 226 014a C6052400 		mov	BYTE PTR HostExceptMsg+36, 51
 226      000033
 122:host.c        **** 			break;
 227              		.loc 1 122 0
 228 0151 E9F70000 		jmp	.L39
 228      00
 229              	.L26:
 123:host.c        **** 		case 0x14:
 124:host.c        **** 			HostExceptMsg[35] = '1';
 230              		.loc 1 124 0
 231 0156 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 231      000031
 125:host.c        **** 			HostExceptMsg[36] = '4';
 232              		.loc 1 125 0
 233 015d C6052400 		mov	BYTE PTR HostExceptMsg+36, 52
 233      000034
 126:host.c        **** 			break;
 234              		.loc 1 126 0
 235 0164 E9E40000 		jmp	.L39
 235      00
 236              	.L27:
 127:host.c        **** 		case 0x15:
 128:host.c        **** 			HostExceptMsg[35] = '1';
 237              		.loc 1 128 0
 238 0169 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 238      000031
 129:host.c        **** 			HostExceptMsg[36] = '5';
 239              		.loc 1 129 0
 240 0170 C6052400 		mov	BYTE PTR HostExceptMsg+36, 53
 240      000035
 130:host.c        **** 			break;
 241              		.loc 1 130 0
 242 0177 E9D10000 		jmp	.L39
 242      00
 243              	.L28:
 131:host.c        **** 		case 0x16:
 132:host.c        **** 			HostExceptMsg[35] = '1';
 244              		.loc 1 132 0
 245 017c C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 245      000031
 133:host.c        **** 			HostExceptMsg[36] = '6';
 246              		.loc 1 133 0
 247 0183 C6052400 		mov	BYTE PTR HostExceptMsg+36, 54
 247      000036
 134:host.c        **** 			break;
 248              		.loc 1 134 0
 249 018a E9BE0000 		jmp	.L39
 249      00
 250              	.L29:
 135:host.c        **** 		case 0x17:
 136:host.c        **** 			HostExceptMsg[35] = '1';
 251              		.loc 1 136 0
 252 018f C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 252      000031
 137:host.c        **** 			HostExceptMsg[36] = '7';
 253              		.loc 1 137 0
 254 0196 C6052400 		mov	BYTE PTR HostExceptMsg+36, 55
 254      000037
 138:host.c        **** 			break;
 255              		.loc 1 138 0
 256 019d E9AB0000 		jmp	.L39
 256      00
 257              	.L30:
 139:host.c        **** 		case 0x18:
 140:host.c        **** 			HostExceptMsg[35] = '1';
 258              		.loc 1 140 0
 259 01a2 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 259      000031
 141:host.c        **** 			HostExceptMsg[36] = '8';
 260              		.loc 1 141 0
 261 01a9 C6052400 		mov	BYTE PTR HostExceptMsg+36, 56
 261      000038
 142:host.c        **** 			break;
 262              		.loc 1 142 0
 263 01b0 E9980000 		jmp	.L39
 263      00
 264              	.L31:
 143:host.c        **** 		case 0x19:
 144:host.c        **** 			HostExceptMsg[35] = '1';
 265              		.loc 1 144 0
 266 01b5 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 266      000031
 145:host.c        **** 			HostExceptMsg[36] = '9';
 267              		.loc 1 145 0
 268 01bc C6052400 		mov	BYTE PTR HostExceptMsg+36, 57
 268      000039
 146:host.c        **** 			break;
 269              		.loc 1 146 0
 270 01c3 E9850000 		jmp	.L39
 270      00
 271              	.L32:
 147:host.c        **** 		case 0x1a:
 148:host.c        **** 			HostExceptMsg[35] = '1';
 272              		.loc 1 148 0
 273 01c8 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 273      000031
 149:host.c        **** 			HostExceptMsg[36] = 'A';
 274              		.loc 1 149 0
 275 01cf C6052400 		mov	BYTE PTR HostExceptMsg+36, 65
 275      000041
 150:host.c        **** 			break;
 276              		.loc 1 150 0
 277 01d6 EB75     		jmp	.L39
 278              	.L33:
 151:host.c        **** 		case 0x1b:
 152:host.c        **** 			HostExceptMsg[35] = '1';
 279              		.loc 1 152 0
 280 01d8 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 280      000031
 153:host.c        **** 			HostExceptMsg[36] = 'B';
 281              		.loc 1 153 0
 282 01df C6052400 		mov	BYTE PTR HostExceptMsg+36, 66
 282      000042
 154:host.c        **** 			break;
 283              		.loc 1 154 0
 284 01e6 EB65     		jmp	.L39
 285              	.L34:
 155:host.c        **** 		case 0x1c:
 156:host.c        **** 			HostExceptMsg[35] = '1';
 286              		.loc 1 156 0
 287 01e8 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 287      000031
 157:host.c        **** 			HostExceptMsg[36] = 'C';
 288              		.loc 1 157 0
 289 01ef C6052400 		mov	BYTE PTR HostExceptMsg+36, 67
 289      000043
 158:host.c        **** 			break;
 290              		.loc 1 158 0
 291 01f6 EB55     		jmp	.L39
 292              	.L35:
 159:host.c        **** 		case 0x1d:
 160:host.c        **** 			HostExceptMsg[35] = '1';
 293              		.loc 1 160 0
 294 01f8 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 294      000031
 161:host.c        **** 			HostExceptMsg[36] = 'D';
 295              		.loc 1 161 0
 296 01ff C6052400 		mov	BYTE PTR HostExceptMsg+36, 68
 296      000044
 162:host.c        **** 			break;
 297              		.loc 1 162 0
 298 0206 EB45     		jmp	.L39
 299              	.L36:
 163:host.c        **** 		case 0x1e:
 164:host.c        **** 			HostExceptMsg[35] = '1';
 300              		.loc 1 164 0
 301 0208 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 301      000031
 165:host.c        **** 			HostExceptMsg[36] = 'E';
 302              		.loc 1 165 0
 303 020f C6052400 		mov	BYTE PTR HostExceptMsg+36, 69
 303      000045
 166:host.c        **** 			break;
 304              		.loc 1 166 0
 305 0216 EB35     		jmp	.L39
 306              	.L37:
 167:host.c        **** 		case 0x1f:
 168:host.c        **** 			HostExceptMsg[35] = '1';
 307              		.loc 1 168 0
 308 0218 C6052300 		mov	BYTE PTR HostExceptMsg+35, 49
 308      000031
 169:host.c        **** 			HostExceptMsg[36] = 'F';
 309              		.loc 1 169 0
 310 021f C6052400 		mov	BYTE PTR HostExceptMsg+36, 70
 310      000046
 170:host.c        **** 			break;
 311              		.loc 1 170 0
 312 0226 EB25     		jmp	.L39
 313              	.L38:
 171:host.c        **** 		case 0x21:
 172:host.c        **** 			HostExceptMsg[35] = '2';
 314              		.loc 1 172 0
 315 0228 C6052300 		mov	BYTE PTR HostExceptMsg+35, 50
 315      000032
 173:host.c        **** 			HostExceptMsg[36] = '1';
 316              		.loc 1 173 0
 317 022f C6052400 		mov	BYTE PTR HostExceptMsg+36, 49
 317      000031
 174:host.c        **** 			break;
 318              		.loc 1 174 0
 319 0236 EB15     		jmp	.L39
 320              	.L4:
 175:host.c        **** 		default:
 176:host.c        **** 			HostExceptMsg[35] = 'E';
 321              		.loc 1 176 0
 322 0238 C6052300 		mov	BYTE PTR HostExceptMsg+35, 69
 322      000045
 177:host.c        **** 			HostExceptMsg[36] = 'R';
 323              		.loc 1 177 0
 324 023f C6052400 		mov	BYTE PTR HostExceptMsg+36, 82
 324      000052
 178:host.c        **** 			HostExceptMsg[37] = 'R';
 325              		.loc 1 178 0
 326 0246 C6052500 		mov	BYTE PTR HostExceptMsg+37, 82
 326      000052
 327              	.L39:
 179:host.c        **** 	}
 180:host.c        **** 	printAt(HostExceptMsg,0,16);
 328              		.loc 1 180 0
 329 024d 83EC04   		sub	esp, 4
 330 0250 6A10     		push	16
 331 0252 6A00     		push	0
 332 0254 68000000 		push	OFFSET FLAT:HostExceptMsg
 332      00
 333 0259 E8FCFFFF 		call	printAt
 333      FF
 334 025e 83C410   		add	esp, 16
 181:host.c        **** 	pErr = Itoa(_exc_CS, pErr, 16);
 335              		.loc 1 181 0
 336 0261 0FB70500 		movzx	eax, WORD PTR _exc_CS
 336      000000
 337 0268 0FB7C0   		movzx	eax, ax
 338 026b 83EC04   		sub	esp, 4
 339 026e 6A10     		push	16
 340 0270 FF75F4   		push	DWORD PTR [ebp-12]
 341 0273 50       		push	eax
 342 0274 E8FCFFFF 		call	Itoa
 342      FF
 343 0279 83C410   		add	esp, 16
 344 027c 8945F4   		mov	DWORD PTR [ebp-12], eax
 182:host.c        **** 	print(pErr);
 345              		.loc 1 182 0
 346 027f 83EC0C   		sub	esp, 12
 347 0282 FF75F4   		push	DWORD PTR [ebp-12]
 348 0285 E8FCFFFF 		call	print
 348      FF
 349 028a 83C410   		add	esp, 16
 183:host.c        **** 	print(":");
 350              		.loc 1 183 0
 351 028d 83EC0C   		sub	esp, 12
 352 0290 681A0000 		push	OFFSET FLAT:.LC1
 352      00
 353 0295 E8FCFFFF 		call	print
 353      FF
 354 029a 83C410   		add	esp, 16
 184:host.c        **** 	pErr = Itoa(_exc_IP, pErr, 16);
 355              		.loc 1 184 0
 356 029d 0FB70500 		movzx	eax, WORD PTR _exc_IP
 356      000000
 357 02a4 0FB7C0   		movzx	eax, ax
 358 02a7 83EC04   		sub	esp, 4
 359 02aa 6A10     		push	16
 360 02ac FF75F4   		push	DWORD PTR [ebp-12]
 361 02af 50       		push	eax
 362 02b0 E8FCFFFF 		call	Itoa
 362      FF
 363 02b5 83C410   		add	esp, 16
 364 02b8 8945F4   		mov	DWORD PTR [ebp-12], eax
 185:host.c        **** 	print(pErr);
 365              		.loc 1 185 0
 366 02bb 83EC0C   		sub	esp, 12
 367 02be FF75F4   		push	DWORD PTR [ebp-12]
 368 02c1 E8FCFFFF 		call	print
 368      FF
 369 02c6 83C410   		add	esp, 16
 370              	.L40:
 186:host.c        **** HostExceptionLoop:	
 187:host.c        **** 	goto HostExceptionLoop;
 371              		.loc 1 187 0 discriminator 1
 372 02c9 EBFE     		jmp	.L40
 373              	.L42:
  54:host.c        **** 	char* pErr = "                         ";
 374              		.loc 1 54 0
 375 02cb 90       		nop
 188:host.c        **** }
 376              		.loc 1 188 0
 377 02cc C9       		leave
 378              		.cfi_restore 5
 379              		.cfi_def_cfa 4, 4
 380 02cd C3       		ret
 381              		.cfi_endproc
 382              	.LFE0:
 384              		.section	.rodata
 385              		.align 4
 386              	.LC2:
 387 00a4 496E2068 		.string	"In host paging handler, error code: "
 387      6F737420 
 387      70616769 
 387      6E672068 
 387      616E646C 
 388              		.text
 389              		.globl	host_paging_handler
 391              	host_paging_handler:
 392              	.LFB1:
 189:host.c        **** 
 190:host.c        **** void host_paging_handler(DWORD errorCode)
 191:host.c        **** {
 393              		.loc 1 191 0
 394              		.cfi_startproc
 395 02ce 55       		push	ebp
 396              		.cfi_def_cfa_offset 8
 397              		.cfi_offset 5, -8
 398 02cf 89E5     		mov	ebp, esp
 399              		.cfi_def_cfa_register 5
 400 02d1 83EC08   		sub	esp, 8
 192:host.c        **** //    char* pErr = "                         ";
 193:host.c        **** //    DWORD lCR2;
 194:host.c        **** //    asm("mov eax,cr2\nmov %[CR2],eax\n" : [CR2] "=r" (lCR2));
 195:host.c        **** //    pErr = Itoa(errorCode, pErr, 16);
 196:host.c        ****     printAt("In host paging handler, error code: ",0,20);
 401              		.loc 1 196 0
 402 02d4 83EC04   		sub	esp, 4
 403 02d7 6A14     		push	20
 404 02d9 6A00     		push	0
 405 02db 68A40000 		push	OFFSET FLAT:.LC2
 405      00
 406 02e0 E8FCFFFF 		call	printAt
 406      FF
 407 02e5 83C410   		add	esp, 16
 408              	.L44:
 197:host.c        **** //    print(pErr);
 198:host.c        **** //    print(" - CR2 = ");
 199:host.c        **** //    pErr = Itoa(lCR2, pErr, 16);
 200:host.c        **** //    print(pErr);
 201:host.c        **** HPH_Loop:
 202:host.c        ****     goto HPH_Loop;
 409              		.loc 1 202 0 discriminator 1
 410 02e8 EBFE     		jmp	.L44
 411              		.cfi_endproc
 412              	.LFE1:
 414              		.globl	timer_handler
 416              	timer_handler:
 417              	.LFB2:
 203:host.c        ****     InfiniteLoop(0x400);
 204:host.c        **** }
 205:host.c        **** 
 206:host.c        **** void timer_handler() {
 418              		.loc 1 206 0
 419              		.cfi_startproc
 420 02ea 55       		push	ebp
 421              		.cfi_def_cfa_offset 8
 422              		.cfi_offset 5, -8
 423 02eb 89E5     		mov	ebp, esp
 424              		.cfi_def_cfa_register 5
 207:host.c        **** 	asm("mov eax, GS:HostTimerTicks\n");
 425              		.loc 1 207 0
 426              	#APP
 427              	# 207 "host.c" 1
 208              		asm("inc eax\n");
 209              		asm("mov GS:HostTimerTicks, eax\n");
 208:host.c        **** 	asm("mov GS:HostTimerTicks, eax\n");
 428              		mov eax, GS:HostTimerTicks
 429              	
 430              	# 0 "" 2
 431              		.loc 1 208 0
 432              	# 208 "host.c" 1
 210              		asm("mov al, 0x20\n");
 209:host.c        **** 	asm("mov al, 0x20\n");
 433              		inc eax
 434              	
 435              	# 0 "" 2
 436              		.loc 1 209 0
 437              	# 209 "host.c" 1
 211              		asm("out 0x20, al\n");
 210:host.c        **** 	asm("out 0x20, al\n");
 438              		mov GS:HostTimerTicks, eax
 439              	
 440              	# 0 "" 2
 441              		.loc 1 210 0
 442              	# 210 "host.c" 1
 212              	}
 211:host.c        **** }
 443              		mov al, 0x20
 444              	
 445              	# 0 "" 2
 446              		.loc 1 211 0
 447              	# 211 "host.c" 1
 213              	
 212:host.c        **** 
 448              		out 0x20, al
 449              	
 450              	# 0 "" 2
 451              		.loc 1 212 0
 452              	#NO_APP
 453 02fe 90       		nop
 454 02ff 5D       		pop	ebp
 455              		.cfi_restore 5
 456              		.cfi_def_cfa 4, 4
 457 0300 C3       		ret
 458              		.cfi_endproc
 459              	.LFE2:
 461              		.globl	kbd_handler
 463              	kbd_handler:
 464              	.LFB3:
 214:host.c        **** void kbd_handler() {
 465              		.loc 1 214 0
 466              		.cfi_startproc
 467 0301 55       		push	ebp
 468              		.cfi_def_cfa_offset 8
 469              		.cfi_offset 5, -8
 470 0302 89E5     		mov	ebp, esp
 471              		.cfi_def_cfa_register 5
 215:host.c        **** 	asm("mov dx, 0x60\n");
 472              		.loc 1 215 0
 473              	#APP
 474              	# 215 "host.c" 1
 216              		asm("inb al, dx\n");
 217              	        asm("cmp al, 0x80\n");
 216:host.c        ****         asm("cmp al, 0x80\n");
 475              		mov dx, 0x60
 476              	
 477              	# 0 "" 2
 478              		.loc 1 216 0
 479              	# 216 "host.c" 1
 218              	        asm("jbe overSaveScanCode\n");
 217:host.c        ****         asm("jbe overSaveScanCode\n");
 480              		inb al, dx
 481              	
 482              	# 0 "" 2
 483              		.loc 1 217 0
 484              	# 217 "host.c" 1
 219              		asm("mov GS:HostScancode, al\n");
 218:host.c        **** 	asm("mov GS:HostScancode, al\n");
 485              		cmp al, 0x80
 486              	
 487              	# 0 "" 2
 488              		.loc 1 218 0
 489              	# 218 "host.c" 1
 220              	        asm("overSaveScanCode:\n");
 219:host.c        ****         asm("overSaveScanCode:\n");
 490              		jbe overSaveScanCode
 491              	
 492              	# 0 "" 2
 493              		.loc 1 219 0
 494              	# 219 "host.c" 1
 221              		asm("mov al, 0x20\n");
 220:host.c        **** 	asm("mov al, 0x20\n");
 495              		mov GS:HostScancode, al
 496              	
 497              	# 0 "" 2
 498              		.loc 1 220 0
 499              	# 220 "host.c" 1
 222              		asm("out 0x20, al\n");
 221:host.c        **** 	asm("out 0x20, al\n");
 500              		overSaveScanCode:
 501              	
 502              	# 0 "" 2
 503              		.loc 1 221 0
 504              	# 221 "host.c" 1
 223              	}
 222:host.c        **** }
 505              		mov al, 0x20
 506              	
 507              	# 0 "" 2
 508              		.loc 1 222 0
 509              	# 222 "host.c" 1
 224              	
 223:host.c        **** 
 510              		out 0x20, al
 511              	
 512              	# 0 "" 2
 513              		.loc 1 223 0
 514              	#NO_APP
 515 0317 90       		nop
 516 0318 5D       		pop	ebp
 517              		.cfi_restore 5
 518              		.cfi_def_cfa 4, 4
 519 0319 C3       		ret
 520              		.cfi_endproc
 521              	.LFE3:
 523              		.globl	setup_IDT_entry
 525              	setup_IDT_entry:
 526              	.LFB4:
 225:host.c        **** void setup_IDT_entry (DESCR_INT *item, WORD selector, DWORD offset, BYTE access, BYTE param_cnt) 
 226:host.c        **** {
 527              		.loc 1 226 0
 528              		.cfi_startproc
 529 031a 55       		push	ebp
 530              		.cfi_def_cfa_offset 8
 531              		.cfi_offset 5, -8
 532 031b 89E5     		mov	ebp, esp
 533              		.cfi_def_cfa_register 5
 534 031d 83EC1C   		sub	esp, 28
 535 0320 8B4D0C   		mov	ecx, DWORD PTR [ebp+12]
 536 0323 8B5514   		mov	edx, DWORD PTR [ebp+20]
 537 0326 8B4518   		mov	eax, DWORD PTR [ebp+24]
 538 0329 66894DEC 		mov	WORD PTR [ebp-20], cx
 539 032d 8855E8   		mov	BYTE PTR [ebp-24], dl
 540 0330 8845E4   		mov	BYTE PTR [ebp-28], al
 227:host.c        **** 	WORD *ptr = (WORD *)item;
 541              		.loc 1 227 0
 542 0333 8B4508   		mov	eax, DWORD PTR [ebp+8]
 543 0336 8945FC   		mov	DWORD PTR [ebp-4], eax
 228:host.c        **** 
 229:host.c        ****   OPEN_UP_DS
 544              		.loc 1 229 0
 545              	#APP
 546              	# 229 "host.c" 1
 230 033a B8100000 	  ptr[0] = (WORD)offset;
 230      00
 231 033f 50       	  ptr[1] = selector;
 232 0340 1F       	  ptr[2] = (access << 8) + 0;
 233 0341 58       	  ptr[3] = (WORD)(offset >> 16);
 234              	  RESTORE_DS
 235              	}
 230:host.c        ****   ptr[1] = selector;
 547              		push eax
 548              	 mov eax, 0x10
 549              	 push eax
 550              	 pop ds
 551              	 pop eax
 552              	
 553              	# 0 "" 2
 554              		.loc 1 230 0
 555              	#NO_APP
 556 0342 8B4510   		mov	eax, DWORD PTR [ebp+16]
 557 0345 89C2     		mov	edx, eax
 558 0347 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 559 034a 668910   		mov	WORD PTR [eax], dx
 231:host.c        ****   ptr[2] = (access << 8) + 0;
 560              		.loc 1 231 0
 561 034d 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 562 0350 8D5002   		lea	edx, [eax+2]
 563 0353 0FB745EC 		movzx	eax, WORD PTR [ebp-20]
 564 0357 668902   		mov	WORD PTR [edx], ax
 232:host.c        ****   ptr[3] = (WORD)(offset >> 16);
 565              		.loc 1 232 0
 566 035a 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 567 035d 83C004   		add	eax, 4
 568 0360 0FB655E8 		movzx	edx, BYTE PTR [ebp-24]
 569 0364 C1E208   		sal	edx, 8
 570 0367 668910   		mov	WORD PTR [eax], dx
 233:host.c        ****   RESTORE_DS
 571              		.loc 1 233 0
 572 036a 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 573 036d 83C006   		add	eax, 6
 574 0370 8B5510   		mov	edx, DWORD PTR [ebp+16]
 575 0373 C1EA10   		shr	edx, 16
 576 0376 668910   		mov	WORD PTR [eax], dx
 234:host.c        **** }
 577              		.loc 1 234 0
 578 0379 B8380000 		mov	eax, 56
 578      00
 579              	#APP
 580              	# 234 "host.c" 1
 236 0381 50       	
 237 0382 1F       	void SetupHostIDT()
 238 0383 58       	{
 239              	    DESCR_INT *item = (DESCR_INT*)(DWORD)(vhost.CodeBase + vhost.IDTOffset);
 240              	
 235:host.c        **** 
 581              		push eax
 582              	 mov eax, eax
 583              	 push eax
 584              	 pop ds
 585              	 pop eax
 586              	
 587              	# 0 "" 2
 588              		.loc 1 235 0
 589              	#NO_APP
 590 0384 90       		nop
 591 0385 C9       		leave
 592              		.cfi_restore 5
 593              		.cfi_def_cfa 4, 4
 594 0386 C3       		ret
 595              		.cfi_endproc
 596              	.LFE4:
 598              		.globl	SetupHostIDT
 600              	SetupHostIDT:
 601              	.LFB5:
 238:host.c        ****     DESCR_INT *item = (DESCR_INT*)(DWORD)(vhost.CodeBase + vhost.IDTOffset);
 602              		.loc 1 238 0
 603              		.cfi_startproc
 604 0387 55       		push	ebp
 605              		.cfi_def_cfa_offset 8
 606              		.cfi_offset 5, -8
 607 0388 89E5     		mov	ebp, esp
 608              		.cfi_def_cfa_register 5
 609 038a 83EC10   		sub	esp, 16
 239:host.c        **** 
 610              		.loc 1 239 0
 611 038d 8B150000 		mov	edx, DWORD PTR vhost
 611      0000
 612 0393 A1100000 		mov	eax, DWORD PTR vhost+16
 612      00
 613 0398 01D0     		add	eax, edx
 614 039a 8945FC   		mov	DWORD PTR [ebp-4], eax
 241:host.c        ****     /* setting up the exception handlers and timer, keyboard ISRs */
 242:host.c        ****     setup_IDT_entry (item+0x00, 0x50, (DWORD)_isr_00_wrapper, ACS_INT, 0);
 615              		.loc 1 242 0
 616 039d B8000000 		mov	eax, OFFSET FLAT:_isr_00_wrapper
 616      00
 617 03a2 6A00     		push	0
 618 03a4 688E0000 		push	142
 618      00
 619 03a9 50       		push	eax
 620 03aa 6A50     		push	80
 621 03ac FF75FC   		push	DWORD PTR [ebp-4]
 622 03af E8FCFFFF 		call	setup_IDT_entry
 622      FF
 623 03b4 83C414   		add	esp, 20
 243:host.c        ****     setup_IDT_entry (item+0x01, 0x50, (DWORD)_isr_01_wrapper, ACS_INT, 0);
 624              		.loc 1 243 0
 625 03b7 BA000000 		mov	edx, OFFSET FLAT:_isr_01_wrapper
 625      00
 626 03bc 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 627 03bf 83C008   		add	eax, 8
 628 03c2 6A00     		push	0
 629 03c4 688E0000 		push	142
 629      00
 630 03c9 52       		push	edx
 631 03ca 6A50     		push	80
 632 03cc 50       		push	eax
 633 03cd E8FCFFFF 		call	setup_IDT_entry
 633      FF
 634 03d2 83C414   		add	esp, 20
 244:host.c        ****     setup_IDT_entry (item+0x02, 0x50, (DWORD)_isr_02_wrapper, ACS_INT, 0);
 635              		.loc 1 244 0
 636 03d5 BA000000 		mov	edx, OFFSET FLAT:_isr_02_wrapper
 636      00
 637 03da 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 638 03dd 83C010   		add	eax, 16
 639 03e0 6A00     		push	0
 640 03e2 688E0000 		push	142
 640      00
 641 03e7 52       		push	edx
 642 03e8 6A50     		push	80
 643 03ea 50       		push	eax
 644 03eb E8FCFFFF 		call	setup_IDT_entry
 644      FF
 645 03f0 83C414   		add	esp, 20
 245:host.c        ****     setup_IDT_entry (item+0x03, 0x50, (DWORD)_isr_03_wrapper, ACS_INT, 0);
 646              		.loc 1 245 0
 647 03f3 BA000000 		mov	edx, OFFSET FLAT:_isr_03_wrapper
 647      00
 648 03f8 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 649 03fb 83C018   		add	eax, 24
 650 03fe 6A00     		push	0
 651 0400 688E0000 		push	142
 651      00
 652 0405 52       		push	edx
 653 0406 6A50     		push	80
 654 0408 50       		push	eax
 655 0409 E8FCFFFF 		call	setup_IDT_entry
 655      FF
 656 040e 83C414   		add	esp, 20
 246:host.c        ****     setup_IDT_entry (item+0x04, 0x50, (DWORD)_isr_04_wrapper, ACS_INT, 0);
 657              		.loc 1 246 0
 658 0411 BA000000 		mov	edx, OFFSET FLAT:_isr_04_wrapper
 658      00
 659 0416 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 660 0419 83C020   		add	eax, 32
 661 041c 6A00     		push	0
 662 041e 688E0000 		push	142
 662      00
 663 0423 52       		push	edx
 664 0424 6A50     		push	80
 665 0426 50       		push	eax
 666 0427 E8FCFFFF 		call	setup_IDT_entry
 666      FF
 667 042c 83C414   		add	esp, 20
 247:host.c        ****     setup_IDT_entry (item+0x05, 0x50, (DWORD)_isr_05_wrapper, ACS_INT, 0);
 668              		.loc 1 247 0
 669 042f BA000000 		mov	edx, OFFSET FLAT:_isr_05_wrapper
 669      00
 670 0434 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 671 0437 83C028   		add	eax, 40
 672 043a 6A00     		push	0
 673 043c 688E0000 		push	142
 673      00
 674 0441 52       		push	edx
 675 0442 6A50     		push	80
 676 0444 50       		push	eax
 677 0445 E8FCFFFF 		call	setup_IDT_entry
 677      FF
 678 044a 83C414   		add	esp, 20
 248:host.c        ****     setup_IDT_entry (item+0x06, 0x50, (DWORD)_isr_06_wrapper, ACS_INT, 0);
 679              		.loc 1 248 0
 680 044d BA000000 		mov	edx, OFFSET FLAT:_isr_06_wrapper
 680      00
 681 0452 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 682 0455 83C030   		add	eax, 48
 683 0458 6A00     		push	0
 684 045a 688E0000 		push	142
 684      00
 685 045f 52       		push	edx
 686 0460 6A50     		push	80
 687 0462 50       		push	eax
 688 0463 E8FCFFFF 		call	setup_IDT_entry
 688      FF
 689 0468 83C414   		add	esp, 20
 249:host.c        ****     setup_IDT_entry (item+0x07, 0x50, (DWORD)_isr_07_wrapper, ACS_INT, 0);
 690              		.loc 1 249 0
 691 046b BA000000 		mov	edx, OFFSET FLAT:_isr_07_wrapper
 691      00
 692 0470 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 693 0473 83C038   		add	eax, 56
 694 0476 6A00     		push	0
 695 0478 688E0000 		push	142
 695      00
 696 047d 52       		push	edx
 697 047e 6A50     		push	80
 698 0480 50       		push	eax
 699 0481 E8FCFFFF 		call	setup_IDT_entry
 699      FF
 700 0486 83C414   		add	esp, 20
 250:host.c        ****     //CLR 09/26/2014 - Changed to 0x8 ... was 0x50
 251:host.c        ****     setup_IDT_entry (item+0x08, 0x50, (DWORD)_isr_08_wrapper, ACS_INT, 0);
 701              		.loc 1 251 0
 702 0489 BA000000 		mov	edx, OFFSET FLAT:_isr_08_wrapper
 702      00
 703 048e 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 704 0491 83C040   		add	eax, 64
 705 0494 6A00     		push	0
 706 0496 688E0000 		push	142
 706      00
 707 049b 52       		push	edx
 708 049c 6A50     		push	80
 709 049e 50       		push	eax
 710 049f E8FCFFFF 		call	setup_IDT_entry
 710      FF
 711 04a4 83C414   		add	esp, 20
 252:host.c        ****     setup_IDT_entry (item+0x09, 0x50, (DWORD)_isr_09_wrapper, ACS_INT, 0);
 712              		.loc 1 252 0
 713 04a7 BA000000 		mov	edx, OFFSET FLAT:_isr_09_wrapper
 713      00
 714 04ac 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 715 04af 83C048   		add	eax, 72
 716 04b2 6A00     		push	0
 717 04b4 688E0000 		push	142
 717      00
 718 04b9 52       		push	edx
 719 04ba 6A50     		push	80
 720 04bc 50       		push	eax
 721 04bd E8FCFFFF 		call	setup_IDT_entry
 721      FF
 722 04c2 83C414   		add	esp, 20
 253:host.c        ****     setup_IDT_entry (item+0x0a, 0x50, (DWORD)_isr_0A_wrapper, ACS_INT, 0);
 723              		.loc 1 253 0
 724 04c5 BA000000 		mov	edx, OFFSET FLAT:_isr_0A_wrapper
 724      00
 725 04ca 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 726 04cd 83C050   		add	eax, 80
 727 04d0 6A00     		push	0
 728 04d2 688E0000 		push	142
 728      00
 729 04d7 52       		push	edx
 730 04d8 6A50     		push	80
 731 04da 50       		push	eax
 732 04db E8FCFFFF 		call	setup_IDT_entry
 732      FF
 733 04e0 83C414   		add	esp, 20
 254:host.c        ****     setup_IDT_entry (item+0x0b, 0x50, (DWORD)_isr_0B_wrapper, ACS_INT, 0);
 734              		.loc 1 254 0
 735 04e3 BA000000 		mov	edx, OFFSET FLAT:_isr_0B_wrapper
 735      00
 736 04e8 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 737 04eb 83C058   		add	eax, 88
 738 04ee 6A00     		push	0
 739 04f0 688E0000 		push	142
 739      00
 740 04f5 52       		push	edx
 741 04f6 6A50     		push	80
 742 04f8 50       		push	eax
 743 04f9 E8FCFFFF 		call	setup_IDT_entry
 743      FF
 744 04fe 83C414   		add	esp, 20
 255:host.c        ****     setup_IDT_entry (item+0x0c, 0x50, (DWORD)_isr_0C_wrapper, ACS_INT, 0);
 745              		.loc 1 255 0
 746 0501 BA000000 		mov	edx, OFFSET FLAT:_isr_0C_wrapper
 746      00
 747 0506 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 748 0509 83C060   		add	eax, 96
 749 050c 6A00     		push	0
 750 050e 688E0000 		push	142
 750      00
 751 0513 52       		push	edx
 752 0514 6A50     		push	80
 753 0516 50       		push	eax
 754 0517 E8FCFFFF 		call	setup_IDT_entry
 754      FF
 755 051c 83C414   		add	esp, 20
 256:host.c        ****     setup_IDT_entry (item+0x0d, 0x50, (DWORD)_isr_0D_wrapper, ACS_INT, 0);
 756              		.loc 1 256 0
 757 051f BA000000 		mov	edx, OFFSET FLAT:_isr_0D_wrapper
 757      00
 758 0524 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 759 0527 83C068   		add	eax, 104
 760 052a 6A00     		push	0
 761 052c 688E0000 		push	142
 761      00
 762 0531 52       		push	edx
 763 0532 6A50     		push	80
 764 0534 50       		push	eax
 765 0535 E8FCFFFF 		call	setup_IDT_entry
 765      FF
 766 053a 83C414   		add	esp, 20
 257:host.c        ****     setup_IDT_entry (item+0x0e, 0x50, (DWORD)host_paging_handler, ACS_INT, 3);
 767              		.loc 1 257 0
 768 053d BA000000 		mov	edx, OFFSET FLAT:host_paging_handler
 768      00
 769 0542 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 770 0545 83C070   		add	eax, 112
 771 0548 6A03     		push	3
 772 054a 688E0000 		push	142
 772      00
 773 054f 52       		push	edx
 774 0550 6A50     		push	80
 775 0552 50       		push	eax
 776 0553 E8FCFFFF 		call	setup_IDT_entry
 776      FF
 777 0558 83C414   		add	esp, 20
 258:host.c        ****     setup_IDT_entry (item+0x0f, 0x50, (DWORD)_isr_0F_wrapper, ACS_INT, 0);
 778              		.loc 1 258 0
 779 055b BA000000 		mov	edx, OFFSET FLAT:_isr_0F_wrapper
 779      00
 780 0560 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 781 0563 83C078   		add	eax, 120
 782 0566 6A00     		push	0
 783 0568 688E0000 		push	142
 783      00
 784 056d 52       		push	edx
 785 056e 6A50     		push	80
 786 0570 50       		push	eax
 787 0571 E8FCFFFF 		call	setup_IDT_entry
 787      FF
 788 0576 83C414   		add	esp, 20
 259:host.c        ****     setup_IDT_entry (item+0x10, 0x50, (DWORD)_isr_10_wrapper, ACS_INT, 0);
 789              		.loc 1 259 0
 790 0579 BA000000 		mov	edx, OFFSET FLAT:_isr_10_wrapper
 790      00
 791 057e 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 792 0581 83E880   		sub	eax, -128
 793 0584 6A00     		push	0
 794 0586 688E0000 		push	142
 794      00
 795 058b 52       		push	edx
 796 058c 6A50     		push	80
 797 058e 50       		push	eax
 798 058f E8FCFFFF 		call	setup_IDT_entry
 798      FF
 799 0594 83C414   		add	esp, 20
 260:host.c        ****     setup_IDT_entry (item+0x11, 0x50, (DWORD)_isr_11_wrapper, ACS_INT, 0);
 800              		.loc 1 260 0
 801 0597 BA000000 		mov	edx, OFFSET FLAT:_isr_11_wrapper
 801      00
 802 059c 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 803 059f 05880000 		add	eax, 136
 803      00
 804 05a4 6A00     		push	0
 805 05a6 688E0000 		push	142
 805      00
 806 05ab 52       		push	edx
 807 05ac 6A50     		push	80
 808 05ae 50       		push	eax
 809 05af E8FCFFFF 		call	setup_IDT_entry
 809      FF
 810 05b4 83C414   		add	esp, 20
 261:host.c        ****     setup_IDT_entry (item+0x12, 0x50, (DWORD)_isr_12_wrapper, ACS_INT, 0);
 811              		.loc 1 261 0
 812 05b7 BA000000 		mov	edx, OFFSET FLAT:_isr_12_wrapper
 812      00
 813 05bc 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 814 05bf 05900000 		add	eax, 144
 814      00
 815 05c4 6A00     		push	0
 816 05c6 688E0000 		push	142
 816      00
 817 05cb 52       		push	edx
 818 05cc 6A50     		push	80
 819 05ce 50       		push	eax
 820 05cf E8FCFFFF 		call	setup_IDT_entry
 820      FF
 821 05d4 83C414   		add	esp, 20
 262:host.c        ****     setup_IDT_entry (item+0x13, 0x50, (DWORD)_isr_13_wrapper, ACS_INT, 0);
 822              		.loc 1 262 0
 823 05d7 BA000000 		mov	edx, OFFSET FLAT:_isr_13_wrapper
 823      00
 824 05dc 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 825 05df 05980000 		add	eax, 152
 825      00
 826 05e4 6A00     		push	0
 827 05e6 688E0000 		push	142
 827      00
 828 05eb 52       		push	edx
 829 05ec 6A50     		push	80
 830 05ee 50       		push	eax
 831 05ef E8FCFFFF 		call	setup_IDT_entry
 831      FF
 832 05f4 83C414   		add	esp, 20
 263:host.c        ****     setup_IDT_entry (item+0x14, 0x50, (DWORD)_isr_14_wrapper, ACS_INT, 0);
 833              		.loc 1 263 0
 834 05f7 BA000000 		mov	edx, OFFSET FLAT:_isr_14_wrapper
 834      00
 835 05fc 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 836 05ff 05A00000 		add	eax, 160
 836      00
 837 0604 6A00     		push	0
 838 0606 688E0000 		push	142
 838      00
 839 060b 52       		push	edx
 840 060c 6A50     		push	80
 841 060e 50       		push	eax
 842 060f E8FCFFFF 		call	setup_IDT_entry
 842      FF
 843 0614 83C414   		add	esp, 20
 264:host.c        ****     setup_IDT_entry (item+0x15, 0x50, (DWORD)_isr_15_wrapper, ACS_INT, 0);
 844              		.loc 1 264 0
 845 0617 BA000000 		mov	edx, OFFSET FLAT:_isr_15_wrapper
 845      00
 846 061c 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 847 061f 05A80000 		add	eax, 168
 847      00
 848 0624 6A00     		push	0
 849 0626 688E0000 		push	142
 849      00
 850 062b 52       		push	edx
 851 062c 6A50     		push	80
 852 062e 50       		push	eax
 853 062f E8FCFFFF 		call	setup_IDT_entry
 853      FF
 854 0634 83C414   		add	esp, 20
 265:host.c        ****     setup_IDT_entry (item+0x16, 0x50, (DWORD)_isr_16_wrapper, ACS_INT, 0);
 855              		.loc 1 265 0
 856 0637 BA000000 		mov	edx, OFFSET FLAT:_isr_16_wrapper
 856      00
 857 063c 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 858 063f 05B00000 		add	eax, 176
 858      00
 859 0644 6A00     		push	0
 860 0646 688E0000 		push	142
 860      00
 861 064b 52       		push	edx
 862 064c 6A50     		push	80
 863 064e 50       		push	eax
 864 064f E8FCFFFF 		call	setup_IDT_entry
 864      FF
 865 0654 83C414   		add	esp, 20
 266:host.c        ****     setup_IDT_entry (item+0x17, 0x50, (DWORD)_isr_17_wrapper, ACS_INT, 0);
 866              		.loc 1 266 0
 867 0657 BA000000 		mov	edx, OFFSET FLAT:_isr_17_wrapper
 867      00
 868 065c 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 869 065f 05B80000 		add	eax, 184
 869      00
 870 0664 6A00     		push	0
 871 0666 688E0000 		push	142
 871      00
 872 066b 52       		push	edx
 873 066c 6A50     		push	80
 874 066e 50       		push	eax
 875 066f E8FCFFFF 		call	setup_IDT_entry
 875      FF
 876 0674 83C414   		add	esp, 20
 267:host.c        ****     setup_IDT_entry (item+0x18, 0x50, (DWORD)_isr_18_wrapper, ACS_INT, 0);
 877              		.loc 1 267 0
 878 0677 BA000000 		mov	edx, OFFSET FLAT:_isr_18_wrapper
 878      00
 879 067c 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 880 067f 05C00000 		add	eax, 192
 880      00
 881 0684 6A00     		push	0
 882 0686 688E0000 		push	142
 882      00
 883 068b 52       		push	edx
 884 068c 6A50     		push	80
 885 068e 50       		push	eax
 886 068f E8FCFFFF 		call	setup_IDT_entry
 886      FF
 887 0694 83C414   		add	esp, 20
 268:host.c        ****     setup_IDT_entry (item+0x19, 0x50, (DWORD)_isr_19_wrapper, ACS_INT, 0);
 888              		.loc 1 268 0
 889 0697 BA000000 		mov	edx, OFFSET FLAT:_isr_19_wrapper
 889      00
 890 069c 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 891 069f 05C80000 		add	eax, 200
 891      00
 892 06a4 6A00     		push	0
 893 06a6 688E0000 		push	142
 893      00
 894 06ab 52       		push	edx
 895 06ac 6A50     		push	80
 896 06ae 50       		push	eax
 897 06af E8FCFFFF 		call	setup_IDT_entry
 897      FF
 898 06b4 83C414   		add	esp, 20
 269:host.c        ****     setup_IDT_entry (item+0x1a, 0x50, (DWORD)_isr_1A_wrapper, ACS_INT, 0);
 899              		.loc 1 269 0
 900 06b7 BA000000 		mov	edx, OFFSET FLAT:_isr_1A_wrapper
 900      00
 901 06bc 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 902 06bf 05D00000 		add	eax, 208
 902      00
 903 06c4 6A00     		push	0
 904 06c6 688E0000 		push	142
 904      00
 905 06cb 52       		push	edx
 906 06cc 6A50     		push	80
 907 06ce 50       		push	eax
 908 06cf E8FCFFFF 		call	setup_IDT_entry
 908      FF
 909 06d4 83C414   		add	esp, 20
 270:host.c        ****     setup_IDT_entry (item+0x1b, 0x50, (DWORD)_isr_1B_wrapper, ACS_INT, 0);
 910              		.loc 1 270 0
 911 06d7 BA000000 		mov	edx, OFFSET FLAT:_isr_1B_wrapper
 911      00
 912 06dc 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 913 06df 05D80000 		add	eax, 216
 913      00
 914 06e4 6A00     		push	0
 915 06e6 688E0000 		push	142
 915      00
 916 06eb 52       		push	edx
 917 06ec 6A50     		push	80
 918 06ee 50       		push	eax
 919 06ef E8FCFFFF 		call	setup_IDT_entry
 919      FF
 920 06f4 83C414   		add	esp, 20
 271:host.c        ****     setup_IDT_entry (item+0x1c, 0x50, (DWORD)_isr_1C_wrapper, ACS_INT, 0);
 921              		.loc 1 271 0
 922 06f7 BA000000 		mov	edx, OFFSET FLAT:_isr_1C_wrapper
 922      00
 923 06fc 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 924 06ff 05E00000 		add	eax, 224
 924      00
 925 0704 6A00     		push	0
 926 0706 688E0000 		push	142
 926      00
 927 070b 52       		push	edx
 928 070c 6A50     		push	80
 929 070e 50       		push	eax
 930 070f E8FCFFFF 		call	setup_IDT_entry
 930      FF
 931 0714 83C414   		add	esp, 20
 272:host.c        ****     setup_IDT_entry (item+0x1d, 0x50, (DWORD)_isr_1D_wrapper, ACS_INT, 0);
 932              		.loc 1 272 0
 933 0717 BA000000 		mov	edx, OFFSET FLAT:_isr_1D_wrapper
 933      00
 934 071c 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 935 071f 05E80000 		add	eax, 232
 935      00
 936 0724 6A00     		push	0
 937 0726 688E0000 		push	142
 937      00
 938 072b 52       		push	edx
 939 072c 6A50     		push	80
 940 072e 50       		push	eax
 941 072f E8FCFFFF 		call	setup_IDT_entry
 941      FF
 942 0734 83C414   		add	esp, 20
 273:host.c        ****     setup_IDT_entry (item+0x1e, 0x50, (DWORD)_isr_1E_wrapper, ACS_INT, 0);
 943              		.loc 1 273 0
 944 0737 BA000000 		mov	edx, OFFSET FLAT:_isr_1E_wrapper
 944      00
 945 073c 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 946 073f 05F00000 		add	eax, 240
 946      00
 947 0744 6A00     		push	0
 948 0746 688E0000 		push	142
 948      00
 949 074b 52       		push	edx
 950 074c 6A50     		push	80
 951 074e 50       		push	eax
 952 074f E8FCFFFF 		call	setup_IDT_entry
 952      FF
 953 0754 83C414   		add	esp, 20
 274:host.c        ****     setup_IDT_entry (item+0x1f, 0x50, (DWORD)_isr_1F_wrapper, ACS_INT, 0);
 954              		.loc 1 274 0
 955 0757 BA000000 		mov	edx, OFFSET FLAT:_isr_1F_wrapper
 955      00
 956 075c 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 957 075f 05F80000 		add	eax, 248
 957      00
 958 0764 6A00     		push	0
 959 0766 688E0000 		push	142
 959      00
 960 076b 52       		push	edx
 961 076c 6A50     		push	80
 962 076e 50       		push	eax
 963 076f E8FCFFFF 		call	setup_IDT_entry
 963      FF
 964 0774 83C414   		add	esp, 20
 275:host.c        ****     setup_IDT_entry (item+0x20, 0x50, (DWORD)_isr_20_wrapper, ACS_INT, 0);
 965              		.loc 1 275 0
 966 0777 BA000000 		mov	edx, OFFSET FLAT:_isr_20_wrapper
 966      00
 967 077c 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 968 077f 05000100 		add	eax, 256
 968      00
 969 0784 6A00     		push	0
 970 0786 688E0000 		push	142
 970      00
 971 078b 52       		push	edx
 972 078c 6A50     		push	80
 973 078e 50       		push	eax
 974 078f E8FCFFFF 		call	setup_IDT_entry
 974      FF
 975 0794 83C414   		add	esp, 20
 276:host.c        ****     setup_IDT_entry (item+0x21, 0x50, (DWORD)_isr_21_wrapper, ACS_INT, 0);
 976              		.loc 1 276 0
 977 0797 BA000000 		mov	edx, OFFSET FLAT:_isr_21_wrapper
 977      00
 978 079c 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 979 079f 05080100 		add	eax, 264
 979      00
 980 07a4 6A00     		push	0
 981 07a6 688E0000 		push	142
 981      00
 982 07ab 52       		push	edx
 983 07ac 6A50     		push	80
 984 07ae 50       		push	eax
 985 07af E8FCFFFF 		call	setup_IDT_entry
 985      FF
 986 07b4 83C414   		add	esp, 20
 277:host.c        **** }
 987              		.loc 1 277 0
 988 07b7 90       		nop
 989 07b8 C9       		leave
 990              		.cfi_restore 5
 991              		.cfi_def_cfa 4, 4
 992 07b9 C3       		ret
 993              		.cfi_endproc
 994              	.LFE5:
 996              		.globl	UpdatePDEntry
 998              	UpdatePDEntry:
 999              	.LFB6:
 278:host.c        **** 
 279:host.c        **** void UpdatePDEntry(DWORD *PDAddress, WORD Entry, DWORD Page )
 280:host.c        **** {
 1000              		.loc 1 280 0
 1001              		.cfi_startproc
 1002 07ba 55       		push	ebp
 1003              		.cfi_def_cfa_offset 8
 1004              		.cfi_offset 5, -8
 1005 07bb 89E5     		mov	ebp, esp
 1006              		.cfi_def_cfa_register 5
 1007 07bd 83EC04   		sub	esp, 4
 1008 07c0 8B450C   		mov	eax, DWORD PTR [ebp+12]
 1009 07c3 668945FC 		mov	WORD PTR [ebp-4], ax
 281:host.c        ****     OPEN_UP_DS
 1010              		.loc 1 281 0
 1011              	#APP
 1012              	# 281 "host.c" 1
 282 07c8 B8100000 	    PDAddress[Entry] = (Page & 0xFFFFF000) | 7;
 282      00
 283 07cd 50       	    RESTORE_DS
 284 07ce 1F       	}
 285 07cf 58       	
 286              	void ProcessVMRunResults()
 287              	{
 282:host.c        ****     RESTORE_DS
 1013              		push eax
 1014              	 mov eax, 0x10
 1015              	 push eax
 1016              	 pop ds
 1017              	 pop eax
 1018              	
 1019              	# 0 "" 2
 1020              		.loc 1 282 0
 1021              	#NO_APP
 1022 07d0 0FB745FC 		movzx	eax, WORD PTR [ebp-4]
 1023 07d4 8D148500 		lea	edx, [0+eax*4]
 1023      000000
 1024 07db 8B4508   		mov	eax, DWORD PTR [ebp+8]
 1025 07de 01D0     		add	eax, edx
 1026 07e0 8B5510   		mov	edx, DWORD PTR [ebp+16]
 1027 07e3 81E200F0 		and	edx, -4096
 1027      FFFF
 1028 07e9 83CA07   		or	edx, 7
 1029 07ec 8910     		mov	DWORD PTR [eax], edx
 283:host.c        **** }
 1030              		.loc 1 283 0
 1031 07ee B8380000 		mov	eax, 56
 1031      00
 1032              	#APP
 1033              	# 283 "host.c" 1
 288              	    char *pErr = "                    \0";
 289              	    BYTE IntNo = 0;
 284:host.c        **** 
 1034              		push eax
 1035              	 mov eax, eax
 1036              	 push eax
 1037              	 pop ds
 1038              	 pop eax
 1039              	
 1040              	# 0 "" 2
 1041              		.loc 1 284 0
 1042              	#NO_APP
 1043 07f9 90       		nop
 1044 07fa C9       		leave
 1045              		.cfi_restore 5
 1046              		.cfi_def_cfa 4, 4
 1047 07fb C3       		ret
 1048              		.cfi_endproc
 1049              	.LFE6:
 1051              		.section	.rodata
 1052              	.LC3:
 1053 00c9 20202020 		.string	"                    "
 1053      20202020 
 1053      20202020 
 1053      20202020 
 1053      20202020 
 1054 00de 00       		.string	""
 1055              	.LC4:
 1056 00df 307800   		.string	"0x"
 1057              	.LC5:
 1058 00e2 202D2056 		.string	" - Vm "
 1058      6D2000
 1059              	.LC6:
 1060 00e9 202D2050 		.string	" - Pm "
 1060      6D2000
 1061              	.LC7:
 1062 00f0 202D2052 		.string	" - Rm "
 1062      6D2000
 1063              	.LC8:
 1064 00f7 506700   		.string	"Pg"
 1065              	.LC9:
 1066 00fa 4E7000   		.string	"Np"
 1067              	.LC10:
 1068 00fd 2C204578 		.string	", Exit: 0x"
 1068      69743A20 
 1068      307800
 1069              	.LC11:
 1070 0108 2C20496E 		.string	", Info1: 0x"
 1070      666F313A 
 1070      20307800 
 1071              	.LC12:
 1072 0114 2C20496E 		.string	", Info2: 0x"
 1072      666F323A 
 1072      20307800 
 1073              	.LC13:
 1074 0120 2C20496E 		.string	", Int#: 0x"
 1074      74233A20 
 1074      307800
 1075 012b 00       		.align 4
 1076              	.LC14:
 1077 012c 20202020 		.string	"                                           "
 1077      20202020 
 1077      20202020 
 1077      20202020 
 1077      20202020 
 1078              	.LC15:
 1079 0158 6743533D 		.string	"gCS=0x"
 1079      307800
 1080              	.LC16:
 1081 015f 2C206745 		.string	", gEIP=0x"
 1081      49503D30 
 1081      7800
 1082 0169 000000   		.align 4
 1083              	.LC17:
 1084 016c 43523020 		.string	"CR0 write attempt, guest CS:EIP: "
 1084      77726974 
 1084      65206174 
 1084      74656D70 
 1084      742C2067 
 1085              	.LC18:
 1086 018e 20202D20 		.string	"  -  EAX = 0x"
 1086      20454158 
 1086      203D2030 
 1086      7800
 1087              		.align 4
 1088              	.LC19:
 1089 019c 564D2053 		.string	"VM Shutdown State Entered ... locking up now!!!"
 1089      68757464 
 1089      6F776E20 
 1089      53746174 
 1089      6520456E 
 1090              	.LC20:
 1091 01cc 45786365 		.string	"Exception Number: 0x"
 1091      7074696F 
 1091      6E204E75 
 1091      6D626572 
 1091      3A203078 
 1092              	.LC21:
 1093 01e1 47756573 		.string	"Guest CS:EIP: "
 1093      74204353 
 1093      3A454950 
 1093      3A2000
 1094              	.LC22:
 1095 01f0 202000   		.string	"  "
 1096              	.LC23:
 1097 01f3 43523020 		.string	"CR0 value: "
 1097      76616C75 
 1097      653A2000 
 1098              	.LC24:
 1099 01ff 2C204352 		.string	", CR3 value: "
 1099      33207661 
 1099      6C75653A 
 1099      2000
 1100              	.LC25:
 1101 020d 5649534F 		.string	"VISOR: HLT called with IF=0"
 1101      523A2048 
 1101      4C542063 
 1101      616C6C65 
 1101      64207769 
 1102 0229 00       		.string	""
 1103 022a 0000     		.align 4
 1104              	.LC26:
 1105 022c 20202020 		.string	"     VISOR: NMI intercepted, something broke!!!"
 1105      20564953 
 1105      4F523A20 
 1105      4E4D4920 
 1105      696E7465 
 1106              	.LC27:
 1107 025c 556E6861 		.string	"Unhandled Intercept: "
 1107      6E646C65 
 1107      6420496E 
 1107      74657263 
 1107      6570743A 
 1108              		.text
 1109              		.globl	ProcessVMRunResults
 1111              	ProcessVMRunResults:
 1112              	.LFB7:
 287:host.c        ****     char *pErr = "                    \0";
 1113              		.loc 1 287 0
 1114              		.cfi_startproc
 1115 07fc 55       		push	ebp
 1116              		.cfi_def_cfa_offset 8
 1117              		.cfi_offset 5, -8
 1118 07fd 89E5     		mov	ebp, esp
 1119              		.cfi_def_cfa_register 5
 1120 07ff 56       		push	esi
 1121 0800 53       		push	ebx
 1122 0801 83EC40   		sub	esp, 64
 1123              		.cfi_offset 6, -12
 1124              		.cfi_offset 3, -16
 288:host.c        ****     BYTE IntNo = 0;
 1125              		.loc 1 288 0
 1126 0804 C745F4C9 		mov	DWORD PTR [ebp-12], OFFSET FLAT:.LC3
 1126      000000
 1127              		.loc 1 289 0
 1128 080b C645F300 		mov	BYTE PTR [ebp-13], 0
 290:host.c        **** 
 291:host.c        **** #ifdef DEBUG_BASIC
 292:host.c        ****     printAt("0x",0,0);
 1129              		.loc 1 292 0
 1130 080f 83EC04   		sub	esp, 4
 1131 0812 6A00     		push	0
 1132 0814 6A00     		push	0
 1133 0816 68DF0000 		push	OFFSET FLAT:.LC4
 1133      00
 1134 081b E8FCFFFF 		call	printAt
 1134      FF
 1135 0820 83C410   		add	esp, 16
 293:host.c        ****     pErr = Itoa(InterceptCount, pErr, 16);
 1136              		.loc 1 293 0
 1137 0823 A1000000 		mov	eax, DWORD PTR InterceptCount
 1137      00
 1138 0828 8B150400 		mov	edx, DWORD PTR InterceptCount+4
 1138      0000
 1139 082e 83EC04   		sub	esp, 4
 1140 0831 6A10     		push	16
 1141 0833 FF75F4   		push	DWORD PTR [ebp-12]
 1142 0836 50       		push	eax
 1143 0837 E8FCFFFF 		call	Itoa
 1143      FF
 1144 083c 83C410   		add	esp, 16
 1145 083f 8945F4   		mov	DWORD PTR [ebp-12], eax
 294:host.c        ****     print(pErr);
 1146              		.loc 1 294 0
 1147 0842 83EC0C   		sub	esp, 12
 1148 0845 FF75F4   		push	DWORD PTR [ebp-12]
 1149 0848 E8FCFFFF 		call	print
 1149      FF
 1150 084d 83C410   		add	esp, 16
 295:host.c        ****     if ( (guest.vmcb->cr0 & 0x1) == 0x1)
 1151              		.loc 1 295 0
 1152 0850 A1040000 		mov	eax, DWORD PTR guest+4
 1152      00
 1153 0855 8B905C05 		mov	edx, DWORD PTR [eax+1372]
 1153      0000
 1154 085b 8B805805 		mov	eax, DWORD PTR [eax+1368]
 1154      0000
 1155 0861 89C1     		mov	ecx, eax
 1156 0863 83E101   		and	ecx, 1
 1157 0866 89CB     		mov	ebx, ecx
 1158 0868 89D0     		mov	eax, edx
 1159 086a 83E000   		and	eax, 0
 1160 086d 89C6     		mov	esi, eax
 1161 086f 89F0     		mov	eax, esi
 1162 0871 09D8     		or	eax, ebx
 1163 0873 85C0     		test	eax, eax
 1164 0875 7456     		je	.L51
 296:host.c        ****         if ((guest.vmcb->rflags & 0x20000) == 0x20000)
 1165              		.loc 1 296 0
 1166 0877 A1040000 		mov	eax, DWORD PTR guest+4
 1166      00
 1167 087c 8B907405 		mov	edx, DWORD PTR [eax+1396]
 1167      0000
 1168 0882 8B807005 		mov	eax, DWORD PTR [eax+1392]
 1168      0000
 1169 0888 89C6     		mov	esi, eax
 1170 088a 81E60000 		and	esi, 131072
 1170      0200
 1171 0890 8975E0   		mov	DWORD PTR [ebp-32], esi
 1172 0893 89D0     		mov	eax, edx
 1173 0895 83E000   		and	eax, 0
 1174 0898 8945E4   		mov	DWORD PTR [ebp-28], eax
 1175 089b 8B5DE0   		mov	ebx, DWORD PTR [ebp-32]
 1176 089e 8B75E4   		mov	esi, DWORD PTR [ebp-28]
 1177 08a1 89F0     		mov	eax, esi
 1178 08a3 09D8     		or	eax, ebx
 1179 08a5 85C0     		test	eax, eax
 1180 08a7 7412     		je	.L52
 297:host.c        ****             print(" - Vm ");
 1181              		.loc 1 297 0
 1182 08a9 83EC0C   		sub	esp, 12
 1183 08ac 68E20000 		push	OFFSET FLAT:.LC5
 1183      00
 1184 08b1 E8FCFFFF 		call	print
 1184      FF
 1185 08b6 83C410   		add	esp, 16
 1186 08b9 EB22     		jmp	.L54
 1187              	.L52:
 298:host.c        ****         else
 299:host.c        ****             print(" - Pm ");
 1188              		.loc 1 299 0
 1189 08bb 83EC0C   		sub	esp, 12
 1190 08be 68E90000 		push	OFFSET FLAT:.LC6
 1190      00
 1191 08c3 E8FCFFFF 		call	print
 1191      FF
 1192 08c8 83C410   		add	esp, 16
 1193 08cb EB10     		jmp	.L54
 1194              	.L51:
 300:host.c        ****     else
 301:host.c        ****             print(" - Rm ");
 1195              		.loc 1 301 0
 1196 08cd 83EC0C   		sub	esp, 12
 1197 08d0 68F00000 		push	OFFSET FLAT:.LC7
 1197      00
 1198 08d5 E8FCFFFF 		call	print
 1198      FF
 1199 08da 83C410   		add	esp, 16
 1200              	.L54:
 302:host.c        ****     if ( (guest.vmcb->cr0 & 0x80000000) == 0x80000000)
 1201              		.loc 1 302 0
 1202 08dd A1040000 		mov	eax, DWORD PTR guest+4
 1202      00
 1203 08e2 8B905C05 		mov	edx, DWORD PTR [eax+1372]
 1203      0000
 1204 08e8 8B805805 		mov	eax, DWORD PTR [eax+1368]
 1204      0000
 1205 08ee 89C6     		mov	esi, eax
 1206 08f0 81E60000 		and	esi, -2147483648
 1206      0080
 1207 08f6 8975D8   		mov	DWORD PTR [ebp-40], esi
 1208 08f9 89D0     		mov	eax, edx
 1209 08fb 83E000   		and	eax, 0
 1210 08fe 8945DC   		mov	DWORD PTR [ebp-36], eax
 1211 0901 8B5DD8   		mov	ebx, DWORD PTR [ebp-40]
 1212 0904 8B75DC   		mov	esi, DWORD PTR [ebp-36]
 1213 0907 89F0     		mov	eax, esi
 1214 0909 09D8     		or	eax, ebx
 1215 090b 85C0     		test	eax, eax
 1216 090d 7412     		je	.L55
 303:host.c        ****             print("Pg");
 1217              		.loc 1 303 0
 1218 090f 83EC0C   		sub	esp, 12
 1219 0912 68F70000 		push	OFFSET FLAT:.LC8
 1219      00
 1220 0917 E8FCFFFF 		call	print
 1220      FF
 1221 091c 83C410   		add	esp, 16
 1222 091f EB10     		jmp	.L56
 1223              	.L55:
 304:host.c        ****     else
 305:host.c        ****             print("Np");
 1224              		.loc 1 305 0
 1225 0921 83EC0C   		sub	esp, 12
 1226 0924 68FA0000 		push	OFFSET FLAT:.LC9
 1226      00
 1227 0929 E8FCFFFF 		call	print
 1227      FF
 1228 092e 83C410   		add	esp, 16
 1229              	.L56:
 306:host.c        ****     pErr = Itoa((int)guest.vmcb->exitcode, pErr, 16);
 1230              		.loc 1 306 0
 1231 0931 A1040000 		mov	eax, DWORD PTR guest+4
 1231      00
 1232 0936 8B5074   		mov	edx, DWORD PTR [eax+116]
 1233 0939 8B4070   		mov	eax, DWORD PTR [eax+112]
 1234 093c 83EC04   		sub	esp, 4
 1235 093f 6A10     		push	16
 1236 0941 FF75F4   		push	DWORD PTR [ebp-12]
 1237 0944 50       		push	eax
 1238 0945 E8FCFFFF 		call	Itoa
 1238      FF
 1239 094a 83C410   		add	esp, 16
 1240 094d 8945F4   		mov	DWORD PTR [ebp-12], eax
 307:host.c        ****    print(", Exit: 0x");
 1241              		.loc 1 307 0
 1242 0950 83EC0C   		sub	esp, 12
 1243 0953 68FD0000 		push	OFFSET FLAT:.LC10
 1243      00
 1244 0958 E8FCFFFF 		call	print
 1244      FF
 1245 095d 83C410   		add	esp, 16
 308:host.c        ****    print(pErr);
 1246              		.loc 1 308 0
 1247 0960 83EC0C   		sub	esp, 12
 1248 0963 FF75F4   		push	DWORD PTR [ebp-12]
 1249 0966 E8FCFFFF 		call	print
 1249      FF
 1250 096b 83C410   		add	esp, 16
 309:host.c        ****    pErr = Itoa((int)guest.vmcb->exitinfo1, pErr, 16);
 1251              		.loc 1 309 0
 1252 096e A1040000 		mov	eax, DWORD PTR guest+4
 1252      00
 1253 0973 8B507C   		mov	edx, DWORD PTR [eax+124]
 1254 0976 8B4078   		mov	eax, DWORD PTR [eax+120]
 1255 0979 83EC04   		sub	esp, 4
 1256 097c 6A10     		push	16
 1257 097e FF75F4   		push	DWORD PTR [ebp-12]
 1258 0981 50       		push	eax
 1259 0982 E8FCFFFF 		call	Itoa
 1259      FF
 1260 0987 83C410   		add	esp, 16
 1261 098a 8945F4   		mov	DWORD PTR [ebp-12], eax
 310:host.c        ****    print(", Info1: 0x");
 1262              		.loc 1 310 0
 1263 098d 83EC0C   		sub	esp, 12
 1264 0990 68080100 		push	OFFSET FLAT:.LC11
 1264      00
 1265 0995 E8FCFFFF 		call	print
 1265      FF
 1266 099a 83C410   		add	esp, 16
 311:host.c        ****    print(pErr);
 1267              		.loc 1 311 0
 1268 099d 83EC0C   		sub	esp, 12
 1269 09a0 FF75F4   		push	DWORD PTR [ebp-12]
 1270 09a3 E8FCFFFF 		call	print
 1270      FF
 1271 09a8 83C410   		add	esp, 16
 312:host.c        ****    pErr = Itoa((int)guest.vmcb->exitinfo2, pErr, 16);
 1272              		.loc 1 312 0
 1273 09ab A1040000 		mov	eax, DWORD PTR guest+4
 1273      00
 1274 09b0 8B908400 		mov	edx, DWORD PTR [eax+132]
 1274      0000
 1275 09b6 8B808000 		mov	eax, DWORD PTR [eax+128]
 1275      0000
 1276 09bc 83EC04   		sub	esp, 4
 1277 09bf 6A10     		push	16
 1278 09c1 FF75F4   		push	DWORD PTR [ebp-12]
 1279 09c4 50       		push	eax
 1280 09c5 E8FCFFFF 		call	Itoa
 1280      FF
 1281 09ca 83C410   		add	esp, 16
 1282 09cd 8945F4   		mov	DWORD PTR [ebp-12], eax
 313:host.c        ****    print(", Info2: 0x");
 1283              		.loc 1 313 0
 1284 09d0 83EC0C   		sub	esp, 12
 1285 09d3 68140100 		push	OFFSET FLAT:.LC12
 1285      00
 1286 09d8 E8FCFFFF 		call	print
 1286      FF
 1287 09dd 83C410   		add	esp, 16
 314:host.c        ****    print(pErr);
 1288              		.loc 1 314 0
 1289 09e0 83EC0C   		sub	esp, 12
 1290 09e3 FF75F4   		push	DWORD PTR [ebp-12]
 1291 09e6 E8FCFFFF 		call	print
 1291      FF
 1292 09eb 83C410   		add	esp, 16
 315:host.c        ****    pErr = Itoa((int)guest.vmcb->exitintinfo.fields.vector, pErr, 16);
 1293              		.loc 1 315 0
 1294 09ee A1040000 		mov	eax, DWORD PTR guest+4
 1294      00
 1295 09f3 0FB68088 		movzx	eax, BYTE PTR [eax+136]
 1295      000000
 1296 09fa 0FB6C0   		movzx	eax, al
 1297 09fd 83EC04   		sub	esp, 4
 1298 0a00 6A10     		push	16
 1299 0a02 FF75F4   		push	DWORD PTR [ebp-12]
 1300 0a05 50       		push	eax
 1301 0a06 E8FCFFFF 		call	Itoa
 1301      FF
 1302 0a0b 83C410   		add	esp, 16
 1303 0a0e 8945F4   		mov	DWORD PTR [ebp-12], eax
 316:host.c        ****    print(", Int#: 0x");
 1304              		.loc 1 316 0
 1305 0a11 83EC0C   		sub	esp, 12
 1306 0a14 68200100 		push	OFFSET FLAT:.LC13
 1306      00
 1307 0a19 E8FCFFFF 		call	print
 1307      FF
 1308 0a1e 83C410   		add	esp, 16
 317:host.c        ****    print(pErr);
 1309              		.loc 1 317 0
 1310 0a21 83EC0C   		sub	esp, 12
 1311 0a24 FF75F4   		push	DWORD PTR [ebp-12]
 1312 0a27 E8FCFFFF 		call	print
 1312      FF
 1313 0a2c 83C410   		add	esp, 16
 318:host.c        **** #endif
 319:host.c        **** #ifdef DEBUG
 320:host.c        ****     pErr = Itoa((int)guest.vmcb->cs.sel, pErr, 16);
 1314              		.loc 1 320 0
 1315 0a2f A1040000 		mov	eax, DWORD PTR guest+4
 1315      00
 1316 0a34 0FB78010 		movzx	eax, WORD PTR [eax+1040]
 1316      040000
 1317 0a3b 0FB7C0   		movzx	eax, ax
 1318 0a3e 83EC04   		sub	esp, 4
 1319 0a41 6A10     		push	16
 1320 0a43 FF75F4   		push	DWORD PTR [ebp-12]
 1321 0a46 50       		push	eax
 1322 0a47 E8FCFFFF 		call	Itoa
 1322      FF
 1323 0a4c 83C410   		add	esp, 16
 1324 0a4f 8945F4   		mov	DWORD PTR [ebp-12], eax
 321:host.c        ****     print("                                           ");
 1325              		.loc 1 321 0
 1326 0a52 83EC0C   		sub	esp, 12
 1327 0a55 682C0100 		push	OFFSET FLAT:.LC14
 1327      00
 1328 0a5a E8FCFFFF 		call	print
 1328      FF
 1329 0a5f 83C410   		add	esp, 16
 322:host.c        ****     print("gCS=0x");
 1330              		.loc 1 322 0
 1331 0a62 83EC0C   		sub	esp, 12
 1332 0a65 68580100 		push	OFFSET FLAT:.LC15
 1332      00
 1333 0a6a E8FCFFFF 		call	print
 1333      FF
 1334 0a6f 83C410   		add	esp, 16
 323:host.c        ****     print(pErr);
 1335              		.loc 1 323 0
 1336 0a72 83EC0C   		sub	esp, 12
 1337 0a75 FF75F4   		push	DWORD PTR [ebp-12]
 1338 0a78 E8FCFFFF 		call	print
 1338      FF
 1339 0a7d 83C410   		add	esp, 16
 324:host.c        ****     pErr = Itoa((int)guest.vmcb->rip, pErr, 16);
 1340              		.loc 1 324 0
 1341 0a80 A1040000 		mov	eax, DWORD PTR guest+4
 1341      00
 1342 0a85 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 1342      0000
 1343 0a8b 8B807805 		mov	eax, DWORD PTR [eax+1400]
 1343      0000
 1344 0a91 83EC04   		sub	esp, 4
 1345 0a94 6A10     		push	16
 1346 0a96 FF75F4   		push	DWORD PTR [ebp-12]
 1347 0a99 50       		push	eax
 1348 0a9a E8FCFFFF 		call	Itoa
 1348      FF
 1349 0a9f 83C410   		add	esp, 16
 1350 0aa2 8945F4   		mov	DWORD PTR [ebp-12], eax
 325:host.c        ****     print(", gEIP=0x");
 1351              		.loc 1 325 0
 1352 0aa5 83EC0C   		sub	esp, 12
 1353 0aa8 685F0100 		push	OFFSET FLAT:.LC16
 1353      00
 1354 0aad E8FCFFFF 		call	print
 1354      FF
 1355 0ab2 83C410   		add	esp, 16
 326:host.c        ****     print(pErr);
 1356              		.loc 1 326 0
 1357 0ab5 83EC0C   		sub	esp, 12
 1358 0ab8 FF75F4   		push	DWORD PTR [ebp-12]
 1359 0abb E8FCFFFF 		call	print
 1359      FF
 1360 0ac0 83C410   		add	esp, 16
 327:host.c        **** #endif
 328:host.c        ****     guest.vmcb->tlb_control = 0;
 1361              		.loc 1 328 0
 1362 0ac3 A1040000 		mov	eax, DWORD PTR guest+4
 1362      00
 1363 0ac8 C6405C00 		mov	BYTE PTR [eax+92], 0
 329:host.c        ****     guest.vmcb->eventinj.fields.v = false;      //Make sure event injection is turned off
 1364              		.loc 1 329 0
 1365 0acc 8B150400 		mov	edx, DWORD PTR guest+4
 1365      0000
 1366 0ad2 0FB682AB 		movzx	eax, BYTE PTR [edx+171]
 1366      000000
 1367 0ad9 83E07F   		and	eax, 127
 1368 0adc 8882AB00 		mov	BYTE PTR [edx+171], al
 1368      0000
 330:host.c        ****     guest.vmcb->clean_bits=0xFFFF;              //Everything is clean for now
 1369              		.loc 1 330 0
 1370 0ae2 A1040000 		mov	eax, DWORD PTR guest+4
 1370      00
 1371 0ae7 C780C000 		mov	DWORD PTR [eax+192], 65535
 1371      0000FFFF 
 1371      0000
 331:host.c        ****     IntNo = guest.vmcb->exitinfo1;
 1372              		.loc 1 331 0
 1373 0af1 A1040000 		mov	eax, DWORD PTR guest+4
 1373      00
 1374 0af6 8B507C   		mov	edx, DWORD PTR [eax+124]
 1375 0af9 8B4078   		mov	eax, DWORD PTR [eax+120]
 1376 0afc 8845F3   		mov	BYTE PTR [ebp-13], al
 332:host.c        ****     switch(guest.vmcb->exitcode)
 1377              		.loc 1 332 0
 1378 0aff A1040000 		mov	eax, DWORD PTR guest+4
 1378      00
 1379 0b04 8B5074   		mov	edx, DWORD PTR [eax+116]
 1380 0b07 8B4070   		mov	eax, DWORD PTR [eax+112]
 1381 0b0a 83FA00   		cmp	edx, 0
 1382 0b0d 0F87D400 		ja	.L58
 1382      0000
 1383 0b13 83FA00   		cmp	edx, 0
 1384 0b16 7209     		jb	.L59
 1385 0b18 83F853   		cmp	eax, 83
 1386 0b1b 0F87C600 		ja	.L58
 1386      0000
 1387              	.L59:
 1388 0b21 83FA00   		cmp	edx, 0
 1389 0b24 0F87B704 		ja	.L60
 1389      0000
 1390 0b2a 83FA00   		cmp	edx, 0
 1391 0b2d 7209     		jb	.L61
 1392 0b2f 83F84F   		cmp	eax, 79
 1393 0b32 0F83A904 		jnb	.L60
 1393      0000
 1394              	.L61:
 1395 0b38 83FA00   		cmp	edx, 0
 1396 0b3b 7773     		ja	.L62
 1397 0b3d 83FA00   		cmp	edx, 0
 1398 0b40 7205     		jb	.L63
 1399 0b42 83F84A   		cmp	eax, 74
 1400 0b45 7769     		ja	.L62
 1401              	.L63:
 1402 0b47 83FA00   		cmp	edx, 0
 1403 0b4a 0F879104 		ja	.L60
 1403      0000
 1404 0b50 83FA00   		cmp	edx, 0
 1405 0b53 7209     		jb	.L64
 1406 0b55 83F840   		cmp	eax, 64
 1407 0b58 0F838304 		jnb	.L60
 1407      0000
 1408              	.L64:
 1409 0b5e 89C1     		mov	ecx, eax
 1410 0b60 83F103   		xor	ecx, 3
 1411 0b63 09D1     		or	ecx, edx
 1412 0b65 85C9     		test	ecx, ecx
 1413 0b67 0F844003 		je	.L65
 1413      0000
 1414 0b6d 83FA00   		cmp	edx, 0
 1415 0b70 7719     		ja	.L66
 1416 0b72 83FA00   		cmp	edx, 0
 1417 0b75 7205     		jb	.L67
 1418 0b77 83F803   		cmp	eax, 3
 1419 0b7a 770F     		ja	.L66
 1420              	.L67:
 1421 0b7c 09D0     		or	eax, edx
 1422 0b7e 85C0     		test	eax, eax
 1423 0b80 0F841D03 		je	.L68
 1423      0000
 1424 0b86 E9C20900 		jmp	.L57
 1424      00
 1425              	.L66:
 1426 0b8b 89C1     		mov	ecx, eax
 1427 0b8d 83F110   		xor	ecx, 16
 1428 0b90 09D1     		or	ecx, edx
 1429 0b92 85C9     		test	ecx, ecx
 1430 0b94 0F841D03 		je	.L69
 1430      0000
 1431 0b9a 89C1     		mov	ecx, eax
 1432 0b9c 83F113   		xor	ecx, 19
 1433 0b9f 09D1     		or	ecx, edx
 1434 0ba1 89C8     		mov	eax, ecx
 1435 0ba3 85C0     		test	eax, eax
 1436 0ba5 0F84F603 		je	.L70
 1436      0000
 1437 0bab E99D0900 		jmp	.L57
 1437      00
 1438              	.L62:
 1439 0bb0 83FA00   		cmp	edx, 0
 1440 0bb3 0F829409 		jb	.L57
 1440      0000
 1441 0bb9 83FA00   		cmp	edx, 0
 1442 0bbc 7709     		ja	.L71
 1443 0bbe 83F84C   		cmp	eax, 76
 1444 0bc1 0F828609 		jb	.L57
 1444      0000
 1445              	.L71:
 1446 0bc7 83FA00   		cmp	edx, 0
 1447 0bca 0F821104 		jb	.L60
 1447      0000
 1448 0bd0 83FA00   		cmp	edx, 0
 1449 0bd3 0F87DE00 		ja	.L73
 1449      0000
 1450 0bd9 83F84D   		cmp	eax, 77
 1451 0bdc 0F86FF03 		jbe	.L60
 1451      0000
 1452 0be2 E9D00000 		jmp	.L73
 1452      00
 1453              	.L58:
 1454 0be7 89C1     		mov	ecx, eax
 1455 0be9 83F175   		xor	ecx, 117
 1456 0bec 09D1     		or	ecx, edx
 1457 0bee 85C9     		test	ecx, ecx
 1458 0bf0 0F84A601 		je	.L74
 1458      0000
 1459 0bf6 83FA00   		cmp	edx, 0
 1460 0bf9 7763     		ja	.L75
 1461 0bfb 83FA00   		cmp	edx, 0
 1462 0bfe 7205     		jb	.L76
 1463 0c00 83F875   		cmp	eax, 117
 1464 0c03 7759     		ja	.L75
 1465              	.L76:
 1466 0c05 89C1     		mov	ecx, eax
 1467 0c07 83F161   		xor	ecx, 97
 1468 0c0a 09D1     		or	ecx, edx
 1469 0c0c 85C9     		test	ecx, ecx
 1470 0c0e 0F842508 		je	.L77
 1470      0000
 1471 0c14 83FA00   		cmp	edx, 0
 1472 0c17 7720     		ja	.L78
 1473 0c19 83FA00   		cmp	edx, 0
 1474 0c1c 7205     		jb	.L79
 1475 0c1e 83F861   		cmp	eax, 97
 1476 0c21 7716     		ja	.L78
 1477              	.L79:
 1478 0c23 89C1     		mov	ecx, eax
 1479 0c25 83F160   		xor	ecx, 96
 1480 0c28 09D1     		or	ecx, edx
 1481 0c2a 89C8     		mov	eax, ecx
 1482 0c2c 85C0     		test	eax, eax
 1483 0c2e 0F846801 		je	.L74
 1483      0000
 1484 0c34 E9140900 		jmp	.L57
 1484      00
 1485              	.L78:
 1486 0c39 89C1     		mov	ecx, eax
 1487 0c3b 83F172   		xor	ecx, 114
 1488 0c3e 09D1     		or	ecx, edx
 1489 0c40 85C9     		test	ecx, ecx
 1490 0c42 0F841C08 		je	.L80
 1490      0000
 1491 0c48 89C1     		mov	ecx, eax
 1492 0c4a 83F174   		xor	ecx, 116
 1493 0c4d 09D1     		or	ecx, edx
 1494 0c4f 89C8     		mov	eax, ecx
 1495 0c51 85C0     		test	eax, eax
 1496 0c53 0F842302 		je	.L81
 1496      0000
 1497 0c59 E9EF0800 		jmp	.L57
 1497      00
 1498              	.L75:
 1499 0c5e 89C1     		mov	ecx, eax
 1500 0c60 83F17B   		xor	ecx, 123
 1501 0c63 09D1     		or	ecx, edx
 1502 0c65 85C9     		test	ecx, ecx
 1503 0c67 0F843E03 		je	.L82
 1503      0000
 1504 0c6d 83FA00   		cmp	edx, 0
 1505 0c70 7720     		ja	.L83
 1506 0c72 83FA00   		cmp	edx, 0
 1507 0c75 7205     		jb	.L84
 1508 0c77 83F87B   		cmp	eax, 123
 1509 0c7a 7716     		ja	.L83
 1510              	.L84:
 1511 0c7c 89C1     		mov	ecx, eax
 1512 0c7e 83F178   		xor	ecx, 120
 1513 0c81 09D1     		or	ecx, edx
 1514 0c83 89C8     		mov	eax, ecx
 1515 0c85 85C0     		test	eax, eax
 1516 0c87 0F842707 		je	.L85
 1516      0000
 1517 0c8d E9BB0800 		jmp	.L57
 1517      00
 1518              	.L83:
 1519 0c92 89C1     		mov	ecx, eax
 1520 0c94 83F17F   		xor	ecx, 127
 1521 0c97 09D1     		or	ecx, edx
 1522 0c99 85C9     		test	ecx, ecx
 1523 0c9b 0F841403 		je	.L86
 1523      0000
 1524 0ca1 89C1     		mov	ecx, eax
 1525 0ca3 80F504   		xor	ch, 4
 1526 0ca6 09D1     		or	ecx, edx
 1527 0ca8 89C8     		mov	eax, ecx
 1528 0caa 85C0     		test	eax, eax
 1529 0cac 0F84F508 		je	.L101
 1529      0000
 1530 0cb2 E9960800 		jmp	.L57
 1530      00
 1531              	.L73:
 333:host.c        ****     {
 334:host.c        ****         case VMEXIT_NPF :	//Paging exception
 335:host.c        **** 
 336:host.c        **** //            guest.vmcb->eventinj.fields.v = true;
 337:host.c        **** //            guest.vmcb->eventinj.fields.ev = true;
 338:host.c        **** //            guest.vmcb->eventinj.fields.type = 3;
 339:host.c        **** //            guest.vmcb->eventinj.fields.vector = 0xe;
 340:host.c        **** 
 341:host.c        **** //            if (guest.vmcb->np_enable)
 342:host.c        **** //            {
 343:host.c        **** //                guest.vmcb->eventinj.fields.errorcode = 0x0;
 344:host.c        **** //                DWORD lCR2;
 345:host.c        **** //                asm("mov eax,cr2\nmov %[CR2],eax\n" : [CR2] "=r" (lCR2));
 346:host.c        **** //                guest.vmcb->cr2 = lCR2;
 347:host.c        **** //                break;
 348:host.c        **** //            }
 349:host.c        **** //            else
 350:host.c        **** //            {
 351:host.c        **** //                guest.vmcb->eventinj.fields.errorcode = guest.vmcb->exitinfo1 & 0xFFF;
 352:host.c        **** //                guest.vmcb->cr2 = guest.vmcb->exitinfo2;
 353:host.c        **** //            }
 354:host.c        **** //            else
 355:host.c        **** //                InfiniteLoop(guest.vmcb->exitcode);
 356:host.c        ****             break;
 357:host.c        ****         case VMEXIT_EXCEPTION_PF:
 358:host.c        ****             if (guest.vmcb->np_enable)
 1532              		.loc 1 358 0
 1533 0cb7 A1040000 		mov	eax, DWORD PTR guest+4
 1533      00
 1534 0cbc 8B909400 		mov	edx, DWORD PTR [eax+148]
 1534      0000
 1535 0cc2 8B809000 		mov	eax, DWORD PTR [eax+144]
 1535      0000
 1536 0cc8 09D0     		or	eax, edx
 1537 0cca 85C0     		test	eax, eax
 1538 0ccc 741C     		je	.L89
 359:host.c        ****             {
 360:host.c        ****                 //Nested paging is enabled so we should never get here.
 361:host.c        ****                 InfiniteLoop(guest.vmcb->exitcode);
 1539              		.loc 1 361 0
 1540 0cce A1040000 		mov	eax, DWORD PTR guest+4
 1540      00
 1541 0cd3 8B5074   		mov	edx, DWORD PTR [eax+116]
 1542 0cd6 8B4070   		mov	eax, DWORD PTR [eax+112]
 1543 0cd9 83EC0C   		sub	esp, 12
 1544 0cdc 50       		push	eax
 1545 0cdd E8FCFFFF 		call	InfiniteLoop
 1545      FF
 1546 0ce2 83C410   		add	esp, 16
 362:host.c        ****             }
 363:host.c        ****             else
 364:host.c        ****             {
 365:host.c        ****                 InfiniteLoop(guest.vmcb->exitcode);
 366:host.c        ****                 //We set up shadow pages for the entire guest memory so there should never be a gue
 367:host.c        ****                 //If there is one though, reflect it back!
 368:host.c        ****                 guest.vmcb->eventinj.fields.v = 1;
 369:host.c        ****                 guest.vmcb->eventinj.fields.ev = 1;
 370:host.c        ****                 guest.vmcb->eventinj.fields.type = 3;
 371:host.c        ****                 guest.vmcb->eventinj.fields.vector = guest.vmcb->exitcode - 0x40;
 372:host.c        ****                 guest.vmcb->eventinj.fields.errorcode = guest.vmcb->exitinfo1;
 373:host.c        ****                 guest.vmcb->cr2 = guest.vmcb->exitinfo2;
 374:host.c        ****                 //HandleGuestPagingException(guest.vmcb->exitinfo2, guest.vmcb->exitinfo1);
 375:host.c        ****             }
 376:host.c        ****             break;
 1547              		.loc 1 376 0
 1548 0ce5 E9C10800 		jmp	.L88
 1548      00
 1549              	.L89:
 365:host.c        ****                 //We set up shadow pages for the entire guest memory so there should never be a gue
 1550              		.loc 1 365 0
 1551 0cea A1040000 		mov	eax, DWORD PTR guest+4
 1551      00
 1552 0cef 8B5074   		mov	edx, DWORD PTR [eax+116]
 1553 0cf2 8B4070   		mov	eax, DWORD PTR [eax+112]
 1554 0cf5 83EC0C   		sub	esp, 12
 1555 0cf8 50       		push	eax
 1556 0cf9 E8FCFFFF 		call	InfiniteLoop
 1556      FF
 1557 0cfe 83C410   		add	esp, 16
 368:host.c        ****                 guest.vmcb->eventinj.fields.ev = 1;
 1558              		.loc 1 368 0
 1559 0d01 A1040000 		mov	eax, DWORD PTR guest+4
 1559      00
 1560 0d06 0FB690AB 		movzx	edx, BYTE PTR [eax+171]
 1560      000000
 1561 0d0d 83CA80   		or	edx, -128
 1562 0d10 8890AB00 		mov	BYTE PTR [eax+171], dl
 1562      0000
 369:host.c        ****                 guest.vmcb->eventinj.fields.type = 3;
 1563              		.loc 1 369 0
 1564 0d16 A1040000 		mov	eax, DWORD PTR guest+4
 1564      00
 1565 0d1b 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 1565      000000
 1566 0d22 83CA08   		or	edx, 8
 1567 0d25 8890A900 		mov	BYTE PTR [eax+169], dl
 1567      0000
 370:host.c        ****                 guest.vmcb->eventinj.fields.vector = guest.vmcb->exitcode - 0x40;
 1568              		.loc 1 370 0
 1569 0d2b A1040000 		mov	eax, DWORD PTR guest+4
 1569      00
 1570 0d30 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 1570      000000
 1571 0d37 83E2F8   		and	edx, -8
 1572 0d3a 83CA03   		or	edx, 3
 1573 0d3d 8890A900 		mov	BYTE PTR [eax+169], dl
 1573      0000
 371:host.c        ****                 guest.vmcb->eventinj.fields.errorcode = guest.vmcb->exitinfo1;
 1574              		.loc 1 371 0
 1575 0d43 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1575      0000
 1576 0d49 A1040000 		mov	eax, DWORD PTR guest+4
 1576      00
 1577 0d4e 8B5074   		mov	edx, DWORD PTR [eax+116]
 1578 0d51 8B4070   		mov	eax, DWORD PTR [eax+112]
 1579 0d54 83E840   		sub	eax, 64
 1580 0d57 8881A800 		mov	BYTE PTR [ecx+168], al
 1580      0000
 372:host.c        ****                 guest.vmcb->cr2 = guest.vmcb->exitinfo2;
 1581              		.loc 1 372 0
 1582 0d5d 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1582      0000
 1583 0d63 A1040000 		mov	eax, DWORD PTR guest+4
 1583      00
 1584 0d68 8B507C   		mov	edx, DWORD PTR [eax+124]
 1585 0d6b 8B4078   		mov	eax, DWORD PTR [eax+120]
 1586 0d6e 8981AC00 		mov	DWORD PTR [ecx+172], eax
 1586      0000
 373:host.c        ****                 //HandleGuestPagingException(guest.vmcb->exitinfo2, guest.vmcb->exitinfo1);
 1587              		.loc 1 373 0
 1588 0d74 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1588      0000
 1589 0d7a A1040000 		mov	eax, DWORD PTR guest+4
 1589      00
 1590 0d7f 8B908400 		mov	edx, DWORD PTR [eax+132]
 1590      0000
 1591 0d85 8B808000 		mov	eax, DWORD PTR [eax+128]
 1591      0000
 1592 0d8b 89814006 		mov	DWORD PTR [ecx+1600], eax
 1592      0000
 1593 0d91 89914406 		mov	DWORD PTR [ecx+1604], edx
 1593      0000
 1594              		.loc 1 376 0
 1595 0d97 E90F0800 		jmp	.L88
 1595      00
 1596              	.L74:
 377:host.c        ****         case VMEXIT_SWINT: 
 378:host.c        ****         case VMEXIT_INTR:
 379:host.c        **** /*#ifdef DEBUG
 380:host.c        ****             pErr = Itoa((int)IntNo, pErr, 16);
 381:host.c        ****             monitor_write(", IntNo: ");
 382:host.c        ****             monitor_write(pErr);
 383:host.c        ****             monitor_write(" ");
 384:host.c        ****             pErr = Itoa(guest.vmcb->rax, pErr, 16);
 385:host.c        ****             monitor_write(pErr);
 386:host.c        ****             monitor_write("   ");
 387:host.c        **** #endif*/
 388:host.c        ****             //Interrupts that we want to emulate
 389:host.c        ****             //Interrupt 15 AH=88: SYSTEM - GET EXTENDED MEMORY SIZE
 390:host.c        ****             if ((IntNo == 0x15) // && (guest.vmcb->rax & 0xFF00) == 0x8800)  )/* | IntNo == 0x1C)*/
 1597              		.loc 1 390 0
 1598 0d9c 807DF315 		cmp	BYTE PTR [ebp-13], 21
 1599 0da0 755B     		jne	.L91
 391:host.c        ****             //Interrupt 13 AH=08: DISK - GET DRIVE PARAMETERS 
 392:host.c        ****             //|| (IntNo == 0x13 && (guest.vmcb->rax & 0x0F00) == 0x0800 && (GuestRegisters[RAN_EDX]
 393:host.c        **** 	    )
 394:host.c        ****             {
 395:host.c        ****                 HandleRealModeSWInterrupt(IntNo); 
 1600              		.loc 1 395 0
 1601 0da2 0FB645F3 		movzx	eax, BYTE PTR [ebp-13]
 1602 0da6 83EC0C   		sub	esp, 12
 1603 0da9 50       		push	eax
 1604 0daa E8FCFFFF 		call	HandleRealModeSWInterrupt
 1604      FF
 1605 0daf 83C410   		add	esp, 16
 396:host.c        ****                 guest.vmcb->clean_bits |= 0xFEFF;   //CS changed
 1606              		.loc 1 396 0
 1607 0db2 A1040000 		mov	eax, DWORD PTR guest+4
 1607      00
 1608 0db7 8B150400 		mov	edx, DWORD PTR guest+4
 1608      0000
 1609 0dbd 8B92C000 		mov	edx, DWORD PTR [edx+192]
 1609      0000
 1610 0dc3 81CAFFFE 		or	edx, 65279
 1610      0000
 1611 0dc9 8990C000 		mov	DWORD PTR [eax+192], edx
 1611      0000
 397:host.c        ****                 guest.vmcb->rip += 2; //= guest.vmcb->nextrip;
 1612              		.loc 1 397 0
 1613 0dcf 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1613      0000
 1614 0dd5 A1040000 		mov	eax, DWORD PTR guest+4
 1614      00
 1615 0dda 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 1615      0000
 1616 0de0 8B807805 		mov	eax, DWORD PTR [eax+1400]
 1616      0000
 1617 0de6 83C002   		add	eax, 2
 1618 0de9 83D200   		adc	edx, 0
 1619 0dec 89817805 		mov	DWORD PTR [ecx+1400], eax
 1619      0000
 1620 0df2 89917C05 		mov	DWORD PTR [ecx+1404], edx
 1620      0000
 398:host.c        ****             }            
 399:host.c        ****             else
 400:host.c        ****             {
 401:host.c        ****                 //Inject an event to make the INT happen
 402:host.c        ****                 guest.vmcb->rip += 2; //= guest.vmcb->nextrip;
 403:host.c        ****                 guest.vmcb->eventinj.fields.v = 1;
 404:host.c        ****                 guest.vmcb->eventinj.fields.ev = 0;
 405:host.c        ****                 guest.vmcb->eventinj.fields.type = 4;
 406:host.c        ****                 guest.vmcb->eventinj.fields.vector = IntNo;
 407:host.c        **** //asm("xchgw bx,bx\n");
 408:host.c        ****                 //SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(0 << 11) | (DWORD)(4 <
 409:host.c        ****             }
 410:host.c        ****             break;
 1621              		.loc 1 410 0
 1622 0df8 E9AE0700 		jmp	.L88
 1622      00
 1623              	.L91:
 402:host.c        ****                 guest.vmcb->eventinj.fields.v = 1;
 1624              		.loc 1 402 0
 1625 0dfd 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1625      0000
 1626 0e03 A1040000 		mov	eax, DWORD PTR guest+4
 1626      00
 1627 0e08 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 1627      0000
 1628 0e0e 8B807805 		mov	eax, DWORD PTR [eax+1400]
 1628      0000
 1629 0e14 83C002   		add	eax, 2
 1630 0e17 83D200   		adc	edx, 0
 1631 0e1a 89817805 		mov	DWORD PTR [ecx+1400], eax
 1631      0000
 1632 0e20 89917C05 		mov	DWORD PTR [ecx+1404], edx
 1632      0000
 403:host.c        ****                 guest.vmcb->eventinj.fields.ev = 0;
 1633              		.loc 1 403 0
 1634 0e26 A1040000 		mov	eax, DWORD PTR guest+4
 1634      00
 1635 0e2b 0FB690AB 		movzx	edx, BYTE PTR [eax+171]
 1635      000000
 1636 0e32 83CA80   		or	edx, -128
 1637 0e35 8890AB00 		mov	BYTE PTR [eax+171], dl
 1637      0000
 404:host.c        ****                 guest.vmcb->eventinj.fields.type = 4;
 1638              		.loc 1 404 0
 1639 0e3b A1040000 		mov	eax, DWORD PTR guest+4
 1639      00
 1640 0e40 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 1640      000000
 1641 0e47 83E2F7   		and	edx, -9
 1642 0e4a 8890A900 		mov	BYTE PTR [eax+169], dl
 1642      0000
 405:host.c        ****                 guest.vmcb->eventinj.fields.vector = IntNo;
 1643              		.loc 1 405 0
 1644 0e50 A1040000 		mov	eax, DWORD PTR guest+4
 1644      00
 1645 0e55 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 1645      000000
 1646 0e5c 83E2F8   		and	edx, -8
 1647 0e5f 83CA04   		or	edx, 4
 1648 0e62 8890A900 		mov	BYTE PTR [eax+169], dl
 1648      0000
 406:host.c        **** //asm("xchgw bx,bx\n");
 1649              		.loc 1 406 0
 1650 0e68 A1040000 		mov	eax, DWORD PTR guest+4
 1650      00
 1651 0e6d 0FB655F3 		movzx	edx, BYTE PTR [ebp-13]
 1652 0e71 8890A800 		mov	BYTE PTR [eax+168], dl
 1652      0000
 1653              		.loc 1 410 0
 1654 0e77 E92F0700 		jmp	.L88
 1654      00
 1655              	.L81:
 411:host.c        ****         case VMEXIT_IRET:
 412:host.c        ****             HandleInterrutpReturn();
 1656              		.loc 1 412 0
 1657 0e7c E8FCFFFF 		call	HandleInterrutpReturn
 1657      FF
 413:host.c        ****             guest.vmcb->clean_bits = guest.vmcb->clean_bits | 0xFEFF; //CS changed
 1658              		.loc 1 413 0
 1659 0e81 A1040000 		mov	eax, DWORD PTR guest+4
 1659      00
 1660 0e86 8B150400 		mov	edx, DWORD PTR guest+4
 1660      0000
 1661 0e8c 8B92C000 		mov	edx, DWORD PTR [edx+192]
 1661      0000
 1662 0e92 81CAFFFE 		or	edx, 65279
 1662      0000
 1663 0e98 8990C000 		mov	DWORD PTR [eax+192], edx
 1663      0000
 414:host.c        ****             break;
 1664              		.loc 1 414 0
 1665 0e9e E9080700 		jmp	.L88
 1665      00
 1666              	.L68:
 415:host.c        ****         case VMEXIT_CR0_READ:
 416:host.c        ****             HandleCR0Read();
 1667              		.loc 1 416 0
 1668 0ea3 E8FCFFFF 		call	HandleCR0Read
 1668      FF
 417:host.c        ****             break;
 1669              		.loc 1 417 0
 1670 0ea8 E9FE0600 		jmp	.L88
 1670      00
 1671              	.L65:
 418:host.c        ****         case VMEXIT_CR3_READ:
 419:host.c        ****             HandleCR3Read();
 1672              		.loc 1 419 0
 1673 0ead E8FCFFFF 		call	HandleCR3Read
 1673      FF
 420:host.c        ****             break;
 1674              		.loc 1 420 0
 1675 0eb2 E9F40600 		jmp	.L88
 1675      00
 1676              	.L69:
 421:host.c        ****         case VMEXIT_CR0_WRITE:
 422:host.c        **** #ifdef DEBUG
 423:host.c        ****             pErr = Itoa((int)guest.vmcb->cs.sel, pErr, 16);
 1677              		.loc 1 423 0
 1678 0eb7 A1040000 		mov	eax, DWORD PTR guest+4
 1678      00
 1679 0ebc 0FB78010 		movzx	eax, WORD PTR [eax+1040]
 1679      040000
 1680 0ec3 0FB7C0   		movzx	eax, ax
 1681 0ec6 83EC04   		sub	esp, 4
 1682 0ec9 6A10     		push	16
 1683 0ecb FF75F4   		push	DWORD PTR [ebp-12]
 1684 0ece 50       		push	eax
 1685 0ecf E8FCFFFF 		call	Itoa
 1685      FF
 1686 0ed4 83C410   		add	esp, 16
 1687 0ed7 8945F4   		mov	DWORD PTR [ebp-12], eax
 424:host.c        ****             printAt("CR0 write attempt, guest CS:EIP: ",0,6);
 1688              		.loc 1 424 0
 1689 0eda 83EC04   		sub	esp, 4
 1690 0edd 6A06     		push	6
 1691 0edf 6A00     		push	0
 1692 0ee1 686C0100 		push	OFFSET FLAT:.LC17
 1692      00
 1693 0ee6 E8FCFFFF 		call	printAt
 1693      FF
 1694 0eeb 83C410   		add	esp, 16
 425:host.c        ****             printAt("gCS=0x",0,3);
 1695              		.loc 1 425 0
 1696 0eee 83EC04   		sub	esp, 4
 1697 0ef1 6A03     		push	3
 1698 0ef3 6A00     		push	0
 1699 0ef5 68580100 		push	OFFSET FLAT:.LC15
 1699      00
 1700 0efa E8FCFFFF 		call	printAt
 1700      FF
 1701 0eff 83C410   		add	esp, 16
 426:host.c        ****             print(pErr);
 1702              		.loc 1 426 0
 1703 0f02 83EC0C   		sub	esp, 12
 1704 0f05 FF75F4   		push	DWORD PTR [ebp-12]
 1705 0f08 E8FCFFFF 		call	print
 1705      FF
 1706 0f0d 83C410   		add	esp, 16
 427:host.c        ****             pErr = Itoa((int)guest.vmcb->rip, pErr, 16);
 1707              		.loc 1 427 0
 1708 0f10 A1040000 		mov	eax, DWORD PTR guest+4
 1708      00
 1709 0f15 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 1709      0000
 1710 0f1b 8B807805 		mov	eax, DWORD PTR [eax+1400]
 1710      0000
 1711 0f21 83EC04   		sub	esp, 4
 1712 0f24 6A10     		push	16
 1713 0f26 FF75F4   		push	DWORD PTR [ebp-12]
 1714 0f29 50       		push	eax
 1715 0f2a E8FCFFFF 		call	Itoa
 1715      FF
 1716 0f2f 83C410   		add	esp, 16
 1717 0f32 8945F4   		mov	DWORD PTR [ebp-12], eax
 428:host.c        ****             print(", gEIP=0x");
 1718              		.loc 1 428 0
 1719 0f35 83EC0C   		sub	esp, 12
 1720 0f38 685F0100 		push	OFFSET FLAT:.LC16
 1720      00
 1721 0f3d E8FCFFFF 		call	print
 1721      FF
 1722 0f42 83C410   		add	esp, 16
 429:host.c        ****             print(pErr);
 1723              		.loc 1 429 0
 1724 0f45 83EC0C   		sub	esp, 12
 1725 0f48 FF75F4   		push	DWORD PTR [ebp-12]
 1726 0f4b E8FCFFFF 		call	print
 1726      FF
 1727 0f50 83C410   		add	esp, 16
 430:host.c        ****             print("  -  EAX = 0x");
 1728              		.loc 1 430 0
 1729 0f53 83EC0C   		sub	esp, 12
 1730 0f56 688E0100 		push	OFFSET FLAT:.LC18
 1730      00
 1731 0f5b E8FCFFFF 		call	print
 1731      FF
 1732 0f60 83C410   		add	esp, 16
 431:host.c        ****             pErr = Itoa(guest.vmcb->rax, pErr, 16);
 1733              		.loc 1 431 0
 1734 0f63 A1040000 		mov	eax, DWORD PTR guest+4
 1734      00
 1735 0f68 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 1735      0000
 1736 0f6e 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 1736      0000
 1737 0f74 83EC04   		sub	esp, 4
 1738 0f77 6A10     		push	16
 1739 0f79 FF75F4   		push	DWORD PTR [ebp-12]
 1740 0f7c 50       		push	eax
 1741 0f7d E8FCFFFF 		call	Itoa
 1741      FF
 1742 0f82 83C410   		add	esp, 16
 1743 0f85 8945F4   		mov	DWORD PTR [ebp-12], eax
 432:host.c        **** #endif
 433:host.c        ****             guest.vmcb->clean_bits = 0xFFDF;   //CRX unclean
 1744              		.loc 1 433 0
 1745 0f88 A1040000 		mov	eax, DWORD PTR guest+4
 1745      00
 1746 0f8d C780C000 		mov	DWORD PTR [eax+192], 65503
 1746      0000DFFF 
 1746      0000
 434:host.c        ****             HandleCR0Write();
 1747              		.loc 1 434 0
 1748 0f97 E8FCFFFF 		call	HandleCR0Write
 1748      FF
 435:host.c        ****             break;
 1749              		.loc 1 435 0
 1750 0f9c E90A0600 		jmp	.L88
 1750      00
 1751              	.L70:
 436:host.c        ****         case VMEXIT_CR3_WRITE:
 437:host.c        ****             HandleCR3Write();
 1752              		.loc 1 437 0
 1753 0fa1 E8FCFFFF 		call	HandleCR3Write
 1753      FF
 438:host.c        ****             break;
 1754              		.loc 1 438 0
 1755 0fa6 E9000600 		jmp	.L88
 1755      00
 1756              	.L82:
 439:host.c        ****         case VMEXIT_IOIO:
 440:host.c        ****             //monitor_write_at("VISOR: In IOIO Handler",0,16);
 441:host.c        ****             //return;
 442:host.c        ****             //IOIOLoop1:
 443:host.c        ****             //goto IOIOLoop1;
 444:host.c        ****             HandleGuestIO();
 1757              		.loc 1 444 0
 1758 0fab E8FCFFFF 		call	HandleGuestIO
 1758      FF
 445:host.c        ****             break;
 1759              		.loc 1 445 0
 1760 0fb0 E9F60500 		jmp	.L88
 1760      00
 1761              	.L86:
 446:host.c        ****         case VMEXIT_SHUTDOWN:
 447:host.c        ****             print("VM Shutdown State Entered ... locking up now!!!");
 1762              		.loc 1 447 0
 1763 0fb5 83EC0C   		sub	esp, 12
 1764 0fb8 689C0100 		push	OFFSET FLAT:.LC19
 1764      00
 1765 0fbd E8FCFFFF 		call	print
 1765      FF
 1766 0fc2 83C410   		add	esp, 16
 448:host.c        ****             InfiniteLoop(guest.vmcb->exitcode);
 1767              		.loc 1 448 0
 1768 0fc5 A1040000 		mov	eax, DWORD PTR guest+4
 1768      00
 1769 0fca 8B5074   		mov	edx, DWORD PTR [eax+116]
 1770 0fcd 8B4070   		mov	eax, DWORD PTR [eax+112]
 1771 0fd0 83EC0C   		sub	esp, 12
 1772 0fd3 50       		push	eax
 1773 0fd4 E8FCFFFF 		call	InfiniteLoop
 1773      FF
 1774 0fd9 83C410   		add	esp, 16
 449:host.c        ****             break;
 1775              		.loc 1 449 0
 1776 0fdc E9CA0500 		jmp	.L88
 1776      00
 1777              	.L60:
 450:host.c        ****         case VMEXIT_EXCEPTION_DE: case VMEXIT_EXCEPTION_DB: case VMEXIT_EXCEPTION_NMI: case VMEXIT_
 451:host.c        ****              case VMEXIT_EXCEPTION_UD: case VMEXIT_EXCEPTION_NM: case VMEXIT_EXCEPTION_DF: case VME
 452:host.c        ****              case VMEXIT_EXCEPTION_SS: case VMEXIT_EXCEPTION_GP: case VMEXIT_EXCEPTION_15: case VME
 453:host.c        ****              case VMEXIT_EXCEPTION_MC: case VMEXIT_EXCEPTION_XF:
 454:host.c        **** #ifdef DEBUG
 455:host.c        ****                             printAt("Exception Number: 0x",0,10);
 1778              		.loc 1 455 0
 1779 0fe1 83EC04   		sub	esp, 4
 1780 0fe4 6A0A     		push	10
 1781 0fe6 6A00     		push	0
 1782 0fe8 68CC0100 		push	OFFSET FLAT:.LC20
 1782      00
 1783 0fed E8FCFFFF 		call	printAt
 1783      FF
 1784 0ff2 83C410   		add	esp, 16
 456:host.c        ****                             pErr = Itoa(guest.vmcb->exitcode - 0x40, pErr, 16);
 1785              		.loc 1 456 0
 1786 0ff5 A1040000 		mov	eax, DWORD PTR guest+4
 1786      00
 1787 0ffa 8B5074   		mov	edx, DWORD PTR [eax+116]
 1788 0ffd 8B4070   		mov	eax, DWORD PTR [eax+112]
 1789 1000 83E840   		sub	eax, 64
 1790 1003 83EC04   		sub	esp, 4
 1791 1006 6A10     		push	16
 1792 1008 FF75F4   		push	DWORD PTR [ebp-12]
 1793 100b 50       		push	eax
 1794 100c E8FCFFFF 		call	Itoa
 1794      FF
 1795 1011 83C410   		add	esp, 16
 1796 1014 8945F4   		mov	DWORD PTR [ebp-12], eax
 457:host.c        ****                             print(pErr);
 1797              		.loc 1 457 0
 1798 1017 83EC0C   		sub	esp, 12
 1799 101a FF75F4   		push	DWORD PTR [ebp-12]
 1800 101d E8FCFFFF 		call	print
 1800      FF
 1801 1022 83C410   		add	esp, 16
 458:host.c        ****                             pErr = Itoa(guest.vmcb->cs.sel, pErr, 16);
 1802              		.loc 1 458 0
 1803 1025 A1040000 		mov	eax, DWORD PTR guest+4
 1803      00
 1804 102a 0FB78010 		movzx	eax, WORD PTR [eax+1040]
 1804      040000
 1805 1031 0FB7C0   		movzx	eax, ax
 1806 1034 83EC04   		sub	esp, 4
 1807 1037 6A10     		push	16
 1808 1039 FF75F4   		push	DWORD PTR [ebp-12]
 1809 103c 50       		push	eax
 1810 103d E8FCFFFF 		call	Itoa
 1810      FF
 1811 1042 83C410   		add	esp, 16
 1812 1045 8945F4   		mov	DWORD PTR [ebp-12], eax
 459:host.c        ****                             printAt("Guest CS:EIP: ",0,11);
 1813              		.loc 1 459 0
 1814 1048 83EC04   		sub	esp, 4
 1815 104b 6A0B     		push	11
 1816 104d 6A00     		push	0
 1817 104f 68E10100 		push	OFFSET FLAT:.LC21
 1817      00
 1818 1054 E8FCFFFF 		call	printAt
 1818      FF
 1819 1059 83C410   		add	esp, 16
 460:host.c        ****                             print("gCS=0x");
 1820              		.loc 1 460 0
 1821 105c 83EC0C   		sub	esp, 12
 1822 105f 68580100 		push	OFFSET FLAT:.LC15
 1822      00
 1823 1064 E8FCFFFF 		call	print
 1823      FF
 1824 1069 83C410   		add	esp, 16
 461:host.c        ****                             print(pErr);
 1825              		.loc 1 461 0
 1826 106c 83EC0C   		sub	esp, 12
 1827 106f FF75F4   		push	DWORD PTR [ebp-12]
 1828 1072 E8FCFFFF 		call	print
 1828      FF
 1829 1077 83C410   		add	esp, 16
 462:host.c        ****                             pErr = Itoa(guest.vmcb->rip, pErr, 16);
 1830              		.loc 1 462 0
 1831 107a A1040000 		mov	eax, DWORD PTR guest+4
 1831      00
 1832 107f 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 1832      0000
 1833 1085 8B807805 		mov	eax, DWORD PTR [eax+1400]
 1833      0000
 1834 108b 83EC04   		sub	esp, 4
 1835 108e 6A10     		push	16
 1836 1090 FF75F4   		push	DWORD PTR [ebp-12]
 1837 1093 50       		push	eax
 1838 1094 E8FCFFFF 		call	Itoa
 1838      FF
 1839 1099 83C410   		add	esp, 16
 1840 109c 8945F4   		mov	DWORD PTR [ebp-12], eax
 463:host.c        ****                             print(", gEIP=0x");
 1841              		.loc 1 463 0
 1842 109f 83EC0C   		sub	esp, 12
 1843 10a2 685F0100 		push	OFFSET FLAT:.LC16
 1843      00
 1844 10a7 E8FCFFFF 		call	print
 1844      FF
 1845 10ac 83C410   		add	esp, 16
 464:host.c        ****                             print(pErr);
 1846              		.loc 1 464 0
 1847 10af 83EC0C   		sub	esp, 12
 1848 10b2 FF75F4   		push	DWORD PTR [ebp-12]
 1849 10b5 E8FCFFFF 		call	print
 1849      FF
 1850 10ba 83C410   		add	esp, 16
 465:host.c        ****                             print("  ");
 1851              		.loc 1 465 0
 1852 10bd 83EC0C   		sub	esp, 12
 1853 10c0 68F00100 		push	OFFSET FLAT:.LC22
 1853      00
 1854 10c5 E8FCFFFF 		call	print
 1854      FF
 1855 10ca 83C410   		add	esp, 16
 466:host.c        ****                             printAt("CR0 value: ",0,18);
 1856              		.loc 1 466 0
 1857 10cd 83EC04   		sub	esp, 4
 1858 10d0 6A12     		push	18
 1859 10d2 6A00     		push	0
 1860 10d4 68F30100 		push	OFFSET FLAT:.LC23
 1860      00
 1861 10d9 E8FCFFFF 		call	printAt
 1861      FF
 1862 10de 83C410   		add	esp, 16
 467:host.c        ****                             pErr = Itoa(EAX, pErr, 16);
 1863              		.loc 1 467 0
 1864 10e1 83EC04   		sub	esp, 4
 1865 10e4 6A10     		push	16
 1866 10e6 FF75F4   		push	DWORD PTR [ebp-12]
 1867 10e9 6A00     		push	0
 1868 10eb E8FCFFFF 		call	Itoa
 1868      FF
 1869 10f0 83C410   		add	esp, 16
 1870 10f3 8945F4   		mov	DWORD PTR [ebp-12], eax
 468:host.c        ****                             print(pErr);
 1871              		.loc 1 468 0
 1872 10f6 83EC0C   		sub	esp, 12
 1873 10f9 FF75F4   		push	DWORD PTR [ebp-12]
 1874 10fc E8FCFFFF 		call	print
 1874      FF
 1875 1101 83C410   		add	esp, 16
 469:host.c        ****                             print(", CR3 value: ");
 1876              		.loc 1 469 0
 1877 1104 83EC0C   		sub	esp, 12
 1878 1107 68FF0100 		push	OFFSET FLAT:.LC24
 1878      00
 1879 110c E8FCFFFF 		call	print
 1879      FF
 1880 1111 83C410   		add	esp, 16
 470:host.c        ****                             pErr = Itoa(guest.vmcb->cr3, pErr, 16);
 1881              		.loc 1 470 0
 1882 1114 A1040000 		mov	eax, DWORD PTR guest+4
 1882      00
 1883 1119 8B905405 		mov	edx, DWORD PTR [eax+1364]
 1883      0000
 1884 111f 8B805005 		mov	eax, DWORD PTR [eax+1360]
 1884      0000
 1885 1125 83EC04   		sub	esp, 4
 1886 1128 6A10     		push	16
 1887 112a FF75F4   		push	DWORD PTR [ebp-12]
 1888 112d 50       		push	eax
 1889 112e E8FCFFFF 		call	Itoa
 1889      FF
 1890 1133 83C410   		add	esp, 16
 1891 1136 8945F4   		mov	DWORD PTR [ebp-12], eax
 471:host.c        ****                             print(pErr);
 1892              		.loc 1 471 0
 1893 1139 83EC0C   		sub	esp, 12
 1894 113c FF75F4   		push	DWORD PTR [ebp-12]
 1895 113f E8FCFFFF 		call	print
 1895      FF
 1896 1144 83C410   		add	esp, 16
 472:host.c        **** #endif
 473:host.c        ****             //if (guest.vmcb->exitcode == VMEXIT_EXCEPTION_PF)
 474:host.c        ****                 //NOTE: paging fault is handled above with nested paging fault
 475:host.c        ****             guest.vmcb->eventinj.fields.errorcode = 0;
 1897              		.loc 1 475 0
 1898 1147 A1040000 		mov	eax, DWORD PTR guest+4
 1898      00
 1899 114c C780AC00 		mov	DWORD PTR [eax+172], 0
 1899      00000000 
 1899      0000
 476:host.c        ****             if (guest.vmcb->exitcode == VMEXIT_EXCEPTION_DB)
 1900              		.loc 1 476 0
 1901 1156 A1040000 		mov	eax, DWORD PTR guest+4
 1901      00
 1902 115b 8B5074   		mov	edx, DWORD PTR [eax+116]
 1903 115e 8B4070   		mov	eax, DWORD PTR [eax+112]
 1904 1161 89C1     		mov	ecx, eax
 1905 1163 83F141   		xor	ecx, 65
 1906 1166 09D1     		or	ecx, edx
 1907 1168 89C8     		mov	eax, ecx
 1908 116a 85C0     		test	eax, eax
 1909 116c 755E     		jne	.L93
 477:host.c        ****             {
 478:host.c        ****                     //#DB trap gets injected as an INTR with no error code
 479:host.c        ****                 guest.vmcb->eventinj.fields.v = true;
 1910              		.loc 1 479 0
 1911 116e A1040000 		mov	eax, DWORD PTR guest+4
 1911      00
 1912 1173 0FB690AB 		movzx	edx, BYTE PTR [eax+171]
 1912      000000
 1913 117a 83CA80   		or	edx, -128
 1914 117d 8890AB00 		mov	BYTE PTR [eax+171], dl
 1914      0000
 480:host.c        ****                 guest.vmcb->eventinj.fields.ev = false;
 1915              		.loc 1 480 0
 1916 1183 A1040000 		mov	eax, DWORD PTR guest+4
 1916      00
 1917 1188 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 1917      000000
 1918 118f 83E2F7   		and	edx, -9
 1919 1192 8890A900 		mov	BYTE PTR [eax+169], dl
 1919      0000
 481:host.c        ****                 guest.vmcb->eventinj.fields.type = 0;
 1920              		.loc 1 481 0
 1921 1198 A1040000 		mov	eax, DWORD PTR guest+4
 1921      00
 1922 119d 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 1922      000000
 1923 11a4 83E2F8   		and	edx, -8
 1924 11a7 8890A900 		mov	BYTE PTR [eax+169], dl
 1924      0000
 482:host.c        ****                 guest.vmcb->eventinj.fields.vector = guest.vmcb->exitcode - 0x40;
 1925              		.loc 1 482 0
 1926 11ad 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1926      0000
 1927 11b3 A1040000 		mov	eax, DWORD PTR guest+4
 1927      00
 1928 11b8 8B5074   		mov	edx, DWORD PTR [eax+116]
 1929 11bb 8B4070   		mov	eax, DWORD PTR [eax+112]
 1930 11be 83E840   		sub	eax, 64
 1931 11c1 8881A800 		mov	BYTE PTR [ecx+168], al
 1931      0000
 483:host.c        ****                 //SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(0 << 11)   | (DWORD)(0
 484:host.c        ****             }
 485:host.c        ****             else if (guest.vmcb->exitcode == VMEXIT_EXCEPTION_BP)   //Breakpoint
 486:host.c        ****             {
 487:host.c        ****                 guest.vmcb->eventinj.fields.v = true;
 488:host.c        ****                 guest.vmcb->eventinj.fields.ev = false;
 489:host.c        ****                 guest.vmcb->eventinj.fields.type = 3;
 490:host.c        ****                 guest.vmcb->eventinj.fields.vector = guest.vmcb->exitcode - 0x40;
 491:host.c        ****                 //SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(0 << 11)   | (DWORD)(3
 492:host.c        ****             }
 493:host.c        ****             else if (guest.vmcb->exitcode == VMEXIT_EXCEPTION_UD)   //Undefined Opcode
 494:host.c        ****             {
 495:host.c        ****                 guest.vmcb->eventinj.fields.v = true;
 496:host.c        ****                 guest.vmcb->eventinj.fields.ev = false;
 497:host.c        ****                 guest.vmcb->eventinj.fields.type = 3;
 498:host.c        ****                 guest.vmcb->eventinj.fields.vector = guest.vmcb->exitcode - 0x40;
 499:host.c        ****                 //SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(0 << 11)  | (DWORD)(3 
 500:host.c        ****             }
 501:host.c        ****             else if (guest.vmcb->exitcode == VMEXIT_EXCEPTION_GP)   //General Protection Fault
 502:host.c        ****             {
 503:host.c        ****                 guest.vmcb->eventinj.fields.v = true;
 504:host.c        ****                 guest.vmcb->eventinj.fields.ev = true;
 505:host.c        ****                 guest.vmcb->eventinj.fields.type = 3;
 506:host.c        ****                 guest.vmcb->eventinj.fields.vector = guest.vmcb->exitcode - 0x40;
 507:host.c        ****                 //SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(1 << 11)  | (DWORD)(3 
 508:host.c        ****                 //If the exception was of an interrupt, add the interrupt info to the exception's e
 509:host.c        ****                 if (guest.vmcb->exitintinfo.fields.v)
 510:host.c        ****                 {
 511:host.c        ****                         guest.vmcb->eventinj.fields.errorcode = (guest.vmcb->exitintinfo.fields.vec
 512:host.c        ****                         guest.vmcb->rip = guest.vmcb->rip - 2;
 513:host.c        ****                 }
 514:host.c        ****                 else
 515:host.c        ****                     guest.vmcb->eventinj.fields.errorcode = guest.vmcb->exitinfo1;
 516:host.c        ****             }                
 517:host.c        ****             break;
 1932              		.loc 1 517 0
 1933 11c7 E9DE0300 		jmp	.L102
 1933      00
 1934              	.L93:
 485:host.c        ****             {
 1935              		.loc 1 485 0
 1936 11cc A1040000 		mov	eax, DWORD PTR guest+4
 1936      00
 1937 11d1 8B5074   		mov	edx, DWORD PTR [eax+116]
 1938 11d4 8B4070   		mov	eax, DWORD PTR [eax+112]
 1939 11d7 89C1     		mov	ecx, eax
 1940 11d9 83F143   		xor	ecx, 67
 1941 11dc 09D1     		or	ecx, edx
 1942 11de 89C8     		mov	eax, ecx
 1943 11e0 85C0     		test	eax, eax
 1944 11e2 7561     		jne	.L95
 487:host.c        ****                 guest.vmcb->eventinj.fields.ev = false;
 1945              		.loc 1 487 0
 1946 11e4 A1040000 		mov	eax, DWORD PTR guest+4
 1946      00
 1947 11e9 0FB690AB 		movzx	edx, BYTE PTR [eax+171]
 1947      000000
 1948 11f0 83CA80   		or	edx, -128
 1949 11f3 8890AB00 		mov	BYTE PTR [eax+171], dl
 1949      0000
 488:host.c        ****                 guest.vmcb->eventinj.fields.type = 3;
 1950              		.loc 1 488 0
 1951 11f9 A1040000 		mov	eax, DWORD PTR guest+4
 1951      00
 1952 11fe 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 1952      000000
 1953 1205 83E2F7   		and	edx, -9
 1954 1208 8890A900 		mov	BYTE PTR [eax+169], dl
 1954      0000
 489:host.c        ****                 guest.vmcb->eventinj.fields.vector = guest.vmcb->exitcode - 0x40;
 1955              		.loc 1 489 0
 1956 120e A1040000 		mov	eax, DWORD PTR guest+4
 1956      00
 1957 1213 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 1957      000000
 1958 121a 83E2F8   		and	edx, -8
 1959 121d 83CA03   		or	edx, 3
 1960 1220 8890A900 		mov	BYTE PTR [eax+169], dl
 1960      0000
 490:host.c        ****                 //SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(0 << 11)   | (DWORD)(3
 1961              		.loc 1 490 0
 1962 1226 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1962      0000
 1963 122c A1040000 		mov	eax, DWORD PTR guest+4
 1963      00
 1964 1231 8B5074   		mov	edx, DWORD PTR [eax+116]
 1965 1234 8B4070   		mov	eax, DWORD PTR [eax+112]
 1966 1237 83E840   		sub	eax, 64
 1967 123a 8881A800 		mov	BYTE PTR [ecx+168], al
 1967      0000
 1968              		.loc 1 517 0
 1969 1240 E9650300 		jmp	.L102
 1969      00
 1970              	.L95:
 493:host.c        ****             {
 1971              		.loc 1 493 0
 1972 1245 A1040000 		mov	eax, DWORD PTR guest+4
 1972      00
 1973 124a 8B5074   		mov	edx, DWORD PTR [eax+116]
 1974 124d 8B4070   		mov	eax, DWORD PTR [eax+112]
 1975 1250 89C1     		mov	ecx, eax
 1976 1252 83F146   		xor	ecx, 70
 1977 1255 09D1     		or	ecx, edx
 1978 1257 89C8     		mov	eax, ecx
 1979 1259 85C0     		test	eax, eax
 1980 125b 7561     		jne	.L96
 495:host.c        ****                 guest.vmcb->eventinj.fields.ev = false;
 1981              		.loc 1 495 0
 1982 125d A1040000 		mov	eax, DWORD PTR guest+4
 1982      00
 1983 1262 0FB690AB 		movzx	edx, BYTE PTR [eax+171]
 1983      000000
 1984 1269 83CA80   		or	edx, -128
 1985 126c 8890AB00 		mov	BYTE PTR [eax+171], dl
 1985      0000
 496:host.c        ****                 guest.vmcb->eventinj.fields.type = 3;
 1986              		.loc 1 496 0
 1987 1272 A1040000 		mov	eax, DWORD PTR guest+4
 1987      00
 1988 1277 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 1988      000000
 1989 127e 83E2F7   		and	edx, -9
 1990 1281 8890A900 		mov	BYTE PTR [eax+169], dl
 1990      0000
 497:host.c        ****                 guest.vmcb->eventinj.fields.vector = guest.vmcb->exitcode - 0x40;
 1991              		.loc 1 497 0
 1992 1287 A1040000 		mov	eax, DWORD PTR guest+4
 1992      00
 1993 128c 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 1993      000000
 1994 1293 83E2F8   		and	edx, -8
 1995 1296 83CA03   		or	edx, 3
 1996 1299 8890A900 		mov	BYTE PTR [eax+169], dl
 1996      0000
 498:host.c        ****                 //SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(0 << 11)  | (DWORD)(3 
 1997              		.loc 1 498 0
 1998 129f 8B0D0400 		mov	ecx, DWORD PTR guest+4
 1998      0000
 1999 12a5 A1040000 		mov	eax, DWORD PTR guest+4
 1999      00
 2000 12aa 8B5074   		mov	edx, DWORD PTR [eax+116]
 2001 12ad 8B4070   		mov	eax, DWORD PTR [eax+112]
 2002 12b0 83E840   		sub	eax, 64
 2003 12b3 8881A800 		mov	BYTE PTR [ecx+168], al
 2003      0000
 2004              		.loc 1 517 0
 2005 12b9 E9EC0200 		jmp	.L102
 2005      00
 2006              	.L96:
 501:host.c        ****             {
 2007              		.loc 1 501 0
 2008 12be A1040000 		mov	eax, DWORD PTR guest+4
 2008      00
 2009 12c3 8B5074   		mov	edx, DWORD PTR [eax+116]
 2010 12c6 8B4070   		mov	eax, DWORD PTR [eax+112]
 2011 12c9 89C1     		mov	ecx, eax
 2012 12cb 83F14D   		xor	ecx, 77
 2013 12ce 09D1     		or	ecx, edx
 2014 12d0 89C8     		mov	eax, ecx
 2015 12d2 85C0     		test	eax, eax
 2016 12d4 0F85D002 		jne	.L102
 2016      0000
 503:host.c        ****                 guest.vmcb->eventinj.fields.ev = true;
 2017              		.loc 1 503 0
 2018 12da A1040000 		mov	eax, DWORD PTR guest+4
 2018      00
 2019 12df 0FB690AB 		movzx	edx, BYTE PTR [eax+171]
 2019      000000
 2020 12e6 83CA80   		or	edx, -128
 2021 12e9 8890AB00 		mov	BYTE PTR [eax+171], dl
 2021      0000
 504:host.c        ****                 guest.vmcb->eventinj.fields.type = 3;
 2022              		.loc 1 504 0
 2023 12ef A1040000 		mov	eax, DWORD PTR guest+4
 2023      00
 2024 12f4 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 2024      000000
 2025 12fb 83CA08   		or	edx, 8
 2026 12fe 8890A900 		mov	BYTE PTR [eax+169], dl
 2026      0000
 505:host.c        ****                 guest.vmcb->eventinj.fields.vector = guest.vmcb->exitcode - 0x40;
 2027              		.loc 1 505 0
 2028 1304 A1040000 		mov	eax, DWORD PTR guest+4
 2028      00
 2029 1309 0FB690A9 		movzx	edx, BYTE PTR [eax+169]
 2029      000000
 2030 1310 83E2F8   		and	edx, -8
 2031 1313 83CA03   		or	edx, 3
 2032 1316 8890A900 		mov	BYTE PTR [eax+169], dl
 2032      0000
 506:host.c        ****                 //SetVMCBD(VMCB_CONTROL_EVENTINJ, (DWORD)(1 << 31) | (DWORD)(1 << 11)  | (DWORD)(3 
 2033              		.loc 1 506 0
 2034 131c 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2034      0000
 2035 1322 A1040000 		mov	eax, DWORD PTR guest+4
 2035      00
 2036 1327 8B5074   		mov	edx, DWORD PTR [eax+116]
 2037 132a 8B4070   		mov	eax, DWORD PTR [eax+112]
 2038 132d 83E840   		sub	eax, 64
 2039 1330 8881A800 		mov	BYTE PTR [ecx+168], al
 2039      0000
 509:host.c        ****                 {
 2040              		.loc 1 509 0
 2041 1336 A1040000 		mov	eax, DWORD PTR guest+4
 2041      00
 2042 133b 0FB6808B 		movzx	eax, BYTE PTR [eax+139]
 2042      000000
 2043 1342 83E080   		and	eax, -128
 2044 1345 84C0     		test	al, al
 2045 1347 744F     		je	.L97
 511:host.c        ****                         guest.vmcb->rip = guest.vmcb->rip - 2;
 2046              		.loc 1 511 0
 2047 1349 A1040000 		mov	eax, DWORD PTR guest+4
 2047      00
 2048 134e 8B150400 		mov	edx, DWORD PTR guest+4
 2048      0000
 2049 1354 0FB69288 		movzx	edx, BYTE PTR [edx+136]
 2049      000000
 2050 135b 0FB6D2   		movzx	edx, dl
 2051 135e C1E203   		sal	edx, 3
 2052 1361 83C202   		add	edx, 2
 2053 1364 8990AC00 		mov	DWORD PTR [eax+172], edx
 2053      0000
 512:host.c        ****                 }
 2054              		.loc 1 512 0
 2055 136a 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2055      0000
 2056 1370 A1040000 		mov	eax, DWORD PTR guest+4
 2056      00
 2057 1375 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 2057      0000
 2058 137b 8B807805 		mov	eax, DWORD PTR [eax+1400]
 2058      0000
 2059 1381 83C0FE   		add	eax, -2
 2060 1384 83D2FF   		adc	edx, -1
 2061 1387 89817805 		mov	DWORD PTR [ecx+1400], eax
 2061      0000
 2062 138d 89917C05 		mov	DWORD PTR [ecx+1404], edx
 2062      0000
 2063              		.loc 1 517 0
 2064 1393 E9120200 		jmp	.L102
 2064      00
 2065              	.L97:
 515:host.c        ****             }                
 2066              		.loc 1 515 0
 2067 1398 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2067      0000
 2068 139e A1040000 		mov	eax, DWORD PTR guest+4
 2068      00
 2069 13a3 8B507C   		mov	edx, DWORD PTR [eax+124]
 2070 13a6 8B4078   		mov	eax, DWORD PTR [eax+120]
 2071 13a9 8981AC00 		mov	DWORD PTR [ecx+172], eax
 2071      0000
 2072              		.loc 1 517 0
 2073 13af E9F60100 		jmp	.L102
 2073      00
 2074              	.L85:
 518:host.c        ****         case VMEXIT_HLT:
 519:host.c        ****             if ( (guest.vmcb->rflags & 0x200) != 0x200)
 2075              		.loc 1 519 0
 2076 13b4 A1040000 		mov	eax, DWORD PTR guest+4
 2076      00
 2077 13b9 8B907405 		mov	edx, DWORD PTR [eax+1396]
 2077      0000
 2078 13bf 8B807005 		mov	eax, DWORD PTR [eax+1392]
 2078      0000
 2079 13c5 89C3     		mov	ebx, eax
 2080 13c7 81E30002 		and	ebx, 512
 2080      0000
 2081 13cd 895DD0   		mov	DWORD PTR [ebp-48], ebx
 2082 13d0 89D0     		mov	eax, edx
 2083 13d2 83E000   		and	eax, 0
 2084 13d5 8945D4   		mov	DWORD PTR [ebp-44], eax
 2085 13d8 8B5DD0   		mov	ebx, DWORD PTR [ebp-48]
 2086 13db 8B75D4   		mov	esi, DWORD PTR [ebp-44]
 2087 13de 89F0     		mov	eax, esi
 2088 13e0 09D8     		or	eax, ebx
 2089 13e2 85C0     		test	eax, eax
 2090 13e4 752B     		jne	.L98
 520:host.c        ****             {
 521:host.c        ****                 printAt("VISOR: HLT called with IF=0\0",0,1);
 2091              		.loc 1 521 0
 2092 13e6 83EC04   		sub	esp, 4
 2093 13e9 6A01     		push	1
 2094 13eb 6A00     		push	0
 2095 13ed 680D0200 		push	OFFSET FLAT:.LC25
 2095      00
 2096 13f2 E8FCFFFF 		call	printAt
 2096      FF
 2097 13f7 83C410   		add	esp, 16
 522:host.c        ****                 InfiniteLoop(guest.vmcb->exitcode);
 2098              		.loc 1 522 0
 2099 13fa A1040000 		mov	eax, DWORD PTR guest+4
 2099      00
 2100 13ff 8B5074   		mov	edx, DWORD PTR [eax+116]
 2101 1402 8B4070   		mov	eax, DWORD PTR [eax+112]
 2102 1405 83EC0C   		sub	esp, 12
 2103 1408 50       		push	eax
 2104 1409 E8FCFFFF 		call	InfiniteLoop
 2104      FF
 2105 140e 83C410   		add	esp, 16
 2106              	.L98:
 523:host.c        ****             }
 524:host.c        ****             guest.vmcb->rip = guest.vmcb->nextrip;
 2107              		.loc 1 524 0
 2108 1411 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2108      0000
 2109 1417 A1040000 		mov	eax, DWORD PTR guest+4
 2109      00
 2110 141c 8B90CC00 		mov	edx, DWORD PTR [eax+204]
 2110      0000
 2111 1422 8B80C800 		mov	eax, DWORD PTR [eax+200]
 2111      0000
 2112 1428 89817805 		mov	DWORD PTR [ecx+1400], eax
 2112      0000
 2113 142e 89917C05 		mov	DWORD PTR [ecx+1404], edx
 2113      0000
 525:host.c        ****             break;
 2114              		.loc 1 525 0
 2115 1434 E9720100 		jmp	.L88
 2115      00
 2116              	.L77:
 526:host.c        ****         case VMEXIT_NMI:
 527:host.c        ****             printAt("     VISOR: NMI intercepted, something broke!!!",0,1);
 2117              		.loc 1 527 0
 2118 1439 83EC04   		sub	esp, 4
 2119 143c 6A01     		push	1
 2120 143e 6A00     		push	0
 2121 1440 682C0200 		push	OFFSET FLAT:.LC26
 2121      00
 2122 1445 E8FCFFFF 		call	printAt
 2122      FF
 2123 144a 83C410   		add	esp, 16
 528:host.c        ****             InfiniteLoop(guest.vmcb->exitcode);
 2124              		.loc 1 528 0
 2125 144d A1040000 		mov	eax, DWORD PTR guest+4
 2125      00
 2126 1452 8B5074   		mov	edx, DWORD PTR [eax+116]
 2127 1455 8B4070   		mov	eax, DWORD PTR [eax+112]
 2128 1458 83EC0C   		sub	esp, 12
 2129 145b 50       		push	eax
 2130 145c E8FCFFFF 		call	InfiniteLoop
 2130      FF
 2131 1461 83C410   		add	esp, 16
 2132              	.L80:
 529:host.c        ****         case VMEXIT_CPUID:
 530:host.c        ****             //We only want to fulfill requests where EAX=1
 531:host.c        ****             if (guest.vmcb->rax == 0x0)
 2133              		.loc 1 531 0
 2134 1464 A1040000 		mov	eax, DWORD PTR guest+4
 2134      00
 2135 1469 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2135      0000
 2136 146f 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2136      0000
 2137 1475 09D0     		or	eax, edx
 2138 1477 85C0     		test	eax, eax
 2139 1479 751E     		jne	.L99
 532:host.c        ****                 guest.vmcb->rax = 0x1;
 2140              		.loc 1 532 0
 2141 147b A1040000 		mov	eax, DWORD PTR guest+4
 2141      00
 2142 1480 C780F805 		mov	DWORD PTR [eax+1528], 1
 2142      00000100 
 2142      0000
 2143 148a C780FC05 		mov	DWORD PTR [eax+1532], 0
 2143      00000000 
 2143      0000
 2144 1494 E98F0000 		jmp	.L100
 2144      00
 2145              	.L99:
 2146              	.LBB2:
 533:host.c        ****             else
 534:host.c        ****             {
 535:host.c        ****                 bool bUpdateDX = (guest.vmcb->rax & 0xFF) == 0x1?true:false;
 2147              		.loc 1 535 0
 2148 1499 A1040000 		mov	eax, DWORD PTR guest+4
 2148      00
 2149 149e 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2149      0000
 2150 14a4 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2150      0000
 2151 14aa 0FB6D8   		movzx	ebx, al
 2152 14ad 895DC8   		mov	DWORD PTR [ebp-56], ebx
 2153 14b0 89D0     		mov	eax, edx
 2154 14b2 83E000   		and	eax, 0
 2155 14b5 8945CC   		mov	DWORD PTR [ebp-52], eax
 2156 14b8 8B45C8   		mov	eax, DWORD PTR [ebp-56]
 2157 14bb 8B55CC   		mov	edx, DWORD PTR [ebp-52]
 2158 14be 89C6     		mov	esi, eax
 2159 14c0 83F601   		xor	esi, 1
 2160 14c3 8975C0   		mov	DWORD PTR [ebp-64], esi
 2161 14c6 89D0     		mov	eax, edx
 2162 14c8 80F400   		xor	ah, 0
 2163 14cb 8945C4   		mov	DWORD PTR [ebp-60], eax
 2164 14ce 8B5DC0   		mov	ebx, DWORD PTR [ebp-64]
 2165 14d1 8B75C4   		mov	esi, DWORD PTR [ebp-60]
 2166 14d4 89D8     		mov	eax, ebx
 2167 14d6 09F0     		or	eax, esi
 2168 14d8 85C0     		test	eax, eax
 2169 14da 0F94C0   		sete	al
 2170 14dd 8845F2   		mov	BYTE PTR [ebp-14], al
 536:host.c        ****                 HandleGuestCPUID((int)guest.vmcb->rax, (DWORD*)&guest.vmcb->rax, &GuestRegisters[RA
 2171              		.loc 1 536 0
 2172 14e0 A1040000 		mov	eax, DWORD PTR guest+4
 2172      00
 2173 14e5 8D88F805 		lea	ecx, [eax+1528]
 2173      0000
 2174 14eb A1040000 		mov	eax, DWORD PTR guest+4
 2174      00
 2175 14f0 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 2175      0000
 2176 14f6 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 2176      0000
 2177 14fc 83EC0C   		sub	esp, 12
 2178 14ff 68080000 		push	OFFSET FLAT:GuestRegisters+8
 2178      00
 2179 1504 68040000 		push	OFFSET FLAT:GuestRegisters+4
 2179      00
 2180 1509 68000000 		push	OFFSET FLAT:GuestRegisters
 2180      00
 2181 150e 51       		push	ecx
 2182 150f 50       		push	eax
 2183 1510 E8FCFFFF 		call	HandleGuestCPUID
 2183      FF
 2184 1515 83C420   		add	esp, 32
 537:host.c        ****                 if ( bUpdateDX)
 2185              		.loc 1 537 0
 2186 1518 807DF200 		cmp	BYTE PTR [ebp-14], 0
 2187 151c 740A     		je	.L100
 538:host.c        ****                 {
 539:host.c        ****                     GuestRegisters[RAN_EDX] = 0x33; //FPU, VME, TSC, MSR
 2188              		.loc 1 539 0
 2189 151e C7050800 		mov	DWORD PTR GuestRegisters+8, 51
 2189      00003300 
 2189      0000
 2190              	.L100:
 2191              	.LBE2:
 540:host.c        ****                 }
 541:host.c        ****             }
 542:host.c        ****             guest.vmcb->rip = guest.vmcb->nextrip;
 2192              		.loc 1 542 0
 2193 1528 8B0D0400 		mov	ecx, DWORD PTR guest+4
 2193      0000
 2194 152e A1040000 		mov	eax, DWORD PTR guest+4
 2194      00
 2195 1533 8B90CC00 		mov	edx, DWORD PTR [eax+204]
 2195      0000
 2196 1539 8B80C800 		mov	eax, DWORD PTR [eax+200]
 2196      0000
 2197 153f 89817805 		mov	DWORD PTR [ecx+1400], eax
 2197      0000
 2198 1545 89917C05 		mov	DWORD PTR [ecx+1404], edx
 2198      0000
 543:host.c        ****             break;
 2199              		.loc 1 543 0
 2200 154b EB5E     		jmp	.L88
 2201              	.L57:
 544:host.c        ****         default:
 545:host.c        ****             printAt("Unhandled Intercept: ",0,7);
 2202              		.loc 1 545 0
 2203 154d 83EC04   		sub	esp, 4
 2204 1550 6A07     		push	7
 2205 1552 6A00     		push	0
 2206 1554 685C0200 		push	OFFSET FLAT:.LC27
 2206      00
 2207 1559 E8FCFFFF 		call	printAt
 2207      FF
 2208 155e 83C410   		add	esp, 16
 546:host.c        ****             pErr = Itoa(guest.vmcb->exitcode, pErr, 16);
 2209              		.loc 1 546 0
 2210 1561 A1040000 		mov	eax, DWORD PTR guest+4
 2210      00
 2211 1566 8B5074   		mov	edx, DWORD PTR [eax+116]
 2212 1569 8B4070   		mov	eax, DWORD PTR [eax+112]
 2213 156c 83EC04   		sub	esp, 4
 2214 156f 6A10     		push	16
 2215 1571 FF75F4   		push	DWORD PTR [ebp-12]
 2216 1574 50       		push	eax
 2217 1575 E8FCFFFF 		call	Itoa
 2217      FF
 2218 157a 83C410   		add	esp, 16
 2219 157d 8945F4   		mov	DWORD PTR [ebp-12], eax
 547:host.c        ****             print(pErr);
 2220              		.loc 1 547 0
 2221 1580 83EC0C   		sub	esp, 12
 2222 1583 FF75F4   		push	DWORD PTR [ebp-12]
 2223 1586 E8FCFFFF 		call	print
 2223      FF
 2224 158b 83C410   		add	esp, 16
 548:host.c        ****             InfiniteLoop(guest.vmcb->exitcode);
 2225              		.loc 1 548 0
 2226 158e A1040000 		mov	eax, DWORD PTR guest+4
 2226      00
 2227 1593 8B5074   		mov	edx, DWORD PTR [eax+116]
 2228 1596 8B4070   		mov	eax, DWORD PTR [eax+112]
 2229 1599 83EC0C   		sub	esp, 12
 2230 159c 50       		push	eax
 2231 159d E8FCFFFF 		call	InfiniteLoop
 2231      FF
 2232 15a2 83C410   		add	esp, 16
 549:host.c        ****             break;
 2233              		.loc 1 549 0
 2234 15a5 EB04     		jmp	.L88
 2235              	.L101:
 356:host.c        ****         case VMEXIT_EXCEPTION_PF:
 2236              		.loc 1 356 0
 2237 15a7 90       		nop
 2238 15a8 EB01     		jmp	.L88
 2239              	.L102:
 517:host.c        ****         case VMEXIT_HLT:
 2240              		.loc 1 517 0
 2241 15aa 90       		nop
 2242              	.L88:
 550:host.c        ****     }
 551:host.c        ****     asm("STGI\n");
 2243              		.loc 1 551 0
 2244              	#APP
 2245              	# 551 "host.c" 1
 552              	    asm("STI\n");
 553              	//        HostScancode = 0;
 552:host.c        **** //        HostScancode = 0;
 2246              		STGI
 2247              	
 2248              	# 0 "" 2
 2249              		.loc 1 552 0
 2250              	# 552 "host.c" 1
 554              	//    while (HostScancode == 0) {}
 555:host.c        ****     asm("CLI\n");
 2251              		STI
 2252              	
 2253              	# 0 "" 2
 2254              		.loc 1 555 0
 2255              	# 555 "host.c" 1
 556              	    asm("CLGI\n");
 557              	
 556:host.c        **** 
 2256              		CLI
 2257              	
 2258              	# 0 "" 2
 2259              		.loc 1 556 0
 2260              	# 556 "host.c" 1
 558              	}
 2261              		CLGI
 2262              	
 2263              	# 0 "" 2
 2264              		.loc 1 558 0
 2265              	#NO_APP
 2266 15b3 90       		nop
 2267 15b4 8D65F8   		lea	esp, [ebp-8]
 2268 15b7 5B       		pop	ebx
 2269              		.cfi_restore 3
 2270 15b8 5E       		pop	esi
 2271              		.cfi_restore 6
 2272 15b9 5D       		pop	ebp
 2273              		.cfi_restore 5
 2274              		.cfi_def_cfa 4, 4
 2275 15ba C3       		ret
 2276              		.cfi_endproc
 2277              	.LFE7:
 2279              		.section	.rodata
 2280 0272 0000     		.align 4
 2281              	.LC28:
 2282 0274 456E7465 		.string	"Entering main visor loop             "
 2282      72696E67 
 2282      206D6169 
 2282      6E207669 
 2282      736F7220 
 2283              		.text
 2284              		.globl	DoVisor
 2286              	DoVisor:
 2287              	.LFB8:
 559:host.c        **** 
 560:host.c        **** void DoVisor()
 561:host.c        **** {
 2288              		.loc 1 561 0
 2289              		.cfi_startproc
 2290 15bb 55       		push	ebp
 2291              		.cfi_def_cfa_offset 8
 2292              		.cfi_offset 5, -8
 2293 15bc 89E5     		mov	ebp, esp
 2294              		.cfi_def_cfa_register 5
 2295 15be 53       		push	ebx
 2296 15bf 83EC04   		sub	esp, 4
 2297              		.cfi_offset 3, -12
 562:host.c        ****     VMCBFinalAddress = (vhost.CodeBase + vhost.VMCBOffset);
 2298              		.loc 1 562 0
 2299 15c2 8B150000 		mov	edx, DWORD PTR vhost
 2299      0000
 2300 15c8 A1080000 		mov	eax, DWORD PTR vhost+8
 2300      00
 2301 15cd 01D0     		add	eax, edx
 2302 15cf A3000000 		mov	DWORD PTR VMCBFinalAddress, eax
 2302      00
 563:host.c        ****     clrscr();
 2303              		.loc 1 563 0
 2304 15d4 E8FCFFFF 		call	clrscr
 2304      FF
 564:host.c        ****     //Initialize the SVM host save memory location
 565:host.c        ****     cpu_write_msr(MSR_K8_VM_HSAVE_PA,vhost.CodeBase + vhost.HostSaveArea);
 2305              		.loc 1 565 0
 2306 15d9 8B150000 		mov	edx, DWORD PTR vhost
 2306      0000
 2307 15df A1180000 		mov	eax, DWORD PTR vhost+24
 2307      00
 2308 15e4 01D0     		add	eax, edx
 2309 15e6 BA000000 		mov	edx, 0
 2309      00
 2310 15eb 83EC04   		sub	esp, 4
 2311 15ee 52       		push	edx
 2312 15ef 50       		push	eax
 2313 15f0 68170101 		push	-1073676009
 2313      C0
 2314 15f5 E8FCFFFF 		call	cpu_write_msr
 2314      FF
 2315 15fa 83C410   		add	esp, 16
 566:host.c        **** #ifdef __BOOT_FROM_HD__
 567:host.c        ****                 GuestRegisters[2] = 0x80;      //DX = 80 for hd
 2316              		.loc 1 567 0
 2317 15fd C7050800 		mov	DWORD PTR GuestRegisters+8, 128
 2317      00008000 
 2317      0000
 568:host.c        **** #else
 569:host.c        ****                 GuestRegisters[2] = 0x0;      //DX = 0 for floppy drive
 570:host.c        **** #endif
 571:host.c        **** 
 572:host.c        ****     printAt("Entering main visor loop             ",0,1);
 2318              		.loc 1 572 0
 2319 1607 83EC04   		sub	esp, 4
 2320 160a 6A01     		push	1
 2321 160c 6A00     		push	0
 2322 160e 68740200 		push	OFFSET FLAT:.LC28
 2322      00
 2323 1613 E8FCFFFF 		call	printAt
 2323      FF
 2324 1618 83C410   		add	esp, 16
 2325              	.L105:
 573:host.c        ****     while (1)
 574:host.c        ****     {
 575:host.c        ****         asm("mov HostRegisters+0, EBX\n"
 2326              		.loc 1 575 0
 2327              	#APP
 2328              	# 575 "host.c" 1
 576 1621 890D0400 	            "mov HostRegisters+4, ECX\n"
 576      0000
 577 1627 89150800 	            "mov HostRegisters+8, EDX\n"
 577      0000
 578 162d 89350C00 	            "mov HostRegisters+12, ESI\n"
 578      0000
 579 1633 893D1000 	            "mov HostRegisters+16, EDI\n"
 579      0000
 580 1639 892D1400 	            "mov HostRegisters+20, EBP\n");
 580      0000
 581              	        
 582              	        if (InterceptCount++ == 0)
 2329              		mov HostRegisters+0, EBX
 2330              	mov HostRegisters+4, ECX
 2331              	mov HostRegisters+8, EDX
 2332              	mov HostRegisters+12, ESI
 2333              	mov HostRegisters+16, EDI
 2334              	mov HostRegisters+20, EBP
 2335              	
 2336              	# 0 "" 2
 2337              		.loc 1 582 0
 2338              	#NO_APP
 2339 163f A1000000 		mov	eax, DWORD PTR InterceptCount
 2339      00
 2340 1644 8B150400 		mov	edx, DWORD PTR InterceptCount+4
 2340      0000
 2341 164a 89C1     		mov	ecx, eax
 2342 164c 89D3     		mov	ebx, edx
 2343 164e 83C101   		add	ecx, 1
 2344 1651 83D300   		adc	ebx, 0
 2345 1654 890D0000 		mov	DWORD PTR InterceptCount, ecx
 2345      0000
 2346 165a 891D0400 		mov	DWORD PTR InterceptCount+4, ebx
 2346      0000
 2347 1660 09D0     		or	eax, edx
 2348 1662 85C0     		test	eax, eax
 2349 1664 7508     		jne	.L104
 583:host.c        ****         {
 584:host.c        ****             asm("mov eax,VMCBFinalAddress");
 2350              		.loc 1 584 0
 2351              	#APP
 2352              	# 584 "host.c" 1
 585              	            asm("vmload");
 2353              		mov eax,VMCBFinalAddress
 2354              	# 0 "" 2
 2355              		.loc 1 585 0
 2356              	# 585 "host.c" 1
 586              	        }
 2357              		vmload
 2358              	# 0 "" 2
 2359              	#NO_APP
 2360              	.L104:
 587:host.c        ****         
 588:host.c        **** 
 589:host.c        ****         asm("mov eax,VMCBFinalAddress");
 2361              		.loc 1 589 0
 2362              	#APP
 2363              	# 589 "host.c" 1
 590              	        
 591:host.c        ****         		//Load the guest registers
 592:host.c        ****         asm("mov EBX, GuestRegisters+0\n"
 2364              		mov eax,VMCBFinalAddress
 2365              	# 0 "" 2
 2366              		.loc 1 592 0
 2367              	# 592 "host.c" 1
 593 1679 8B0D0400 	            "mov ECX, GuestRegisters+4\n"
 593      0000
 594 167f 8B150800 	            "mov EDX, GuestRegisters+8\n"
 594      0000
 595 1685 8B350C00 	            "mov ESI, GuestRegisters+12\n"
 595      0000
 596 168b 8B3D1000 	            "mov EDI, GuestRegisters+16\n"
 596      0000
 597 1691 8B2D1400 	            "mov EBP, GuestRegisters+20\n");
 597      0000
 598              	
 599              	        asm("vmload\n");
 2368              		mov EBX, GuestRegisters+0
 2369              	mov ECX, GuestRegisters+4
 2370              	mov EDX, GuestRegisters+8
 2371              	mov ESI, GuestRegisters+12
 2372              	mov EDI, GuestRegisters+16
 2373              	mov EBP, GuestRegisters+20
 2374              	
 2375              	# 0 "" 2
 2376              		.loc 1 599 0
 2377              	# 599 "host.c" 1
 600              	//asm("xchgw bx,bx\n");
 601              	        asm("vmrun");
 2378              		vmload
 2379              	
 2380              	# 0 "" 2
 2381              		.loc 1 601 0
 2382              	# 601 "host.c" 1
 602              	        asm("vmsave\n");
 2383              		vmrun
 2384              	# 0 "" 2
 2385              		.loc 1 602 0
 2386              	# 602 "host.c" 1
 603              	//asm("xchgw bx,bx\n");
 604              	        //Save the guest registers
 605:host.c        ****         asm("mov GuestRegisters+0, EBX\n"
 2387              		vmsave
 2388              	
 2389              	# 0 "" 2
 2390              		.loc 1 605 0
 2391              	# 605 "host.c" 1
 606 16a6 890D0400 	            "mov GuestRegisters+4, ECX\n"
 606      0000
 607 16ac 89150800 	            "mov GuestRegisters+8, EDX\n"
 607      0000
 608 16b2 89350C00 	            "mov GuestRegisters+12, ESI\n"
 608      0000
 609 16b8 893D1000 	            "mov GuestRegisters+16, EDI\n"
 609      0000
 610 16be 892D1400 	            "mov GuestRegisters+20, EBP\n");
 610      0000
 611              	        
 612              	        //Load the host registers
 613:host.c        ****         asm("mov EBX, HostRegisters+0\n"
 2392              		mov GuestRegisters+0, EBX
 2393              	mov GuestRegisters+4, ECX
 2394              	mov GuestRegisters+8, EDX
 2395              	mov GuestRegisters+12, ESI
 2396              	mov GuestRegisters+16, EDI
 2397              	mov GuestRegisters+20, EBP
 2398              	
 2399              	# 0 "" 2
 2400              		.loc 1 613 0
 2401              	# 613 "host.c" 1
 614 16ca 8B0D0400 	            "mov ECX, HostRegisters+4\n"
 614      0000
 615 16d0 8B150800 	            "mov EDX, HostRegisters+8\n"
 615      0000
 616 16d6 8B350C00 	            "mov ESI, HostRegisters+12\n"
 616      0000
 617 16dc 8B3D1000 	            "mov EDI, HostRegisters+16\n"
 617      0000
 618 16e2 8B2D1400 	            "mov EBP, HostRegisters+20\n");
 618      0000
 619              	        
 620              	        asm("mov eax,%[fsVal]\n"
 2402              		mov EBX, HostRegisters+0
 2403              	mov ECX, HostRegisters+4
 2404              	mov EDX, HostRegisters+8
 2405              	mov ESI, HostRegisters+12
 2406              	mov EDI, HostRegisters+16
 2407              	mov EBP, HostRegisters+20
 2408              	
 2409              	# 0 "" 2
 2410              		.loc 1 620 0
 2411              	#NO_APP
 2412 16e8 B8100000 		mov	eax, 16
 2412      00
 2413 16ed BA380000 		mov	edx, 56
 2413      00
 2414              	#APP
 2415              	# 620 "host.c" 1
 621 16f4 50       	            "push eax\n pop fs\n"
 622 16f5 0FA1     	            "mov eax,%[gsVal]\n"
 623 16f7 89D0     	            "push eax\n pop gs\n"
 624 16f9 50       	            :: [fsVal] "r" (SELECTOR_ALL_MEM),
 625 16fa 0FA9     	               [gsVal] "r" (SELECTOR_VISOR_DATA) );
 626              	        ProcessVMRunResults();
 627              	    }
 626:host.c        ****     }
 2416              		mov eax,eax
 2417              	push eax
 2418              	 pop fs
 2419              	mov eax,edx
 2420              	push eax
 2421              	 pop gs
 2422              	
 2423              	# 0 "" 2
 2424              		.loc 1 626 0
 2425              	#NO_APP
 2426 16fc E8FCFFFF 		call	ProcessVMRunResults
 2426      FF
 2427              		.loc 1 627 0
 2428 1701 E915FFFF 		jmp	.L105
 2428      FF
 2429              		.cfi_endproc
 2430              	.LFE8:
 2432              		.section	.rodata
 2433 029a 0000     		.align 4
 2434              	.LC29:
 2435 029c 496E2074 		.string	"In the toilet (aka infinite loop) from intercept code: 0x"
 2435      68652074 
 2435      6F696C65 
 2435      74202861 
 2435      6B612069 
 2436              	.LC30:
 2437 02d6 42797465 		.string	"Bytes at CS:IP: "
 2437      73206174 
 2437      2043533A 
 2437      49503A20 
 2437      00
 2438              	.LC31:
 2439 02e7 2000     		.string	" "
 2440              	.LC32:
 2441 02e9 41323020 		.string	"A20 Value: "
 2441      56616C75 
 2441      653A2000 
 2442              		.text
 2443              		.globl	InfiniteLoop
 2445              	InfiniteLoop:
 2446              	.LFB9:
 628:host.c        ****     
 629:host.c        ****     
 630:host.c        **** }
 631:host.c        **** 
 632:host.c        **** void InfiniteLoop(int InterceptCode)
 633:host.c        **** {
 2447              		.loc 1 633 0
 2448              		.cfi_startproc
 2449 1706 55       		push	ebp
 2450              		.cfi_def_cfa_offset 8
 2451              		.cfi_offset 5, -8
 2452 1707 89E5     		mov	ebp, esp
 2453              		.cfi_def_cfa_register 5
 2454 1709 83EC18   		sub	esp, 24
 634:host.c        **** char *pErr = "                    \0";
 2455              		.loc 1 634 0
 2456 170c C745F4C9 		mov	DWORD PTR [ebp-12], OFFSET FLAT:.LC3
 2456      000000
 635:host.c        **** int cnt = 0;
 2457              		.loc 1 635 0
 2458 1713 C745F000 		mov	DWORD PTR [ebp-16], 0
 2458      000000
 636:host.c        **** 
 637:host.c        **** 	gInterceptCode = InterceptCode;
 2459              		.loc 1 637 0
 2460 171a 8B4508   		mov	eax, DWORD PTR [ebp+8]
 2461 171d A3000000 		mov	DWORD PTR gInterceptCode, eax
 2461      00
 638:host.c        ****         printAt("In the toilet (aka infinite loop) from intercept code: 0x",0,21);
 2462              		.loc 1 638 0
 2463 1722 83EC04   		sub	esp, 4
 2464 1725 6A15     		push	21
 2465 1727 6A00     		push	0
 2466 1729 689C0200 		push	OFFSET FLAT:.LC29
 2466      00
 2467 172e E8FCFFFF 		call	printAt
 2467      FF
 2468 1733 83C410   		add	esp, 16
 639:host.c        **** 	pErr = Itoa(InterceptCode, pErr, 16);
 2469              		.loc 1 639 0
 2470 1736 83EC04   		sub	esp, 4
 2471 1739 6A10     		push	16
 2472 173b FF75F4   		push	DWORD PTR [ebp-12]
 2473 173e FF7508   		push	DWORD PTR [ebp+8]
 2474 1741 E8FCFFFF 		call	Itoa
 2474      FF
 2475 1746 83C410   		add	esp, 16
 2476 1749 8945F4   		mov	DWORD PTR [ebp-12], eax
 640:host.c        **** 	print(pErr);
 2477              		.loc 1 640 0
 2478 174c 83EC0C   		sub	esp, 12
 2479 174f FF75F4   		push	DWORD PTR [ebp-12]
 2480 1752 E8FCFFFF 		call	print
 2480      FF
 2481 1757 83C410   		add	esp, 16
 641:host.c        **** 	printAt("CR0 value: ",0,17);
 2482              		.loc 1 641 0
 2483 175a 83EC04   		sub	esp, 4
 2484 175d 6A11     		push	17
 2485 175f 6A00     		push	0
 2486 1761 68F30100 		push	OFFSET FLAT:.LC23
 2486      00
 2487 1766 E8FCFFFF 		call	printAt
 2487      FF
 2488 176b 83C410   		add	esp, 16
 642:host.c        **** 	pErr = Itoa(guest.vmcb->cr0, pErr, 16);
 2489              		.loc 1 642 0
 2490 176e A1040000 		mov	eax, DWORD PTR guest+4
 2490      00
 2491 1773 8B905C05 		mov	edx, DWORD PTR [eax+1372]
 2491      0000
 2492 1779 8B805805 		mov	eax, DWORD PTR [eax+1368]
 2492      0000
 2493 177f 83EC04   		sub	esp, 4
 2494 1782 6A10     		push	16
 2495 1784 FF75F4   		push	DWORD PTR [ebp-12]
 2496 1787 50       		push	eax
 2497 1788 E8FCFFFF 		call	Itoa
 2497      FF
 2498 178d 83C410   		add	esp, 16
 2499 1790 8945F4   		mov	DWORD PTR [ebp-12], eax
 643:host.c        **** 	print(pErr);
 2500              		.loc 1 643 0
 2501 1793 83EC0C   		sub	esp, 12
 2502 1796 FF75F4   		push	DWORD PTR [ebp-12]
 2503 1799 E8FCFFFF 		call	print
 2503      FF
 2504 179e 83C410   		add	esp, 16
 644:host.c        **** 	print(", CR3 value: ");
 2505              		.loc 1 644 0
 2506 17a1 83EC0C   		sub	esp, 12
 2507 17a4 68FF0100 		push	OFFSET FLAT:.LC24
 2507      00
 2508 17a9 E8FCFFFF 		call	print
 2508      FF
 2509 17ae 83C410   		add	esp, 16
 645:host.c        **** 	pErr = Itoa(guest.vmcb->cr3, pErr, 16);
 2510              		.loc 1 645 0
 2511 17b1 A1040000 		mov	eax, DWORD PTR guest+4
 2511      00
 2512 17b6 8B905405 		mov	edx, DWORD PTR [eax+1364]
 2512      0000
 2513 17bc 8B805005 		mov	eax, DWORD PTR [eax+1360]
 2513      0000
 2514 17c2 83EC04   		sub	esp, 4
 2515 17c5 6A10     		push	16
 2516 17c7 FF75F4   		push	DWORD PTR [ebp-12]
 2517 17ca 50       		push	eax
 2518 17cb E8FCFFFF 		call	Itoa
 2518      FF
 2519 17d0 83C410   		add	esp, 16
 2520 17d3 8945F4   		mov	DWORD PTR [ebp-12], eax
 646:host.c        **** 	print(pErr);
 2521              		.loc 1 646 0
 2522 17d6 83EC0C   		sub	esp, 12
 2523 17d9 FF75F4   		push	DWORD PTR [ebp-12]
 2524 17dc E8FCFFFF 		call	print
 2524      FF
 2525 17e1 83C410   		add	esp, 16
 647:host.c        ****         printAt("Bytes at CS:IP: ",0,18);
 2526              		.loc 1 647 0
 2527 17e4 83EC04   		sub	esp, 4
 2528 17e7 6A12     		push	18
 2529 17e9 6A00     		push	0
 2530 17eb 68D60200 		push	OFFSET FLAT:.LC30
 2530      00
 2531 17f0 E8FCFFFF 		call	printAt
 2531      FF
 2532 17f5 83C410   		add	esp, 16
 648:host.c        ****         for (cnt=0;cnt<20;cnt++)
 2533              		.loc 1 648 0
 2534 17f8 C745F000 		mov	DWORD PTR [ebp-16], 0
 2534      000000
 2535 17ff EB70     		jmp	.L107
 2536              	.L108:
 649:host.c        ****         {
 650:host.c        ****             pErr = Itoa(GetMemB( (guest.vmcb->cs.sel | guest.vmcb->rip) + cnt,true), pErr, 16);
 2537              		.loc 1 650 0 discriminator 3
 2538 1801 A1040000 		mov	eax, DWORD PTR guest+4
 2538      00
 2539 1806 0FB78010 		movzx	eax, WORD PTR [eax+1040]
 2539      040000
 2540 180d 0FB7C8   		movzx	ecx, ax
 2541 1810 A1040000 		mov	eax, DWORD PTR guest+4
 2541      00
 2542 1815 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 2542      0000
 2543 181b 8B807805 		mov	eax, DWORD PTR [eax+1400]
 2543      0000
 2544 1821 89CA     		mov	edx, ecx
 2545 1823 09C2     		or	edx, eax
 2546 1825 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 2547 1828 01D0     		add	eax, edx
 2548 182a 83EC08   		sub	esp, 8
 2549 182d 6A01     		push	1
 2550 182f 50       		push	eax
 2551 1830 E8FCFFFF 		call	GetMemB
 2551      FF
 2552 1835 83C410   		add	esp, 16
 2553 1838 0FB6C0   		movzx	eax, al
 2554 183b 83EC04   		sub	esp, 4
 2555 183e 6A10     		push	16
 2556 1840 FF75F4   		push	DWORD PTR [ebp-12]
 2557 1843 50       		push	eax
 2558 1844 E8FCFFFF 		call	Itoa
 2558      FF
 2559 1849 83C410   		add	esp, 16
 2560 184c 8945F4   		mov	DWORD PTR [ebp-12], eax
 651:host.c        ****             print(pErr);
 2561              		.loc 1 651 0 discriminator 3
 2562 184f 83EC0C   		sub	esp, 12
 2563 1852 FF75F4   		push	DWORD PTR [ebp-12]
 2564 1855 E8FCFFFF 		call	print
 2564      FF
 2565 185a 83C410   		add	esp, 16
 652:host.c        ****             print(" ");
 2566              		.loc 1 652 0 discriminator 3
 2567 185d 83EC0C   		sub	esp, 12
 2568 1860 68E70200 		push	OFFSET FLAT:.LC31
 2568      00
 2569 1865 E8FCFFFF 		call	print
 2569      FF
 2570 186a 83C410   		add	esp, 16
 648:host.c        ****         {
 2571              		.loc 1 648 0 discriminator 3
 2572 186d 8345F001 		add	DWORD PTR [ebp-16], 1
 2573              	.L107:
 648:host.c        ****         {
 2574              		.loc 1 648 0 is_stmt 0 discriminator 1
 2575 1871 837DF013 		cmp	DWORD PTR [ebp-16], 19
 2576 1875 7E8A     		jle	.L108
 653:host.c        ****         }
 654:host.c        ****         printAt("A20 Value: ",0,19);
 2577              		.loc 1 654 0 is_stmt 1
 2578 1877 83EC04   		sub	esp, 4
 2579 187a 6A13     		push	19
 2580 187c 6A00     		push	0
 2581 187e 68E90200 		push	OFFSET FLAT:.LC32
 2581      00
 2582 1883 E8FCFFFF 		call	printAt
 2582      FF
 2583 1888 83C410   		add	esp, 16
 655:host.c        ****         pErr = Itoa(inb(0x92), pErr, 16);
 2584              		.loc 1 655 0
 2585 188b 83EC0C   		sub	esp, 12
 2586 188e 68920000 		push	146
 2586      00
 2587 1893 E8FCFFFF 		call	inb
 2587      FF
 2588 1898 83C410   		add	esp, 16
 2589 189b 0FB6C0   		movzx	eax, al
 2590 189e 83EC04   		sub	esp, 4
 2591 18a1 6A10     		push	16
 2592 18a3 FF75F4   		push	DWORD PTR [ebp-12]
 2593 18a6 50       		push	eax
 2594 18a7 E8FCFFFF 		call	Itoa
 2594      FF
 2595 18ac 83C410   		add	esp, 16
 2596 18af 8945F4   		mov	DWORD PTR [ebp-12], eax
 656:host.c        ****         print(pErr);
 2597              		.loc 1 656 0
 2598 18b2 83EC0C   		sub	esp, 12
 2599 18b5 FF75F4   		push	DWORD PTR [ebp-12]
 2600 18b8 E8FCFFFF 		call	print
 2600      FF
 2601 18bd 83C410   		add	esp, 16
 657:host.c        ****         HostScancode = 0;
 2602              		.loc 1 657 0
 2603 18c0 C6050000 		mov	BYTE PTR HostScancode, 0
 2603      000000
 658:host.c        ****         DumpVMCB();
 2604              		.loc 1 658 0
 2605 18c7 E8FCFFFF 		call	DumpVMCB
 2605      FF
 2606              	.L109:
 659:host.c        ****         
 660:host.c        ****         InfiniteLoop1:
 661:host.c        **** 	goto InfiniteLoop1;
 2607              		.loc 1 661 0 discriminator 1
 2608 18cc EBFE     		jmp	.L109
 2609              		.cfi_endproc
 2610              	.LFE9:
 2612              		.globl	SetupHostPaging
 2614              	SetupHostPaging:
 2615              	.LFB10:
 662:host.c        **** }
 663:host.c        **** 
 664:host.c        **** /*
 665:host.c        ****  * Set up host and nested paging
 666:host.c        ****  */
 667:host.c        **** void SetupHostPaging()
 668:host.c        **** {
 2616              		.loc 1 668 0
 2617              		.cfi_startproc
 2618 18ce 55       		push	ebp
 2619              		.cfi_def_cfa_offset 8
 2620              		.cfi_offset 5, -8
 2621 18cf 89E5     		mov	ebp, esp
 2622              		.cfi_def_cfa_register 5
 2623 18d1 83EC30   		sub	esp, 48
 669:host.c        ****     DWORD hCR3 = vhost.CodeBase + vhost.CR3;
 2624              		.loc 1 669 0
 2625 18d4 8B150000 		mov	edx, DWORD PTR vhost
 2625      0000
 2626 18da A13C0000 		mov	eax, DWORD PTR vhost+60
 2626      00
 2627 18df 01D0     		add	eax, edx
 2628 18e1 8945F0   		mov	DWORD PTR [ebp-16], eax
 670:host.c        ****     DWORD hnCR3 = (DWORD)guest.vmcb->nested_cr3;
 2629              		.loc 1 670 0
 2630 18e4 A1040000 		mov	eax, DWORD PTR guest+4
 2630      00
 2631 18e9 8B90B400 		mov	edx, DWORD PTR [eax+180]
 2631      0000
 2632 18ef 8B80B000 		mov	eax, DWORD PTR [eax+176]
 2632      0000
 2633 18f5 8945EC   		mov	DWORD PTR [ebp-20], eax
 671:host.c        ****     DWORD hostMemSize = vhost.memSize;
 2634              		.loc 1 671 0
 2635 18f8 A1300000 		mov	eax, DWORD PTR vhost+48
 2635      00
 2636 18fd 8945E8   		mov	DWORD PTR [ebp-24], eax
 672:host.c        ****     DWORD guestMemSize = guest.memSize;
 2637              		.loc 1 672 0
 2638 1900 A1000000 		mov	eax, DWORD PTR guest
 2638      00
 2639 1905 8945E4   		mov	DWORD PTR [ebp-28], eax
 673:host.c        ****     DWORD guestMemOffset = guest.GuestMemStartAddress;
 2640              		.loc 1 673 0
 2641 1908 A1080000 		mov	eax, DWORD PTR guest+8
 2641      00
 2642 190d 8945E0   		mov	DWORD PTR [ebp-32], eax
 674:host.c        ****     
 675:host.c        ****     OPEN_UP_DS
 2643              		.loc 1 675 0
 2644              	#APP
 2645              	# 675 "host.c" 1
 676 1911 B8100000 	    DWORD *ptr = (DWORD*)hCR3;
 676      00
 677 1916 50       	    DWORD *ptrT = (DWORD*)hCR3 + 0x400;
 678 1917 1F       	    DWORD cnt, cnt2;
 679 1918 58       	
 680              	    //Initialize Host Page Directory
 681              	    for (cnt=0;cnt <= (hostMemSize / 0x400000); cnt++)	
 676:host.c        ****     DWORD *ptrT = (DWORD*)hCR3 + 0x400;
 2646              		push eax
 2647              	 mov eax, 0x10
 2648              	 push eax
 2649              	 pop ds
 2650              	 pop eax
 2651              	
 2652              	# 0 "" 2
 2653              		.loc 1 676 0
 2654              	#NO_APP
 2655 1919 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 2656 191c 8945DC   		mov	DWORD PTR [ebp-36], eax
 677:host.c        ****     DWORD cnt, cnt2;
 2657              		.loc 1 677 0
 2658 191f 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 2659 1922 05001000 		add	eax, 4096
 2659      00
 2660 1927 8945FC   		mov	DWORD PTR [ebp-4], eax
 2661              		.loc 1 681 0
 2662 192a C745F800 		mov	DWORD PTR [ebp-8], 0
 2662      000000
 2663 1931 EB6C     		jmp	.L111
 2664              	.L114:
 682:host.c        ****     {
 683:host.c        ****             ptr[cnt] = (hCR3 + 4096 + (cnt*4096)) | 7;
 2665              		.loc 1 683 0
 2666 1933 8B45F8   		mov	eax, DWORD PTR [ebp-8]
 2667 1936 8D148500 		lea	edx, [0+eax*4]
 2667      000000
 2668 193d 8B45DC   		mov	eax, DWORD PTR [ebp-36]
 2669 1940 01D0     		add	eax, edx
 2670 1942 8B55F8   		mov	edx, DWORD PTR [ebp-8]
 2671 1945 89D1     		mov	ecx, edx
 2672 1947 C1E10C   		sal	ecx, 12
 2673 194a 8B55F0   		mov	edx, DWORD PTR [ebp-16]
 2674 194d 01CA     		add	edx, ecx
 2675 194f 81C20010 		add	edx, 4096
 2675      0000
 2676 1955 83CA07   		or	edx, 7
 2677 1958 8910     		mov	DWORD PTR [eax], edx
 684:host.c        ****             for (cnt2=0;cnt2<1024;cnt2++)
 2678              		.loc 1 684 0
 2679 195a C745F400 		mov	DWORD PTR [ebp-12], 0
 2679      000000
 2680 1961 EB28     		jmp	.L112
 2681              	.L113:
 685:host.c        ****                     ptrT[cnt2] = ((0x400000 * cnt) + ((cnt2) << 12)) | 7;
 2682              		.loc 1 685 0 discriminator 3
 2683 1963 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 2684 1966 8D148500 		lea	edx, [0+eax*4]
 2684      000000
 2685 196d 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 2686 1970 01D0     		add	eax, edx
 2687 1972 8B55F8   		mov	edx, DWORD PTR [ebp-8]
 2688 1975 89D1     		mov	ecx, edx
 2689 1977 C1E116   		sal	ecx, 22
 2690 197a 8B55F4   		mov	edx, DWORD PTR [ebp-12]
 2691 197d C1E20C   		sal	edx, 12
 2692 1980 01CA     		add	edx, ecx
 2693 1982 83CA07   		or	edx, 7
 2694 1985 8910     		mov	DWORD PTR [eax], edx
 684:host.c        ****             for (cnt2=0;cnt2<1024;cnt2++)
 2695              		.loc 1 684 0 discriminator 3
 2696 1987 8345F401 		add	DWORD PTR [ebp-12], 1
 2697              	.L112:
 684:host.c        ****             for (cnt2=0;cnt2<1024;cnt2++)
 2698              		.loc 1 684 0 is_stmt 0 discriminator 1
 2699 198b 817DF4FF 		cmp	DWORD PTR [ebp-12], 1023
 2699      030000
 2700 1992 76CF     		jbe	.L113
 686:host.c        ****             ptrT += 0x400;
 2701              		.loc 1 686 0 is_stmt 1 discriminator 2
 2702 1994 8145FC00 		add	DWORD PTR [ebp-4], 4096
 2702      100000
 681:host.c        ****     {
 2703              		.loc 1 681 0 discriminator 2
 2704 199b 8345F801 		add	DWORD PTR [ebp-8], 1
 2705              	.L111:
 681:host.c        ****     {
 2706              		.loc 1 681 0 is_stmt 0 discriminator 1
 2707 199f 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 2708 19a2 C1E816   		shr	eax, 22
 2709 19a5 3B45F8   		cmp	eax, DWORD PTR [ebp-8]
 2710 19a8 7389     		jnb	.L114
 687:host.c        ****     }
 688:host.c        **** 	ptr = (DWORD*)hnCR3; 
 2711              		.loc 1 688 0 is_stmt 1
 2712 19aa 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 2713 19ad 8945DC   		mov	DWORD PTR [ebp-36], eax
 689:host.c        **** 	ptrT = (DWORD*)hnCR3 + 0x400;
 2714              		.loc 1 689 0
 2715 19b0 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 2716 19b3 05001000 		add	eax, 4096
 2716      00
 2717 19b8 8945FC   		mov	DWORD PTR [ebp-4], eax
 690:host.c        **** 	//Initialize Nested Paging table
 691:host.c        **** 	for (cnt=0;cnt<=(guestMemSize / 0x400000); cnt++) //TODO: Should use GUEST_MEMORY_SIZE
 2718              		.loc 1 691 0
 2719 19bb C745F800 		mov	DWORD PTR [ebp-8], 0
 2719      000000
 2720 19c2 EB71     		jmp	.L115
 2721              	.L118:
 692:host.c        **** 	{
 693:host.c        **** 		ptr[cnt] = (hnCR3 + 4096 + (cnt*4096)) | 7;
 2722              		.loc 1 693 0
 2723 19c4 8B45F8   		mov	eax, DWORD PTR [ebp-8]
 2724 19c7 8D148500 		lea	edx, [0+eax*4]
 2724      000000
 2725 19ce 8B45DC   		mov	eax, DWORD PTR [ebp-36]
 2726 19d1 01D0     		add	eax, edx
 2727 19d3 8B55F8   		mov	edx, DWORD PTR [ebp-8]
 2728 19d6 89D1     		mov	ecx, edx
 2729 19d8 C1E10C   		sal	ecx, 12
 2730 19db 8B55EC   		mov	edx, DWORD PTR [ebp-20]
 2731 19de 01CA     		add	edx, ecx
 2732 19e0 81C20010 		add	edx, 4096
 2732      0000
 2733 19e6 83CA07   		or	edx, 7
 2734 19e9 8910     		mov	DWORD PTR [eax], edx
 694:host.c        **** 		//Create a guest page table for each Page Directory
 695:host.c        **** 		for (cnt2 = 0;cnt2 < 1024;cnt2++) 
 2735              		.loc 1 695 0
 2736 19eb C745F400 		mov	DWORD PTR [ebp-12], 0
 2736      000000
 2737 19f2 EB2D     		jmp	.L116
 2738              	.L117:
 696:host.c        ****                 {
 697:host.c        ****                     ptrT[cnt2] = (guestMemOffset + (0x400000 * cnt) + (cnt2 << 12)) | 7;
 2739              		.loc 1 697 0 discriminator 3
 2740 19f4 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 2741 19f7 8D148500 		lea	edx, [0+eax*4]
 2741      000000
 2742 19fe 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 2743 1a01 01D0     		add	eax, edx
 2744 1a03 8B55F8   		mov	edx, DWORD PTR [ebp-8]
 2745 1a06 89D1     		mov	ecx, edx
 2746 1a08 C1E116   		sal	ecx, 22
 2747 1a0b 8B55E0   		mov	edx, DWORD PTR [ebp-32]
 2748 1a0e 01D1     		add	ecx, edx
 2749 1a10 8B55F4   		mov	edx, DWORD PTR [ebp-12]
 2750 1a13 C1E20C   		sal	edx, 12
 2751 1a16 01CA     		add	edx, ecx
 2752 1a18 83CA07   		or	edx, 7
 2753 1a1b 8910     		mov	DWORD PTR [eax], edx
 695:host.c        ****                 {
 2754              		.loc 1 695 0 discriminator 3
 2755 1a1d 8345F401 		add	DWORD PTR [ebp-12], 1
 2756              	.L116:
 695:host.c        ****                 {
 2757              		.loc 1 695 0 is_stmt 0 discriminator 1
 2758 1a21 817DF4FF 		cmp	DWORD PTR [ebp-12], 1023
 2758      030000
 2759 1a28 76CA     		jbe	.L117
 698:host.c        ****                 }
 699:host.c        **** 		ptrT += 0x400;
 2760              		.loc 1 699 0 is_stmt 1 discriminator 2
 2761 1a2a 8145FC00 		add	DWORD PTR [ebp-4], 4096
 2761      100000
 691:host.c        **** 	{
 2762              		.loc 1 691 0 discriminator 2
 2763 1a31 8345F801 		add	DWORD PTR [ebp-8], 1
 2764              	.L115:
 691:host.c        **** 	{
 2765              		.loc 1 691 0 is_stmt 0 discriminator 1
 2766 1a35 8B45E4   		mov	eax, DWORD PTR [ebp-28]
 2767 1a38 C1E816   		shr	eax, 22
 2768 1a3b 3B45F8   		cmp	eax, DWORD PTR [ebp-8]
 2769 1a3e 7384     		jnb	.L118
 700:host.c        **** 	}
 701:host.c        ****         RESTORE_DS
 2770              		.loc 1 701 0 is_stmt 1
 2771 1a40 B8380000 		mov	eax, 56
 2771      00
 2772              	#APP
 2773              	# 701 "host.c" 1
 702 1a46 89C0     	}
 703 1a48 50       	
 704 1a49 1F       	void RelocateMyself()
 705 1a4a 58       	{
 706              	    CopyMemory(0x800000,vhost.CodeBase, 0x1FFFF);
 707              	    DESCR_SEG *item = (DESCR_SEG*)(DWORD)(vhost.CodeBase + vhost.GDTOffset);
 702:host.c        **** 
 2774              		push eax
 2775              	 mov eax, eax
 2776              	 push eax
 2777              	 pop ds
 2778              	 pop eax
 2779              	
 2780              	# 0 "" 2
 2781              		.loc 1 702 0
 2782              	#NO_APP
 2783 1a4b 90       		nop
 2784 1a4c C9       		leave
 2785              		.cfi_restore 5
 2786              		.cfi_def_cfa 4, 4
 2787 1a4d C3       		ret
 2788              		.cfi_endproc
 2789              	.LFE10:
 2791              		.globl	RelocateMyself
 2793              	RelocateMyself:
 2794              	.LFB11:
 705:host.c        ****     CopyMemory(0x800000,vhost.CodeBase, 0x1FFFF);
 2795              		.loc 1 705 0
 2796              		.cfi_startproc
 2797 1a4e 55       		push	ebp
 2798              		.cfi_def_cfa_offset 8
 2799              		.cfi_offset 5, -8
 2800 1a4f 89E5     		mov	ebp, esp
 2801              		.cfi_def_cfa_register 5
 2802 1a51 83EC18   		sub	esp, 24
 706:host.c        ****     DESCR_SEG *item = (DESCR_SEG*)(DWORD)(vhost.CodeBase + vhost.GDTOffset);
 2803              		.loc 1 706 0
 2804 1a54 A1000000 		mov	eax, DWORD PTR vhost
 2804      00
 2805 1a59 83EC04   		sub	esp, 4
 2806 1a5c 68FFFF01 		push	131071
 2806      00
 2807 1a61 50       		push	eax
 2808 1a62 68000080 		push	8388608
 2808      00
 2809 1a67 E8FCFFFF 		call	CopyMemory
 2809      FF
 2810 1a6c 83C410   		add	esp, 16
 2811              		.loc 1 707 0
 2812 1a6f 8B150000 		mov	edx, DWORD PTR vhost
 2812      0000
 2813 1a75 A1140000 		mov	eax, DWORD PTR vhost+20
 2813      00
 2814 1a7a 01D0     		add	eax, edx
 2815 1a7c 8945F4   		mov	DWORD PTR [ebp-12], eax
 708:host.c        ****     setup_GDT32_entry_gcc(item+10, vhost.CodeBase, 0xFFFFFFFF, ACS_CODE, 0X4F);
 2816              		.loc 1 708 0
 2817 1a7f A1000000 		mov	eax, DWORD PTR vhost
 2817      00
 2818 1a84 8B55F4   		mov	edx, DWORD PTR [ebp-12]
 2819 1a87 83C250   		add	edx, 80
 2820 1a8a 83EC0C   		sub	esp, 12
 2821 1a8d 6A4F     		push	79
 2822 1a8f 689A0000 		push	154
 2822      00
 2823 1a94 6AFF     		push	-1
 2824 1a96 50       		push	eax
 2825 1a97 52       		push	edx
 2826 1a98 E8FCFFFF 		call	setup_GDT32_entry_gcc
 2826      FF
 2827 1a9d 83C420   		add	esp, 32
 709:host.c        ****     asm("jmp 0x50:_jmp1\n"
 2828              		.loc 1 709 0
 2829              	#APP
 2830              	# 709 "host.c" 1
 710              	    "_jmp1:");
 711              	    setup_GDT32_entry_gcc(item+7, vhost.CodeBase, 0xFFFFFFFF, ACS_DATA, 0x4F);
 2831              		jmp 0x50:_jmp1
 2832              	_jmp1:
 2833              	# 0 "" 2
 2834              		.loc 1 711 0
 2835              	#NO_APP
 2836 1aa7 A1000000 		mov	eax, DWORD PTR vhost
 2836      00
 2837 1aac 8B55F4   		mov	edx, DWORD PTR [ebp-12]
 2838 1aaf 83C238   		add	edx, 56
 2839 1ab2 83EC0C   		sub	esp, 12
 2840 1ab5 6A4F     		push	79
 2841 1ab7 68920000 		push	146
 2841      00
 2842 1abc 6AFF     		push	-1
 2843 1abe 50       		push	eax
 2844 1abf 52       		push	edx
 2845 1ac0 E8FCFFFF 		call	setup_GDT32_entry_gcc
 2845      FF
 2846 1ac5 83C420   		add	esp, 32
 712:host.c        ****     asm("mov eax,0x38\npush ax\npop ds");
 2847              		.loc 1 712 0
 2848              	#APP
 2849              	# 712 "host.c" 1
 713 1acd 6650     	    asm("mov eax,0x38\npush ax\npop gs");
 714 1acf 1F       	}
 715              	
 713:host.c        **** }
 2850              		mov eax,0x38
 2851              	push ax
 2852              	pop ds
 2853              	# 0 "" 2
 2854              		.loc 1 713 0
 2855              	# 713 "host.c" 1
 716              	void SaveHostBIOS()
 714:host.c        **** 
 2856              		mov eax,0x38
 2857              	push ax
 2858              	pop gs
 2859              	# 0 "" 2
 2860              		.loc 1 714 0
 2861              	#NO_APP
 2862 1ad9 90       		nop
 2863 1ada C9       		leave
 2864              		.cfi_restore 5
 2865              		.cfi_def_cfa 4, 4
 2866 1adb C3       		ret
 2867              		.cfi_endproc
 2868              	.LFE11:
 2870              		.globl	SaveHostBIOS
 2872              	SaveHostBIOS:
 2873              	.LFB12:
 717:host.c        **** {
 2874              		.loc 1 717 0
 2875              		.cfi_startproc
 2876 1adc 55       		push	ebp
 2877              		.cfi_def_cfa_offset 8
 2878              		.cfi_offset 5, -8
 2879 1add 89E5     		mov	ebp, esp
 2880              		.cfi_def_cfa_register 5
 718:host.c        ****     lTempDest = vhost.CodeBase + vhost.BIOSSave;
 2881              		.loc 1 718 0
 2882 1adf 8B150000 		mov	edx, DWORD PTR vhost
 2882      0000
 2883 1ae5 A11C0000 		mov	eax, DWORD PTR vhost+28
 2883      00
 2884 1aea 01D0     		add	eax, edx
 2885 1aec A3000000 		mov	DWORD PTR lTempDest, eax
 2885      00
 719:host.c        ****     lTempSource =  0xE0000;
 2886              		.loc 1 719 0
 2887 1af1 C7050000 		mov	DWORD PTR lTempSource, 917504
 2887      00000000 
 2887      0E00
 720:host.c        ****     asm(            "	mov		esi, %[Source]\n"
 2888              		.loc 1 720 0
 2889 1afb A1000000 		mov	eax, DWORD PTR lTempDest
 2889      00
 2890 1b00 8B150000 		mov	edx, DWORD PTR lTempSource
 2890      0000
 2891              	#APP
 2892              	# 720 "host.c" 1
 721 1b08 89C7     	                "	mov		edi, %[Dest]\n"
 722 1b0a B9000002 	                "	mov		ecx, 0x20000\n"
 722      00
 723 1b0f FC       	                "	cld\n"
 724 1b10 64F3A4   	                "   rep movsb es:[edi], fs:[esi]\n"
 725              	                :
 726              	                : [Dest] "r" (lTempDest), [Source] "r" (lTempSource));
 727:host.c        **** 
 728:host.c        ****     lTempDest = vhost.CodeBase + vhost.VIDEOSave;
 2893              			mov		esi, edx
 2894              		mov		edi, eax
 2895              		mov		ecx, 0x20000
 2896              		cld
 2897              	   rep movsb es:[edi], fs:[esi]
 2898              	
 2899              	# 0 "" 2
 2900              		.loc 1 728 0
 2901              	#NO_APP
 2902 1b13 8B150000 		mov	edx, DWORD PTR vhost
 2902      0000
 2903 1b19 A1200000 		mov	eax, DWORD PTR vhost+32
 2903      00
 2904 1b1e 01D0     		add	eax, edx
 2905 1b20 A3000000 		mov	DWORD PTR lTempDest, eax
 2905      00
 729:host.c        ****     lTempSource =  0xC0000;
 2906              		.loc 1 729 0
 2907 1b25 C7050000 		mov	DWORD PTR lTempSource, 786432
 2907      00000000 
 2907      0C00
 730:host.c        ****     asm(            "	mov		esi, %[Source]\n"
 2908              		.loc 1 730 0
 2909 1b2f A1000000 		mov	eax, DWORD PTR lTempDest
 2909      00
 2910 1b34 8B150000 		mov	edx, DWORD PTR lTempSource
 2910      0000
 2911              	#APP
 2912              	# 730 "host.c" 1
 731 1b3c 89C7     	                "	mov		edi, %[Dest]\n"
 732 1b3e B9000001 	                "	mov		ecx, 0x10000\n"
 732      00
 733 1b43 FC       	                "	cld\n"
 734 1b44 64F3A4   	                "   rep movsb es:[edi], fs:[esi]\n"
 735              	                :
 736              	                : [Dest] "r" (lTempDest), [Source] "r" (lTempSource));
 737:host.c        ****     
 738:host.c        ****     
 739:host.c        **** }
 2913              			mov		esi, edx
 2914              		mov		edi, eax
 2915              		mov		ecx, 0x10000
 2916              		cld
 2917              	   rep movsb es:[edi], fs:[esi]
 2918              	
 2919              	# 0 "" 2
 2920              		.loc 1 739 0
 2921              	#NO_APP
 2922 1b47 90       		nop
 2923 1b48 5D       		pop	ebp
 2924              		.cfi_restore 5
 2925              		.cfi_def_cfa 4, 4
 2926 1b49 C3       		ret
 2927              		.cfi_endproc
 2928              	.LFE12:
 2930              		.section	.rodata
 2931              	.LC33:
 2932 02f5 2A2A2A20 		.string	"*** Host Information ***"
 2932      486F7374 
 2932      20496E66 
 2932      6F726D61 
 2932      74696F6E 
 2933              	.LC34:
 2934 030e 486F7374 		.string	"Host Memory Size: 0x"
 2934      204D656D 
 2934      6F727920 
 2934      53697A65 
 2934      3A203078 
 2935 0323 00       		.align 4
 2936              	.LC35:
 2937 0324 47756573 		.string	"Guest offset in physical memory: 0x"
 2937      74206F66 
 2937      66736574 
 2937      20696E20 
 2937      70687973 
 2938              	.LC36:
 2939 0348 47756573 		.string	"Guest Memory Size: 0x"
 2939      74204D65 
 2939      6D6F7279 
 2939      2053697A 
 2939      653A2030 
 2940              	.LC37:
 2941 035e 436F6465 		.string	"CodeBase: 0x"
 2941      42617365 
 2941      3A203078 
 2941      00
 2942              	.LC38:
 2943 036b 53746163 		.string	"StackBase: 0x"
 2943      6B426173 
 2943      653A2030 
 2943      7800
 2944              	.LC39:
 2945 0379 564D4342 		.string	"VMCB: 0x"
 2945      3A203078 
 2945      00
 2946              	.LC40:
 2947 0382 494F494F 		.string	"IOIO: 0x"
 2947      3A203078 
 2947      00
 2948              	.LC41:
 2949 038b 50616765 		.string	"Page Tables: 0x"
 2949      20546162 
 2949      6C65733A 
 2949      20307800 
 2950              	.LC42:
 2951 039b 4944543A 		.string	"IDT: 0x"
 2951      20307800 
 2952              	.LC43:
 2953 03a3 4744543A 		.string	"GDT: 0x"
 2953      20307800 
 2954              	.LC44:
 2955 03ab 486F7374 		.string	"Host Save Area: 0x"
 2955      20536176 
 2955      65204172 
 2955      65613A20 
 2955      307800
 2956              	.LC45:
 2957 03be 42494F53 		.string	"BIOS Save Area: 0x"
 2957      20536176 
 2957      65204172 
 2957      65613A20 
 2957      307800
 2958              	.LC46:
 2959 03d1 56494445 		.string	"VIDEO Save Area: 0x"
 2959      4F205361 
 2959      76652041 
 2959      7265613A 
 2959      20307800 
 2960              	.LC47:
 2961 03e5 4E657374 		.string	"Nested CR3: 0x"
 2961      65642043 
 2961      52333A20 
 2961      307800
 2962              	.LC48:
 2963 03f4 426F6F74 		.string	"Boot Sector Save Area: 0x"
 2963      20536563 
 2963      746F7220 
 2963      53617665 
 2963      20417265 
 2964              	.LC49:
 2965 040e 45383230 		.string	"E820 Data: 0x"
 2965      20446174 
 2965      613A2030 
 2965      7800
 2966              	.LC50:
 2967 041c 546F7461 		.string	"Total Host Mem: 0x"
 2967      6C20486F 
 2967      7374204D 
 2967      656D3A20 
 2967      307800
 2968              	.LC51:
 2969 042f 202800   		.string	" ("
 2970              	.LC52:
 2971 0432 20627974 		.string	" bytes)"
 2971      65732900 
 2972              		.text
 2973              		.globl	PrintHostInformation
 2975              	PrintHostInformation:
 2976              	.LFB13:
 740:host.c        **** 
 741:host.c        **** void PrintHostInformation()
 742:host.c        **** {
 2977              		.loc 1 742 0
 2978              		.cfi_startproc
 2979 1b4a 55       		push	ebp
 2980              		.cfi_def_cfa_offset 8
 2981              		.cfi_offset 5, -8
 2982 1b4b 89E5     		mov	ebp, esp
 2983              		.cfi_def_cfa_register 5
 2984 1b4d 83EC18   		sub	esp, 24
 743:host.c        ****     char *pErr = "                    \0";
 2985              		.loc 1 743 0
 2986 1b50 C745F4C9 		mov	DWORD PTR [ebp-12], OFFSET FLAT:.LC3
 2986      000000
 744:host.c        ****     int lineNo = 0;
 2987              		.loc 1 744 0
 2988 1b57 C745F000 		mov	DWORD PTR [ebp-16], 0
 2988      000000
 745:host.c        ****     
 746:host.c        ****     clrscr();
 2989              		.loc 1 746 0
 2990 1b5e E8FCFFFF 		call	clrscr
 2990      FF
 747:host.c        ****     printAt("*** Host Information ***",0,lineNo++);
 2991              		.loc 1 747 0
 2992 1b63 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 2993 1b66 8D5001   		lea	edx, [eax+1]
 2994 1b69 8955F0   		mov	DWORD PTR [ebp-16], edx
 2995 1b6c 83EC04   		sub	esp, 4
 2996 1b6f 50       		push	eax
 2997 1b70 6A00     		push	0
 2998 1b72 68F50200 		push	OFFSET FLAT:.LC33
 2998      00
 2999 1b77 E8FCFFFF 		call	printAt
 2999      FF
 3000 1b7c 83C410   		add	esp, 16
 748:host.c        **** 
 749:host.c        ****     printAt("Host Memory Size: 0x",0,lineNo++);
 3001              		.loc 1 749 0
 3002 1b7f 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3003 1b82 8D5001   		lea	edx, [eax+1]
 3004 1b85 8955F0   		mov	DWORD PTR [ebp-16], edx
 3005 1b88 83EC04   		sub	esp, 4
 3006 1b8b 50       		push	eax
 3007 1b8c 6A00     		push	0
 3008 1b8e 680E0300 		push	OFFSET FLAT:.LC34
 3008      00
 3009 1b93 E8FCFFFF 		call	printAt
 3009      FF
 3010 1b98 83C410   		add	esp, 16
 750:host.c        ****     pErr = Itoa(vhost.memSize, pErr, 16);
 3011              		.loc 1 750 0
 3012 1b9b A1300000 		mov	eax, DWORD PTR vhost+48
 3012      00
 3013 1ba0 83EC04   		sub	esp, 4
 3014 1ba3 6A10     		push	16
 3015 1ba5 FF75F4   		push	DWORD PTR [ebp-12]
 3016 1ba8 50       		push	eax
 3017 1ba9 E8FCFFFF 		call	Itoa
 3017      FF
 3018 1bae 83C410   		add	esp, 16
 3019 1bb1 8945F4   		mov	DWORD PTR [ebp-12], eax
 751:host.c        ****     print(pErr);
 3020              		.loc 1 751 0
 3021 1bb4 83EC0C   		sub	esp, 12
 3022 1bb7 FF75F4   		push	DWORD PTR [ebp-12]
 3023 1bba E8FCFFFF 		call	print
 3023      FF
 3024 1bbf 83C410   		add	esp, 16
 752:host.c        **** 
 753:host.c        ****     printAt("Guest offset in physical memory: 0x", 0, lineNo++);
 3025              		.loc 1 753 0
 3026 1bc2 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3027 1bc5 8D5001   		lea	edx, [eax+1]
 3028 1bc8 8955F0   		mov	DWORD PTR [ebp-16], edx
 3029 1bcb 83EC04   		sub	esp, 4
 3030 1bce 50       		push	eax
 3031 1bcf 6A00     		push	0
 3032 1bd1 68240300 		push	OFFSET FLAT:.LC35
 3032      00
 3033 1bd6 E8FCFFFF 		call	printAt
 3033      FF
 3034 1bdb 83C410   		add	esp, 16
 754:host.c        ****     pErr = Itoa(guest.GuestMemStartAddress, pErr, 16);
 3035              		.loc 1 754 0
 3036 1bde A1080000 		mov	eax, DWORD PTR guest+8
 3036      00
 3037 1be3 83EC04   		sub	esp, 4
 3038 1be6 6A10     		push	16
 3039 1be8 FF75F4   		push	DWORD PTR [ebp-12]
 3040 1beb 50       		push	eax
 3041 1bec E8FCFFFF 		call	Itoa
 3041      FF
 3042 1bf1 83C410   		add	esp, 16
 3043 1bf4 8945F4   		mov	DWORD PTR [ebp-12], eax
 755:host.c        ****     print(pErr);
 3044              		.loc 1 755 0
 3045 1bf7 83EC0C   		sub	esp, 12
 3046 1bfa FF75F4   		push	DWORD PTR [ebp-12]
 3047 1bfd E8FCFFFF 		call	print
 3047      FF
 3048 1c02 83C410   		add	esp, 16
 756:host.c        **** 
 757:host.c        ****     printAt("Guest Memory Size: 0x",0,lineNo++);
 3049              		.loc 1 757 0
 3050 1c05 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3051 1c08 8D5001   		lea	edx, [eax+1]
 3052 1c0b 8955F0   		mov	DWORD PTR [ebp-16], edx
 3053 1c0e 83EC04   		sub	esp, 4
 3054 1c11 50       		push	eax
 3055 1c12 6A00     		push	0
 3056 1c14 68480300 		push	OFFSET FLAT:.LC36
 3056      00
 3057 1c19 E8FCFFFF 		call	printAt
 3057      FF
 3058 1c1e 83C410   		add	esp, 16
 758:host.c        ****     pErr = Itoa(guest.memSize, pErr, 16);
 3059              		.loc 1 758 0
 3060 1c21 A1000000 		mov	eax, DWORD PTR guest
 3060      00
 3061 1c26 83EC04   		sub	esp, 4
 3062 1c29 6A10     		push	16
 3063 1c2b FF75F4   		push	DWORD PTR [ebp-12]
 3064 1c2e 50       		push	eax
 3065 1c2f E8FCFFFF 		call	Itoa
 3065      FF
 3066 1c34 83C410   		add	esp, 16
 3067 1c37 8945F4   		mov	DWORD PTR [ebp-12], eax
 759:host.c        ****     print(pErr);
 3068              		.loc 1 759 0
 3069 1c3a 83EC0C   		sub	esp, 12
 3070 1c3d FF75F4   		push	DWORD PTR [ebp-12]
 3071 1c40 E8FCFFFF 		call	print
 3071      FF
 3072 1c45 83C410   		add	esp, 16
 760:host.c        **** 
 761:host.c        ****     printAt("CodeBase: 0x",0,lineNo++);
 3073              		.loc 1 761 0
 3074 1c48 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3075 1c4b 8D5001   		lea	edx, [eax+1]
 3076 1c4e 8955F0   		mov	DWORD PTR [ebp-16], edx
 3077 1c51 83EC04   		sub	esp, 4
 3078 1c54 50       		push	eax
 3079 1c55 6A00     		push	0
 3080 1c57 685E0300 		push	OFFSET FLAT:.LC37
 3080      00
 3081 1c5c E8FCFFFF 		call	printAt
 3081      FF
 3082 1c61 83C410   		add	esp, 16
 762:host.c        ****     pErr = Itoa(vhost.CodeBase, pErr, 16);
 3083              		.loc 1 762 0
 3084 1c64 A1000000 		mov	eax, DWORD PTR vhost
 3084      00
 3085 1c69 83EC04   		sub	esp, 4
 3086 1c6c 6A10     		push	16
 3087 1c6e FF75F4   		push	DWORD PTR [ebp-12]
 3088 1c71 50       		push	eax
 3089 1c72 E8FCFFFF 		call	Itoa
 3089      FF
 3090 1c77 83C410   		add	esp, 16
 3091 1c7a 8945F4   		mov	DWORD PTR [ebp-12], eax
 763:host.c        ****     print(pErr);
 3092              		.loc 1 763 0
 3093 1c7d 83EC0C   		sub	esp, 12
 3094 1c80 FF75F4   		push	DWORD PTR [ebp-12]
 3095 1c83 E8FCFFFF 		call	print
 3095      FF
 3096 1c88 83C410   		add	esp, 16
 764:host.c        **** 
 765:host.c        ****     printAt("StackBase: 0x",0,lineNo++);
 3097              		.loc 1 765 0
 3098 1c8b 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3099 1c8e 8D5001   		lea	edx, [eax+1]
 3100 1c91 8955F0   		mov	DWORD PTR [ebp-16], edx
 3101 1c94 83EC04   		sub	esp, 4
 3102 1c97 50       		push	eax
 3103 1c98 6A00     		push	0
 3104 1c9a 686B0300 		push	OFFSET FLAT:.LC38
 3104      00
 3105 1c9f E8FCFFFF 		call	printAt
 3105      FF
 3106 1ca4 83C410   		add	esp, 16
 766:host.c        ****     pErr = Itoa(vhost.StackBase, pErr, 16);
 3107              		.loc 1 766 0
 3108 1ca7 A1040000 		mov	eax, DWORD PTR vhost+4
 3108      00
 3109 1cac 83EC04   		sub	esp, 4
 3110 1caf 6A10     		push	16
 3111 1cb1 FF75F4   		push	DWORD PTR [ebp-12]
 3112 1cb4 50       		push	eax
 3113 1cb5 E8FCFFFF 		call	Itoa
 3113      FF
 3114 1cba 83C410   		add	esp, 16
 3115 1cbd 8945F4   		mov	DWORD PTR [ebp-12], eax
 767:host.c        ****     print(pErr);
 3116              		.loc 1 767 0
 3117 1cc0 83EC0C   		sub	esp, 12
 3118 1cc3 FF75F4   		push	DWORD PTR [ebp-12]
 3119 1cc6 E8FCFFFF 		call	print
 3119      FF
 3120 1ccb 83C410   		add	esp, 16
 768:host.c        **** 
 769:host.c        ****     printAt("VMCB: 0x",0,lineNo++);
 3121              		.loc 1 769 0
 3122 1cce 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3123 1cd1 8D5001   		lea	edx, [eax+1]
 3124 1cd4 8955F0   		mov	DWORD PTR [ebp-16], edx
 3125 1cd7 83EC04   		sub	esp, 4
 3126 1cda 50       		push	eax
 3127 1cdb 6A00     		push	0
 3128 1cdd 68790300 		push	OFFSET FLAT:.LC39
 3128      00
 3129 1ce2 E8FCFFFF 		call	printAt
 3129      FF
 3130 1ce7 83C410   		add	esp, 16
 770:host.c        ****     pErr = Itoa(vhost.CodeBase + vhost.VMCBOffset, pErr, 16);
 3131              		.loc 1 770 0
 3132 1cea 8B150000 		mov	edx, DWORD PTR vhost
 3132      0000
 3133 1cf0 A1080000 		mov	eax, DWORD PTR vhost+8
 3133      00
 3134 1cf5 01D0     		add	eax, edx
 3135 1cf7 83EC04   		sub	esp, 4
 3136 1cfa 6A10     		push	16
 3137 1cfc FF75F4   		push	DWORD PTR [ebp-12]
 3138 1cff 50       		push	eax
 3139 1d00 E8FCFFFF 		call	Itoa
 3139      FF
 3140 1d05 83C410   		add	esp, 16
 3141 1d08 8945F4   		mov	DWORD PTR [ebp-12], eax
 771:host.c        ****     print(pErr);
 3142              		.loc 1 771 0
 3143 1d0b 83EC0C   		sub	esp, 12
 3144 1d0e FF75F4   		push	DWORD PTR [ebp-12]
 3145 1d11 E8FCFFFF 		call	print
 3145      FF
 3146 1d16 83C410   		add	esp, 16
 772:host.c        **** 
 773:host.c        ****     printAt("IOIO: 0x",0,lineNo++);
 3147              		.loc 1 773 0
 3148 1d19 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3149 1d1c 8D5001   		lea	edx, [eax+1]
 3150 1d1f 8955F0   		mov	DWORD PTR [ebp-16], edx
 3151 1d22 83EC04   		sub	esp, 4
 3152 1d25 50       		push	eax
 3153 1d26 6A00     		push	0
 3154 1d28 68820300 		push	OFFSET FLAT:.LC40
 3154      00
 3155 1d2d E8FCFFFF 		call	printAt
 3155      FF
 3156 1d32 83C410   		add	esp, 16
 774:host.c        ****     pErr = Itoa(vhost.CodeBase + vhost.VMCBIoioOffset, pErr, 16);
 3157              		.loc 1 774 0
 3158 1d35 8B150000 		mov	edx, DWORD PTR vhost
 3158      0000
 3159 1d3b A10C0000 		mov	eax, DWORD PTR vhost+12
 3159      00
 3160 1d40 01D0     		add	eax, edx
 3161 1d42 83EC04   		sub	esp, 4
 3162 1d45 6A10     		push	16
 3163 1d47 FF75F4   		push	DWORD PTR [ebp-12]
 3164 1d4a 50       		push	eax
 3165 1d4b E8FCFFFF 		call	Itoa
 3165      FF
 3166 1d50 83C410   		add	esp, 16
 3167 1d53 8945F4   		mov	DWORD PTR [ebp-12], eax
 775:host.c        ****     print(pErr);
 3168              		.loc 1 775 0
 3169 1d56 83EC0C   		sub	esp, 12
 3170 1d59 FF75F4   		push	DWORD PTR [ebp-12]
 3171 1d5c E8FCFFFF 		call	print
 3171      FF
 3172 1d61 83C410   		add	esp, 16
 776:host.c        **** 
 777:host.c        ****     printAt("Page Tables: 0x",0,lineNo++);
 3173              		.loc 1 777 0
 3174 1d64 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3175 1d67 8D5001   		lea	edx, [eax+1]
 3176 1d6a 8955F0   		mov	DWORD PTR [ebp-16], edx
 3177 1d6d 83EC04   		sub	esp, 4
 3178 1d70 50       		push	eax
 3179 1d71 6A00     		push	0
 3180 1d73 688B0300 		push	OFFSET FLAT:.LC41
 3180      00
 3181 1d78 E8FCFFFF 		call	printAt
 3181      FF
 3182 1d7d 83C410   		add	esp, 16
 778:host.c        ****     pErr = Itoa(vhost.CodeBase + vhost.CR3, pErr, 16);
 3183              		.loc 1 778 0
 3184 1d80 8B150000 		mov	edx, DWORD PTR vhost
 3184      0000
 3185 1d86 A13C0000 		mov	eax, DWORD PTR vhost+60
 3185      00
 3186 1d8b 01D0     		add	eax, edx
 3187 1d8d 83EC04   		sub	esp, 4
 3188 1d90 6A10     		push	16
 3189 1d92 FF75F4   		push	DWORD PTR [ebp-12]
 3190 1d95 50       		push	eax
 3191 1d96 E8FCFFFF 		call	Itoa
 3191      FF
 3192 1d9b 83C410   		add	esp, 16
 3193 1d9e 8945F4   		mov	DWORD PTR [ebp-12], eax
 779:host.c        ****     print(pErr);
 3194              		.loc 1 779 0
 3195 1da1 83EC0C   		sub	esp, 12
 3196 1da4 FF75F4   		push	DWORD PTR [ebp-12]
 3197 1da7 E8FCFFFF 		call	print
 3197      FF
 3198 1dac 83C410   		add	esp, 16
 780:host.c        **** 
 781:host.c        ****     printAt("IDT: 0x",0,lineNo++);
 3199              		.loc 1 781 0
 3200 1daf 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3201 1db2 8D5001   		lea	edx, [eax+1]
 3202 1db5 8955F0   		mov	DWORD PTR [ebp-16], edx
 3203 1db8 83EC04   		sub	esp, 4
 3204 1dbb 50       		push	eax
 3205 1dbc 6A00     		push	0
 3206 1dbe 689B0300 		push	OFFSET FLAT:.LC42
 3206      00
 3207 1dc3 E8FCFFFF 		call	printAt
 3207      FF
 3208 1dc8 83C410   		add	esp, 16
 782:host.c        ****     pErr = Itoa(vhost.CodeBase + vhost.IDTOffset, pErr, 16);
 3209              		.loc 1 782 0
 3210 1dcb 8B150000 		mov	edx, DWORD PTR vhost
 3210      0000
 3211 1dd1 A1100000 		mov	eax, DWORD PTR vhost+16
 3211      00
 3212 1dd6 01D0     		add	eax, edx
 3213 1dd8 83EC04   		sub	esp, 4
 3214 1ddb 6A10     		push	16
 3215 1ddd FF75F4   		push	DWORD PTR [ebp-12]
 3216 1de0 50       		push	eax
 3217 1de1 E8FCFFFF 		call	Itoa
 3217      FF
 3218 1de6 83C410   		add	esp, 16
 3219 1de9 8945F4   		mov	DWORD PTR [ebp-12], eax
 783:host.c        ****     print(pErr);
 3220              		.loc 1 783 0
 3221 1dec 83EC0C   		sub	esp, 12
 3222 1def FF75F4   		push	DWORD PTR [ebp-12]
 3223 1df2 E8FCFFFF 		call	print
 3223      FF
 3224 1df7 83C410   		add	esp, 16
 784:host.c        **** 
 785:host.c        ****     printAt("GDT: 0x",0,lineNo++);
 3225              		.loc 1 785 0
 3226 1dfa 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3227 1dfd 8D5001   		lea	edx, [eax+1]
 3228 1e00 8955F0   		mov	DWORD PTR [ebp-16], edx
 3229 1e03 83EC04   		sub	esp, 4
 3230 1e06 50       		push	eax
 3231 1e07 6A00     		push	0
 3232 1e09 68A30300 		push	OFFSET FLAT:.LC43
 3232      00
 3233 1e0e E8FCFFFF 		call	printAt
 3233      FF
 3234 1e13 83C410   		add	esp, 16
 786:host.c        ****     pErr = Itoa(vhost.CodeBase + vhost.GDTOffset, pErr, 16);
 3235              		.loc 1 786 0
 3236 1e16 8B150000 		mov	edx, DWORD PTR vhost
 3236      0000
 3237 1e1c A1140000 		mov	eax, DWORD PTR vhost+20
 3237      00
 3238 1e21 01D0     		add	eax, edx
 3239 1e23 83EC04   		sub	esp, 4
 3240 1e26 6A10     		push	16
 3241 1e28 FF75F4   		push	DWORD PTR [ebp-12]
 3242 1e2b 50       		push	eax
 3243 1e2c E8FCFFFF 		call	Itoa
 3243      FF
 3244 1e31 83C410   		add	esp, 16
 3245 1e34 8945F4   		mov	DWORD PTR [ebp-12], eax
 787:host.c        ****     print(pErr);
 3246              		.loc 1 787 0
 3247 1e37 83EC0C   		sub	esp, 12
 3248 1e3a FF75F4   		push	DWORD PTR [ebp-12]
 3249 1e3d E8FCFFFF 		call	print
 3249      FF
 3250 1e42 83C410   		add	esp, 16
 788:host.c        **** 
 789:host.c        ****     printAt("Host Save Area: 0x",0,lineNo++);
 3251              		.loc 1 789 0
 3252 1e45 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3253 1e48 8D5001   		lea	edx, [eax+1]
 3254 1e4b 8955F0   		mov	DWORD PTR [ebp-16], edx
 3255 1e4e 83EC04   		sub	esp, 4
 3256 1e51 50       		push	eax
 3257 1e52 6A00     		push	0
 3258 1e54 68AB0300 		push	OFFSET FLAT:.LC44
 3258      00
 3259 1e59 E8FCFFFF 		call	printAt
 3259      FF
 3260 1e5e 83C410   		add	esp, 16
 790:host.c        ****     pErr = Itoa(vhost.CodeBase + vhost.HostSaveArea, pErr, 16);
 3261              		.loc 1 790 0
 3262 1e61 8B150000 		mov	edx, DWORD PTR vhost
 3262      0000
 3263 1e67 A1180000 		mov	eax, DWORD PTR vhost+24
 3263      00
 3264 1e6c 01D0     		add	eax, edx
 3265 1e6e 83EC04   		sub	esp, 4
 3266 1e71 6A10     		push	16
 3267 1e73 FF75F4   		push	DWORD PTR [ebp-12]
 3268 1e76 50       		push	eax
 3269 1e77 E8FCFFFF 		call	Itoa
 3269      FF
 3270 1e7c 83C410   		add	esp, 16
 3271 1e7f 8945F4   		mov	DWORD PTR [ebp-12], eax
 791:host.c        ****     print(pErr);
 3272              		.loc 1 791 0
 3273 1e82 83EC0C   		sub	esp, 12
 3274 1e85 FF75F4   		push	DWORD PTR [ebp-12]
 3275 1e88 E8FCFFFF 		call	print
 3275      FF
 3276 1e8d 83C410   		add	esp, 16
 792:host.c        **** 
 793:host.c        ****     printAt("BIOS Save Area: 0x",0,lineNo++);
 3277              		.loc 1 793 0
 3278 1e90 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3279 1e93 8D5001   		lea	edx, [eax+1]
 3280 1e96 8955F0   		mov	DWORD PTR [ebp-16], edx
 3281 1e99 83EC04   		sub	esp, 4
 3282 1e9c 50       		push	eax
 3283 1e9d 6A00     		push	0
 3284 1e9f 68BE0300 		push	OFFSET FLAT:.LC45
 3284      00
 3285 1ea4 E8FCFFFF 		call	printAt
 3285      FF
 3286 1ea9 83C410   		add	esp, 16
 794:host.c        ****     pErr = Itoa(vhost.CodeBase + vhost.BIOSSave, pErr, 16);
 3287              		.loc 1 794 0
 3288 1eac 8B150000 		mov	edx, DWORD PTR vhost
 3288      0000
 3289 1eb2 A11C0000 		mov	eax, DWORD PTR vhost+28
 3289      00
 3290 1eb7 01D0     		add	eax, edx
 3291 1eb9 83EC04   		sub	esp, 4
 3292 1ebc 6A10     		push	16
 3293 1ebe FF75F4   		push	DWORD PTR [ebp-12]
 3294 1ec1 50       		push	eax
 3295 1ec2 E8FCFFFF 		call	Itoa
 3295      FF
 3296 1ec7 83C410   		add	esp, 16
 3297 1eca 8945F4   		mov	DWORD PTR [ebp-12], eax
 795:host.c        ****     print(pErr);
 3298              		.loc 1 795 0
 3299 1ecd 83EC0C   		sub	esp, 12
 3300 1ed0 FF75F4   		push	DWORD PTR [ebp-12]
 3301 1ed3 E8FCFFFF 		call	print
 3301      FF
 3302 1ed8 83C410   		add	esp, 16
 796:host.c        **** 
 797:host.c        ****     printAt("VIDEO Save Area: 0x",0,lineNo++);
 3303              		.loc 1 797 0
 3304 1edb 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3305 1ede 8D5001   		lea	edx, [eax+1]
 3306 1ee1 8955F0   		mov	DWORD PTR [ebp-16], edx
 3307 1ee4 83EC04   		sub	esp, 4
 3308 1ee7 50       		push	eax
 3309 1ee8 6A00     		push	0
 3310 1eea 68D10300 		push	OFFSET FLAT:.LC46
 3310      00
 3311 1eef E8FCFFFF 		call	printAt
 3311      FF
 3312 1ef4 83C410   		add	esp, 16
 798:host.c        ****     pErr = Itoa(vhost.CodeBase + vhost.VIDEOSave, pErr, 16);
 3313              		.loc 1 798 0
 3314 1ef7 8B150000 		mov	edx, DWORD PTR vhost
 3314      0000
 3315 1efd A1200000 		mov	eax, DWORD PTR vhost+32
 3315      00
 3316 1f02 01D0     		add	eax, edx
 3317 1f04 83EC04   		sub	esp, 4
 3318 1f07 6A10     		push	16
 3319 1f09 FF75F4   		push	DWORD PTR [ebp-12]
 3320 1f0c 50       		push	eax
 3321 1f0d E8FCFFFF 		call	Itoa
 3321      FF
 3322 1f12 83C410   		add	esp, 16
 3323 1f15 8945F4   		mov	DWORD PTR [ebp-12], eax
 799:host.c        ****     print(pErr);
 3324              		.loc 1 799 0
 3325 1f18 83EC0C   		sub	esp, 12
 3326 1f1b FF75F4   		push	DWORD PTR [ebp-12]
 3327 1f1e E8FCFFFF 		call	print
 3327      FF
 3328 1f23 83C410   		add	esp, 16
 800:host.c        ****     
 801:host.c        ****     printAt("Nested CR3: 0x",0,lineNo++);
 3329              		.loc 1 801 0
 3330 1f26 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3331 1f29 8D5001   		lea	edx, [eax+1]
 3332 1f2c 8955F0   		mov	DWORD PTR [ebp-16], edx
 3333 1f2f 83EC04   		sub	esp, 4
 3334 1f32 50       		push	eax
 3335 1f33 6A00     		push	0
 3336 1f35 68E50300 		push	OFFSET FLAT:.LC47
 3336      00
 3337 1f3a E8FCFFFF 		call	printAt
 3337      FF
 3338 1f3f 83C410   		add	esp, 16
 802:host.c        ****     pErr = Itoa(vhost.CodeBase + vhost.NestedCR3, pErr, 16);
 3339              		.loc 1 802 0
 3340 1f42 8B150000 		mov	edx, DWORD PTR vhost
 3340      0000
 3341 1f48 A1240000 		mov	eax, DWORD PTR vhost+36
 3341      00
 3342 1f4d 01D0     		add	eax, edx
 3343 1f4f 83EC04   		sub	esp, 4
 3344 1f52 6A10     		push	16
 3345 1f54 FF75F4   		push	DWORD PTR [ebp-12]
 3346 1f57 50       		push	eax
 3347 1f58 E8FCFFFF 		call	Itoa
 3347      FF
 3348 1f5d 83C410   		add	esp, 16
 3349 1f60 8945F4   		mov	DWORD PTR [ebp-12], eax
 803:host.c        ****     print(pErr);
 3350              		.loc 1 803 0
 3351 1f63 83EC0C   		sub	esp, 12
 3352 1f66 FF75F4   		push	DWORD PTR [ebp-12]
 3353 1f69 E8FCFFFF 		call	print
 3353      FF
 3354 1f6e 83C410   		add	esp, 16
 804:host.c        ****     
 805:host.c        ****     printAt("Boot Sector Save Area: 0x",0,lineNo++);
 3355              		.loc 1 805 0
 3356 1f71 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3357 1f74 8D5001   		lea	edx, [eax+1]
 3358 1f77 8955F0   		mov	DWORD PTR [ebp-16], edx
 3359 1f7a 83EC04   		sub	esp, 4
 3360 1f7d 50       		push	eax
 3361 1f7e 6A00     		push	0
 3362 1f80 68F40300 		push	OFFSET FLAT:.LC48
 3362      00
 3363 1f85 E8FCFFFF 		call	printAt
 3363      FF
 3364 1f8a 83C410   		add	esp, 16
 806:host.c        ****     pErr = Itoa(vhost.CodeBase + vhost.BootSectorSave, pErr, 16);
 3365              		.loc 1 806 0
 3366 1f8d 8B150000 		mov	edx, DWORD PTR vhost
 3366      0000
 3367 1f93 A12C0000 		mov	eax, DWORD PTR vhost+44
 3367      00
 3368 1f98 01D0     		add	eax, edx
 3369 1f9a 83EC04   		sub	esp, 4
 3370 1f9d 6A10     		push	16
 3371 1f9f FF75F4   		push	DWORD PTR [ebp-12]
 3372 1fa2 50       		push	eax
 3373 1fa3 E8FCFFFF 		call	Itoa
 3373      FF
 3374 1fa8 83C410   		add	esp, 16
 3375 1fab 8945F4   		mov	DWORD PTR [ebp-12], eax
 807:host.c        ****     print(pErr);
 3376              		.loc 1 807 0
 3377 1fae 83EC0C   		sub	esp, 12
 3378 1fb1 FF75F4   		push	DWORD PTR [ebp-12]
 3379 1fb4 E8FCFFFF 		call	print
 3379      FF
 3380 1fb9 83C410   		add	esp, 16
 808:host.c        ****     
 809:host.c        ****     printAt("E820 Data: 0x",0,lineNo++);
 3381              		.loc 1 809 0
 3382 1fbc 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3383 1fbf 8D5001   		lea	edx, [eax+1]
 3384 1fc2 8955F0   		mov	DWORD PTR [ebp-16], edx
 3385 1fc5 83EC04   		sub	esp, 4
 3386 1fc8 50       		push	eax
 3387 1fc9 6A00     		push	0
 3388 1fcb 680E0400 		push	OFFSET FLAT:.LC49
 3388      00
 3389 1fd0 E8FCFFFF 		call	printAt
 3389      FF
 3390 1fd5 83C410   		add	esp, 16
 810:host.c        ****     pErr = Itoa(vhost.CodeBase + vhost.e820MemMap, pErr, 16);
 3391              		.loc 1 810 0
 3392 1fd8 8B150000 		mov	edx, DWORD PTR vhost
 3392      0000
 3393 1fde A1400000 		mov	eax, DWORD PTR vhost+64
 3393      00
 3394 1fe3 01D0     		add	eax, edx
 3395 1fe5 83EC04   		sub	esp, 4
 3396 1fe8 6A10     		push	16
 3397 1fea FF75F4   		push	DWORD PTR [ebp-12]
 3398 1fed 50       		push	eax
 3399 1fee E8FCFFFF 		call	Itoa
 3399      FF
 3400 1ff3 83C410   		add	esp, 16
 3401 1ff6 8945F4   		mov	DWORD PTR [ebp-12], eax
 811:host.c        ****     print (pErr);
 3402              		.loc 1 811 0
 3403 1ff9 83EC0C   		sub	esp, 12
 3404 1ffc FF75F4   		push	DWORD PTR [ebp-12]
 3405 1fff E8FCFFFF 		call	print
 3405      FF
 3406 2004 83C410   		add	esp, 16
 812:host.c        ****     
 813:host.c        ****     
 814:host.c        ****     printAt("Total Host Mem: 0x",0,lineNo++);
 3407              		.loc 1 814 0
 3408 2007 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3409 200a 8D5001   		lea	edx, [eax+1]
 3410 200d 8955F0   		mov	DWORD PTR [ebp-16], edx
 3411 2010 83EC04   		sub	esp, 4
 3412 2013 50       		push	eax
 3413 2014 6A00     		push	0
 3414 2016 681C0400 		push	OFFSET FLAT:.LC50
 3414      00
 3415 201b E8FCFFFF 		call	printAt
 3415      FF
 3416 2020 83C410   		add	esp, 16
 815:host.c        ****     DWORD lTotal = (vhost.CodeBase + vhost.e820MemMap + 1024) - vhost.CodeBase;
 3417              		.loc 1 815 0
 3418 2023 A1400000 		mov	eax, DWORD PTR vhost+64
 3418      00
 3419 2028 05000400 		add	eax, 1024
 3419      00
 3420 202d 8945EC   		mov	DWORD PTR [ebp-20], eax
 816:host.c        ****     pErr = Itoa(lTotal, pErr, 16);
 3421              		.loc 1 816 0
 3422 2030 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 3423 2033 83EC04   		sub	esp, 4
 3424 2036 6A10     		push	16
 3425 2038 FF75F4   		push	DWORD PTR [ebp-12]
 3426 203b 50       		push	eax
 3427 203c E8FCFFFF 		call	Itoa
 3427      FF
 3428 2041 83C410   		add	esp, 16
 3429 2044 8945F4   		mov	DWORD PTR [ebp-12], eax
 817:host.c        ****     print(pErr);
 3430              		.loc 1 817 0
 3431 2047 83EC0C   		sub	esp, 12
 3432 204a FF75F4   		push	DWORD PTR [ebp-12]
 3433 204d E8FCFFFF 		call	print
 3433      FF
 3434 2052 83C410   		add	esp, 16
 818:host.c        ****     print(" (");
 3435              		.loc 1 818 0
 3436 2055 83EC0C   		sub	esp, 12
 3437 2058 682F0400 		push	OFFSET FLAT:.LC51
 3437      00
 3438 205d E8FCFFFF 		call	print
 3438      FF
 3439 2062 83C410   		add	esp, 16
 819:host.c        ****     pErr = Itoa(lTotal, pErr, 10);
 3440              		.loc 1 819 0
 3441 2065 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 3442 2068 83EC04   		sub	esp, 4
 3443 206b 6A0A     		push	10
 3444 206d FF75F4   		push	DWORD PTR [ebp-12]
 3445 2070 50       		push	eax
 3446 2071 E8FCFFFF 		call	Itoa
 3446      FF
 3447 2076 83C410   		add	esp, 16
 3448 2079 8945F4   		mov	DWORD PTR [ebp-12], eax
 820:host.c        ****     print(pErr);
 3449              		.loc 1 820 0
 3450 207c 83EC0C   		sub	esp, 12
 3451 207f FF75F4   		push	DWORD PTR [ebp-12]
 3452 2082 E8FCFFFF 		call	print
 3452      FF
 3453 2087 83C410   		add	esp, 16
 821:host.c        ****     print(" bytes)");
 3454              		.loc 1 821 0
 3455 208a 83EC0C   		sub	esp, 12
 3456 208d 68320400 		push	OFFSET FLAT:.LC52
 3456      00
 3457 2092 E8FCFFFF 		call	print
 3457      FF
 3458 2097 83C410   		add	esp, 16
 822:host.c        ****     
 823:host.c        ****     HostScancode = 0;
 3459              		.loc 1 823 0
 3460 209a C6050000 		mov	BYTE PTR HostScancode, 0
 3460      000000
 824:host.c        ****     while (HostScancode == 0)
 3461              		.loc 1 824 0
 3462 20a1 90       		nop
 3463              	.L122:
 3464              		.loc 1 824 0 is_stmt 0 discriminator 1
 3465 20a2 0FB60500 		movzx	eax, BYTE PTR HostScancode
 3465      000000
 3466 20a9 84C0     		test	al, al
 3467 20ab 74F5     		je	.L122
 825:host.c        ****     {}
 826:host.c        **** }
 3468              		.loc 1 826 0 is_stmt 1
 3469 20ad 90       		nop
 3470 20ae C9       		leave
 3471              		.cfi_restore 5
 3472              		.cfi_def_cfa 4, 4
 3473 20af C3       		ret
 3474              		.cfi_endproc
 3475              	.LFE13:
 3477              		.section	.rodata
 3478              	.LC53:
 3479 043a 2A2A2A56 		.string	"***VMCB DUMP***"
 3479      4D434220 
 3479      44554D50 
 3479      2A2A2A00 
 3480              	.LC54:
 3481 044a 436F6E74 		.string	"Control Area"
 3481      726F6C20 
 3481      41726561 
 3481      00
 3482              	.LC55:
 3483 0457 43522052 		.string	"CR Read: "
 3483      6561643A 
 3483      2000
 3484              	.LC56:
 3485 0461 202D2043 		.string	" - CR Write: "
 3485      52205772 
 3485      6974653A 
 3485      2000
 3486              	.LC57:
 3487 046f 202D2044 		.string	" - DR Read: "
 3487      52205265 
 3487      61643A20 
 3487      00
 3488              	.LC58:
 3489 047c 202D2044 		.string	" - DR Write: "
 3489      52205772 
 3489      6974653A 
 3489      2000
 3490              	.LC59:
 3491 048a 45786365 		.string	"Exceptions: "
 3491      7074696F 
 3491      6E733A20 
 3491      00
 3492              	.LC60:
 3493 0497 202D2030 		.string	" - 0x0C: "
 3493      7830433A 
 3493      2000
 3494              	.LC61:
 3495 04a1 202D2030 		.string	" - 0x10: "
 3495      7831303A 
 3495      2000
 3496              	.LC62:
 3497 04ab 202D2049 		.string	" - IOPMB: "
 3497      4F504D42 
 3497      3A2000
 3498              	.LC63:
 3499 04b6 202D2054 		.string	" - TSC: "
 3499      53433A20 
 3499      00
 3500              	.LC64:
 3501 04bf 472D4153 		.string	"G-ASID: "
 3501      49443A20 
 3501      00
 3502              	.LC65:
 3503 04c8 202D2054 		.string	" - TLBC: "
 3503      4C42433A 
 3503      2000
 3504              	.LC66:
 3505 04d2 202D204E 		.string	" - NP-En: "
 3505      502D456E 
 3505      3A2000
 3506              	.LC67:
 3507 04dd 202D204E 		.string	" - N_CR3: "
 3507      5F435233 
 3507      3A2000
 3508              	.LC68:
 3509 04e8 434C4541 		.string	"CLEAN: "
 3509      4E3A2000 
 3510              	.LC69:
 3511 04f0 202D204E 		.string	" - N_RIP: "
 3511      5F524950 
 3511      3A2000
 3512              	.LC70:
 3513 04fb 53617665 		.string	"Save State: "
 3513      20537461 
 3513      74653A20 
 3513      00
 3514              	.LC71:
 3515 0508 43533A20 		.string	"CS: "
 3515      00
 3516              	.LC72:
 3517 050d 20202044 		.string	"   DS: "
 3517      533A2000 
 3518              	.LC73:
 3519 0515 20202045 		.string	"   ES: "
 3519      533A2000 
 3520              	.LC74:
 3521 051d 46533A20 		.string	"FS: "
 3521      00
 3522              	.LC75:
 3523 0522 20202047 		.string	"   GS: "
 3523      533A2000 
 3524              	.LC76:
 3525 052a 20202053 		.string	"   SS: "
 3525      533A2000 
 3526              	.LC77:
 3527 0532 20202047 		.string	"   GDTR: "
 3527      4454523A 
 3527      2000
 3528              	.LC78:
 3529 053c 2020204C 		.string	"   LDTR: "
 3529      4454523A 
 3529      2000
 3530              	.LC79:
 3531 0546 20202049 		.string	"   IDTR: "
 3531      4454523A 
 3531      2000
 3532              	.LC80:
 3533 0550 43504C3A 		.string	"CPL: "
 3533      2000
 3534              	.LC81:
 3535 0556 202D2045 		.string	" - EFER: "
 3535      4645523A 
 3535      2000
 3536              	.LC82:
 3537 0560 202D2043 		.string	" - CR4: "
 3537      52343A20 
 3537      00
 3538              	.LC83:
 3539 0569 202D2043 		.string	" - CR3: "
 3539      52333A20 
 3539      00
 3540              	.LC84:
 3541 0572 202D2043 		.string	" - CR0: "
 3541      52303A20 
 3541      00
 3542              	.LC85:
 3543 057b 202D2052 		.string	" - RFLAGS: "
 3543      464C4147 
 3543      533A2000 
 3544              	.LC86:
 3545 0587 202D2052 		.string	" - RIP: "
 3545      49503A20 
 3545      00
 3546              	.LC87:
 3547 0590 202D2052 		.string	" - RSP: "
 3547      53503A20 
 3547      00
 3548              	.LC88:
 3549 0599 202D2052 		.string	" - RAX: "
 3549      41583A20 
 3549      00
 3550              	.LC89:
 3551 05a2 202D2043 		.string	" - CR2: "
 3551      52323A20 
 3551      00
 3552              	.LC90:
 3553 05ab 45786974 		.string	"ExitCode: "
 3553      436F6465 
 3553      3A2000
 3554              	.LC91:
 3555 05b6 202D2045 		.string	" - ExitInfo1: "
 3555      78697449 
 3555      6E666F31 
 3555      3A2000
 3556              	.LC92:
 3557 05c5 202D2045 		.string	" - ExitInfo2: "
 3557      78697449 
 3557      6E666F32 
 3557      3A2000
 3558              		.text
 3559              		.globl	DumpVMCB
 3561              	DumpVMCB:
 3562              	.LFB14:
 827:host.c        **** 
 828:host.c        **** void DumpVMCB()
 829:host.c        **** {
 3563              		.loc 1 829 0
 3564              		.cfi_startproc
 3565 20b0 55       		push	ebp
 3566              		.cfi_def_cfa_offset 8
 3567              		.cfi_offset 5, -8
 3568 20b1 89E5     		mov	ebp, esp
 3569              		.cfi_def_cfa_register 5
 3570 20b3 83EC18   		sub	esp, 24
 830:host.c        ****     int rownum;
 831:host.c        ****     char *pErr = "                    \0";
 3571              		.loc 1 831 0
 3572 20b6 C745F4C9 		mov	DWORD PTR [ebp-12], OFFSET FLAT:.LC3
 3572      000000
 832:host.c        ****    
 833:host.c        ****     clrscr();
 3573              		.loc 1 833 0
 3574 20bd E8FCFFFF 		call	clrscr
 3574      FF
 834:host.c        ****     rownum = 0;
 3575              		.loc 1 834 0
 3576 20c2 C745F000 		mov	DWORD PTR [ebp-16], 0
 3576      000000
 835:host.c        ****     printAt("***VMCB DUMP***",0,rownum++);
 3577              		.loc 1 835 0
 3578 20c9 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3579 20cc 8D5001   		lea	edx, [eax+1]
 3580 20cf 8955F0   		mov	DWORD PTR [ebp-16], edx
 3581 20d2 83EC04   		sub	esp, 4
 3582 20d5 50       		push	eax
 3583 20d6 6A00     		push	0
 3584 20d8 683A0400 		push	OFFSET FLAT:.LC53
 3584      00
 3585 20dd E8FCFFFF 		call	printAt
 3585      FF
 3586 20e2 83C410   		add	esp, 16
 836:host.c        ****     printAt("Control Area",0,rownum++);
 3587              		.loc 1 836 0
 3588 20e5 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3589 20e8 8D5001   		lea	edx, [eax+1]
 3590 20eb 8955F0   		mov	DWORD PTR [ebp-16], edx
 3591 20ee 83EC04   		sub	esp, 4
 3592 20f1 50       		push	eax
 3593 20f2 6A00     		push	0
 3594 20f4 684A0400 		push	OFFSET FLAT:.LC54
 3594      00
 3595 20f9 E8FCFFFF 		call	printAt
 3595      FF
 3596 20fe 83C410   		add	esp, 16
 837:host.c        ****     printAt("CR Read: ",0,rownum++);
 3597              		.loc 1 837 0
 3598 2101 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3599 2104 8D5001   		lea	edx, [eax+1]
 3600 2107 8955F0   		mov	DWORD PTR [ebp-16], edx
 3601 210a 83EC04   		sub	esp, 4
 3602 210d 50       		push	eax
 3603 210e 6A00     		push	0
 3604 2110 68570400 		push	OFFSET FLAT:.LC55
 3604      00
 3605 2115 E8FCFFFF 		call	printAt
 3605      FF
 3606 211a 83C410   		add	esp, 16
 838:host.c        ****     pErr = Itoa((WORD)guest.vmcb->cr_intercepts, pErr, 16);
 3607              		.loc 1 838 0
 3608 211d A1040000 		mov	eax, DWORD PTR guest+4
 3608      00
 3609 2122 8B00     		mov	eax, DWORD PTR [eax]
 3610 2124 0FB7C0   		movzx	eax, ax
 3611 2127 83EC04   		sub	esp, 4
 3612 212a 6A10     		push	16
 3613 212c FF75F4   		push	DWORD PTR [ebp-12]
 3614 212f 50       		push	eax
 3615 2130 E8FCFFFF 		call	Itoa
 3615      FF
 3616 2135 83C410   		add	esp, 16
 3617 2138 8945F4   		mov	DWORD PTR [ebp-12], eax
 839:host.c        ****     print(pErr);
 3618              		.loc 1 839 0
 3619 213b 83EC0C   		sub	esp, 12
 3620 213e FF75F4   		push	DWORD PTR [ebp-12]
 3621 2141 E8FCFFFF 		call	print
 3621      FF
 3622 2146 83C410   		add	esp, 16
 840:host.c        ****     print(" - CR Write: ");
 3623              		.loc 1 840 0
 3624 2149 83EC0C   		sub	esp, 12
 3625 214c 68610400 		push	OFFSET FLAT:.LC56
 3625      00
 3626 2151 E8FCFFFF 		call	print
 3626      FF
 3627 2156 83C410   		add	esp, 16
 841:host.c        ****     pErr = Itoa((WORD)guest.vmcb->cr_intercepts >> 16, pErr, 16);
 3628              		.loc 1 841 0
 3629 2159 83EC04   		sub	esp, 4
 3630 215c 6A10     		push	16
 3631 215e FF75F4   		push	DWORD PTR [ebp-12]
 3632 2161 6A00     		push	0
 3633 2163 E8FCFFFF 		call	Itoa
 3633      FF
 3634 2168 83C410   		add	esp, 16
 3635 216b 8945F4   		mov	DWORD PTR [ebp-12], eax
 842:host.c        ****     print(pErr);
 3636              		.loc 1 842 0
 3637 216e 83EC0C   		sub	esp, 12
 3638 2171 FF75F4   		push	DWORD PTR [ebp-12]
 3639 2174 E8FCFFFF 		call	print
 3639      FF
 3640 2179 83C410   		add	esp, 16
 843:host.c        ****     print(" - DR Read: ");
 3641              		.loc 1 843 0
 3642 217c 83EC0C   		sub	esp, 12
 3643 217f 686F0400 		push	OFFSET FLAT:.LC57
 3643      00
 3644 2184 E8FCFFFF 		call	print
 3644      FF
 3645 2189 83C410   		add	esp, 16
 844:host.c        ****     pErr = Itoa((WORD)guest.vmcb->dr_intercepts, pErr, 16);
 3646              		.loc 1 844 0
 3647 218c A1040000 		mov	eax, DWORD PTR guest+4
 3647      00
 3648 2191 8B4004   		mov	eax, DWORD PTR [eax+4]
 3649 2194 0FB7C0   		movzx	eax, ax
 3650 2197 83EC04   		sub	esp, 4
 3651 219a 6A10     		push	16
 3652 219c FF75F4   		push	DWORD PTR [ebp-12]
 3653 219f 50       		push	eax
 3654 21a0 E8FCFFFF 		call	Itoa
 3654      FF
 3655 21a5 83C410   		add	esp, 16
 3656 21a8 8945F4   		mov	DWORD PTR [ebp-12], eax
 845:host.c        ****     print(pErr);
 3657              		.loc 1 845 0
 3658 21ab 83EC0C   		sub	esp, 12
 3659 21ae FF75F4   		push	DWORD PTR [ebp-12]
 3660 21b1 E8FCFFFF 		call	print
 3660      FF
 3661 21b6 83C410   		add	esp, 16
 846:host.c        ****     print(" - DR Write: ");
 3662              		.loc 1 846 0
 3663 21b9 83EC0C   		sub	esp, 12
 3664 21bc 687C0400 		push	OFFSET FLAT:.LC58
 3664      00
 3665 21c1 E8FCFFFF 		call	print
 3665      FF
 3666 21c6 83C410   		add	esp, 16
 847:host.c        ****     pErr = Itoa((WORD)guest.vmcb->dr_intercepts >> 16, pErr, 16);
 3667              		.loc 1 847 0
 3668 21c9 83EC04   		sub	esp, 4
 3669 21cc 6A10     		push	16
 3670 21ce FF75F4   		push	DWORD PTR [ebp-12]
 3671 21d1 6A00     		push	0
 3672 21d3 E8FCFFFF 		call	Itoa
 3672      FF
 3673 21d8 83C410   		add	esp, 16
 3674 21db 8945F4   		mov	DWORD PTR [ebp-12], eax
 848:host.c        ****     print(pErr);
 3675              		.loc 1 848 0
 3676 21de 83EC0C   		sub	esp, 12
 3677 21e1 FF75F4   		push	DWORD PTR [ebp-12]
 3678 21e4 E8FCFFFF 		call	print
 3678      FF
 3679 21e9 83C410   		add	esp, 16
 849:host.c        ****     printAt("Exceptions: ",0,rownum++);
 3680              		.loc 1 849 0
 3681 21ec 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3682 21ef 8D5001   		lea	edx, [eax+1]
 3683 21f2 8955F0   		mov	DWORD PTR [ebp-16], edx
 3684 21f5 83EC04   		sub	esp, 4
 3685 21f8 50       		push	eax
 3686 21f9 6A00     		push	0
 3687 21fb 688A0400 		push	OFFSET FLAT:.LC59
 3687      00
 3688 2200 E8FCFFFF 		call	printAt
 3688      FF
 3689 2205 83C410   		add	esp, 16
 850:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->exception_intercepts, pErr, 16);
 3690              		.loc 1 850 0
 3691 2208 A1040000 		mov	eax, DWORD PTR guest+4
 3691      00
 3692 220d 8B4008   		mov	eax, DWORD PTR [eax+8]
 3693 2210 83EC04   		sub	esp, 4
 3694 2213 6A10     		push	16
 3695 2215 FF75F4   		push	DWORD PTR [ebp-12]
 3696 2218 50       		push	eax
 3697 2219 E8FCFFFF 		call	Itoa
 3697      FF
 3698 221e 83C410   		add	esp, 16
 3699 2221 8945F4   		mov	DWORD PTR [ebp-12], eax
 851:host.c        ****     print(pErr);
 3700              		.loc 1 851 0
 3701 2224 83EC0C   		sub	esp, 12
 3702 2227 FF75F4   		push	DWORD PTR [ebp-12]
 3703 222a E8FCFFFF 		call	print
 3703      FF
 3704 222f 83C410   		add	esp, 16
 852:host.c        ****     print(" - 0x0C: ");
 3705              		.loc 1 852 0
 3706 2232 83EC0C   		sub	esp, 12
 3707 2235 68970400 		push	OFFSET FLAT:.LC60
 3707      00
 3708 223a E8FCFFFF 		call	print
 3708      FF
 3709 223f 83C410   		add	esp, 16
 853:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->general1_intercepts, pErr, 16);
 3710              		.loc 1 853 0
 3711 2242 A1040000 		mov	eax, DWORD PTR guest+4
 3711      00
 3712 2247 8B400C   		mov	eax, DWORD PTR [eax+12]
 3713 224a 83EC04   		sub	esp, 4
 3714 224d 6A10     		push	16
 3715 224f FF75F4   		push	DWORD PTR [ebp-12]
 3716 2252 50       		push	eax
 3717 2253 E8FCFFFF 		call	Itoa
 3717      FF
 3718 2258 83C410   		add	esp, 16
 3719 225b 8945F4   		mov	DWORD PTR [ebp-12], eax
 854:host.c        ****     print(pErr);
 3720              		.loc 1 854 0
 3721 225e 83EC0C   		sub	esp, 12
 3722 2261 FF75F4   		push	DWORD PTR [ebp-12]
 3723 2264 E8FCFFFF 		call	print
 3723      FF
 3724 2269 83C410   		add	esp, 16
 855:host.c        ****     print(" - 0x10: ");
 3725              		.loc 1 855 0
 3726 226c 83EC0C   		sub	esp, 12
 3727 226f 68A10400 		push	OFFSET FLAT:.LC61
 3727      00
 3728 2274 E8FCFFFF 		call	print
 3728      FF
 3729 2279 83C410   		add	esp, 16
 856:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->general2_intercepts, pErr, 16);
 3730              		.loc 1 856 0
 3731 227c A1040000 		mov	eax, DWORD PTR guest+4
 3731      00
 3732 2281 8B4010   		mov	eax, DWORD PTR [eax+16]
 3733 2284 83EC04   		sub	esp, 4
 3734 2287 6A10     		push	16
 3735 2289 FF75F4   		push	DWORD PTR [ebp-12]
 3736 228c 50       		push	eax
 3737 228d E8FCFFFF 		call	Itoa
 3737      FF
 3738 2292 83C410   		add	esp, 16
 3739 2295 8945F4   		mov	DWORD PTR [ebp-12], eax
 857:host.c        ****     print(pErr);
 3740              		.loc 1 857 0
 3741 2298 83EC0C   		sub	esp, 12
 3742 229b FF75F4   		push	DWORD PTR [ebp-12]
 3743 229e E8FCFFFF 		call	print
 3743      FF
 3744 22a3 83C410   		add	esp, 16
 858:host.c        ****     print(" - IOPMB: ");
 3745              		.loc 1 858 0
 3746 22a6 83EC0C   		sub	esp, 12
 3747 22a9 68AB0400 		push	OFFSET FLAT:.LC62
 3747      00
 3748 22ae E8FCFFFF 		call	print
 3748      FF
 3749 22b3 83C410   		add	esp, 16
 859:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->iopm_base_pa, pErr, 16);
 3750              		.loc 1 859 0
 3751 22b6 A1040000 		mov	eax, DWORD PTR guest+4
 3751      00
 3752 22bb 8B5044   		mov	edx, DWORD PTR [eax+68]
 3753 22be 8B4040   		mov	eax, DWORD PTR [eax+64]
 3754 22c1 83EC04   		sub	esp, 4
 3755 22c4 6A10     		push	16
 3756 22c6 FF75F4   		push	DWORD PTR [ebp-12]
 3757 22c9 50       		push	eax
 3758 22ca E8FCFFFF 		call	Itoa
 3758      FF
 3759 22cf 83C410   		add	esp, 16
 3760 22d2 8945F4   		mov	DWORD PTR [ebp-12], eax
 860:host.c        ****     print(pErr);
 3761              		.loc 1 860 0
 3762 22d5 83EC0C   		sub	esp, 12
 3763 22d8 FF75F4   		push	DWORD PTR [ebp-12]
 3764 22db E8FCFFFF 		call	print
 3764      FF
 3765 22e0 83C410   		add	esp, 16
 861:host.c        ****     print(" - TSC: ");
 3766              		.loc 1 861 0
 3767 22e3 83EC0C   		sub	esp, 12
 3768 22e6 68B60400 		push	OFFSET FLAT:.LC63
 3768      00
 3769 22eb E8FCFFFF 		call	print
 3769      FF
 3770 22f0 83C410   		add	esp, 16
 862:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->tsc_offset, pErr, 16);
 3771              		.loc 1 862 0
 3772 22f3 A1040000 		mov	eax, DWORD PTR guest+4
 3772      00
 3773 22f8 8B5054   		mov	edx, DWORD PTR [eax+84]
 3774 22fb 8B4050   		mov	eax, DWORD PTR [eax+80]
 3775 22fe 83EC04   		sub	esp, 4
 3776 2301 6A10     		push	16
 3777 2303 FF75F4   		push	DWORD PTR [ebp-12]
 3778 2306 50       		push	eax
 3779 2307 E8FCFFFF 		call	Itoa
 3779      FF
 3780 230c 83C410   		add	esp, 16
 3781 230f 8945F4   		mov	DWORD PTR [ebp-12], eax
 863:host.c        ****     print(pErr);
 3782              		.loc 1 863 0
 3783 2312 83EC0C   		sub	esp, 12
 3784 2315 FF75F4   		push	DWORD PTR [ebp-12]
 3785 2318 E8FCFFFF 		call	print
 3785      FF
 3786 231d 83C410   		add	esp, 16
 864:host.c        ****     printAt("G-ASID: ",0,rownum++);
 3787              		.loc 1 864 0
 3788 2320 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3789 2323 8D5001   		lea	edx, [eax+1]
 3790 2326 8955F0   		mov	DWORD PTR [ebp-16], edx
 3791 2329 83EC04   		sub	esp, 4
 3792 232c 50       		push	eax
 3793 232d 6A00     		push	0
 3794 232f 68BF0400 		push	OFFSET FLAT:.LC64
 3794      00
 3795 2334 E8FCFFFF 		call	printAt
 3795      FF
 3796 2339 83C410   		add	esp, 16
 865:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->guest_asid, pErr, 16);
 3797              		.loc 1 865 0
 3798 233c A1040000 		mov	eax, DWORD PTR guest+4
 3798      00
 3799 2341 8B4058   		mov	eax, DWORD PTR [eax+88]
 3800 2344 83EC04   		sub	esp, 4
 3801 2347 6A10     		push	16
 3802 2349 FF75F4   		push	DWORD PTR [ebp-12]
 3803 234c 50       		push	eax
 3804 234d E8FCFFFF 		call	Itoa
 3804      FF
 3805 2352 83C410   		add	esp, 16
 3806 2355 8945F4   		mov	DWORD PTR [ebp-12], eax
 866:host.c        ****     print(pErr);
 3807              		.loc 1 866 0
 3808 2358 83EC0C   		sub	esp, 12
 3809 235b FF75F4   		push	DWORD PTR [ebp-12]
 3810 235e E8FCFFFF 		call	print
 3810      FF
 3811 2363 83C410   		add	esp, 16
 867:host.c        ****     print(" - TLBC: ");
 3812              		.loc 1 867 0
 3813 2366 83EC0C   		sub	esp, 12
 3814 2369 68C80400 		push	OFFSET FLAT:.LC65
 3814      00
 3815 236e E8FCFFFF 		call	print
 3815      FF
 3816 2373 83C410   		add	esp, 16
 868:host.c        ****     pErr = Itoa((BYTE)guest.vmcb->tlb_control, pErr, 16);
 3817              		.loc 1 868 0
 3818 2376 A1040000 		mov	eax, DWORD PTR guest+4
 3818      00
 3819 237b 0FB6405C 		movzx	eax, BYTE PTR [eax+92]
 3820 237f 0FB6C0   		movzx	eax, al
 3821 2382 83EC04   		sub	esp, 4
 3822 2385 6A10     		push	16
 3823 2387 FF75F4   		push	DWORD PTR [ebp-12]
 3824 238a 50       		push	eax
 3825 238b E8FCFFFF 		call	Itoa
 3825      FF
 3826 2390 83C410   		add	esp, 16
 3827 2393 8945F4   		mov	DWORD PTR [ebp-12], eax
 869:host.c        ****     print(pErr);
 3828              		.loc 1 869 0
 3829 2396 83EC0C   		sub	esp, 12
 3830 2399 FF75F4   		push	DWORD PTR [ebp-12]
 3831 239c E8FCFFFF 		call	print
 3831      FF
 3832 23a1 83C410   		add	esp, 16
 870:host.c        ****     print(" - NP-En: ");
 3833              		.loc 1 870 0
 3834 23a4 83EC0C   		sub	esp, 12
 3835 23a7 68D20400 		push	OFFSET FLAT:.LC66
 3835      00
 3836 23ac E8FCFFFF 		call	print
 3836      FF
 3837 23b1 83C410   		add	esp, 16
 871:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->np_enable, pErr, 16);
 3838              		.loc 1 871 0
 3839 23b4 A1040000 		mov	eax, DWORD PTR guest+4
 3839      00
 3840 23b9 8B909400 		mov	edx, DWORD PTR [eax+148]
 3840      0000
 3841 23bf 8B809000 		mov	eax, DWORD PTR [eax+144]
 3841      0000
 3842 23c5 83EC04   		sub	esp, 4
 3843 23c8 6A10     		push	16
 3844 23ca FF75F4   		push	DWORD PTR [ebp-12]
 3845 23cd 50       		push	eax
 3846 23ce E8FCFFFF 		call	Itoa
 3846      FF
 3847 23d3 83C410   		add	esp, 16
 3848 23d6 8945F4   		mov	DWORD PTR [ebp-12], eax
 872:host.c        ****     print(pErr);
 3849              		.loc 1 872 0
 3850 23d9 83EC0C   		sub	esp, 12
 3851 23dc FF75F4   		push	DWORD PTR [ebp-12]
 3852 23df E8FCFFFF 		call	print
 3852      FF
 3853 23e4 83C410   		add	esp, 16
 873:host.c        ****     print(" - N_CR3: ");
 3854              		.loc 1 873 0
 3855 23e7 83EC0C   		sub	esp, 12
 3856 23ea 68DD0400 		push	OFFSET FLAT:.LC67
 3856      00
 3857 23ef E8FCFFFF 		call	print
 3857      FF
 3858 23f4 83C410   		add	esp, 16
 874:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->nested_cr3, pErr, 16);
 3859              		.loc 1 874 0
 3860 23f7 A1040000 		mov	eax, DWORD PTR guest+4
 3860      00
 3861 23fc 8B90B400 		mov	edx, DWORD PTR [eax+180]
 3861      0000
 3862 2402 8B80B000 		mov	eax, DWORD PTR [eax+176]
 3862      0000
 3863 2408 83EC04   		sub	esp, 4
 3864 240b 6A10     		push	16
 3865 240d FF75F4   		push	DWORD PTR [ebp-12]
 3866 2410 50       		push	eax
 3867 2411 E8FCFFFF 		call	Itoa
 3867      FF
 3868 2416 83C410   		add	esp, 16
 3869 2419 8945F4   		mov	DWORD PTR [ebp-12], eax
 875:host.c        ****     print(pErr);
 3870              		.loc 1 875 0
 3871 241c 83EC0C   		sub	esp, 12
 3872 241f FF75F4   		push	DWORD PTR [ebp-12]
 3873 2422 E8FCFFFF 		call	print
 3873      FF
 3874 2427 83C410   		add	esp, 16
 876:host.c        ****     printAt("CLEAN: ",0,rownum++);
 3875              		.loc 1 876 0
 3876 242a 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3877 242d 8D5001   		lea	edx, [eax+1]
 3878 2430 8955F0   		mov	DWORD PTR [ebp-16], edx
 3879 2433 83EC04   		sub	esp, 4
 3880 2436 50       		push	eax
 3881 2437 6A00     		push	0
 3882 2439 68E80400 		push	OFFSET FLAT:.LC68
 3882      00
 3883 243e E8FCFFFF 		call	printAt
 3883      FF
 3884 2443 83C410   		add	esp, 16
 877:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->clean_bits, pErr, 16);
 3885              		.loc 1 877 0
 3886 2446 A1040000 		mov	eax, DWORD PTR guest+4
 3886      00
 3887 244b 8B80C000 		mov	eax, DWORD PTR [eax+192]
 3887      0000
 3888 2451 83EC04   		sub	esp, 4
 3889 2454 6A10     		push	16
 3890 2456 FF75F4   		push	DWORD PTR [ebp-12]
 3891 2459 50       		push	eax
 3892 245a E8FCFFFF 		call	Itoa
 3892      FF
 3893 245f 83C410   		add	esp, 16
 3894 2462 8945F4   		mov	DWORD PTR [ebp-12], eax
 878:host.c        ****     print(pErr);
 3895              		.loc 1 878 0
 3896 2465 83EC0C   		sub	esp, 12
 3897 2468 FF75F4   		push	DWORD PTR [ebp-12]
 3898 246b E8FCFFFF 		call	print
 3898      FF
 3899 2470 83C410   		add	esp, 16
 879:host.c        ****     print(" - N_RIP: ");
 3900              		.loc 1 879 0
 3901 2473 83EC0C   		sub	esp, 12
 3902 2476 68F00400 		push	OFFSET FLAT:.LC69
 3902      00
 3903 247b E8FCFFFF 		call	print
 3903      FF
 3904 2480 83C410   		add	esp, 16
 880:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->nextrip, pErr, 16);
 3905              		.loc 1 880 0
 3906 2483 A1040000 		mov	eax, DWORD PTR guest+4
 3906      00
 3907 2488 8B90CC00 		mov	edx, DWORD PTR [eax+204]
 3907      0000
 3908 248e 8B80C800 		mov	eax, DWORD PTR [eax+200]
 3908      0000
 3909 2494 83EC04   		sub	esp, 4
 3910 2497 6A10     		push	16
 3911 2499 FF75F4   		push	DWORD PTR [ebp-12]
 3912 249c 50       		push	eax
 3913 249d E8FCFFFF 		call	Itoa
 3913      FF
 3914 24a2 83C410   		add	esp, 16
 3915 24a5 8945F4   		mov	DWORD PTR [ebp-12], eax
 881:host.c        ****     print(pErr);
 3916              		.loc 1 881 0
 3917 24a8 83EC0C   		sub	esp, 12
 3918 24ab FF75F4   		push	DWORD PTR [ebp-12]
 3919 24ae E8FCFFFF 		call	print
 3919      FF
 3920 24b3 83C410   		add	esp, 16
 882:host.c        **** 
 883:host.c        ****     printAt("Save State: ",0,rownum++);
 3921              		.loc 1 883 0
 3922 24b6 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3923 24b9 8D5001   		lea	edx, [eax+1]
 3924 24bc 8955F0   		mov	DWORD PTR [ebp-16], edx
 3925 24bf 83EC04   		sub	esp, 4
 3926 24c2 50       		push	eax
 3927 24c3 6A00     		push	0
 3928 24c5 68FB0400 		push	OFFSET FLAT:.LC70
 3928      00
 3929 24ca E8FCFFFF 		call	printAt
 3929      FF
 3930 24cf 83C410   		add	esp, 16
 884:host.c        **** 
 885:host.c        ****     printAt("CS: ",0,rownum++);
 3931              		.loc 1 885 0
 3932 24d2 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 3933 24d5 8D5001   		lea	edx, [eax+1]
 3934 24d8 8955F0   		mov	DWORD PTR [ebp-16], edx
 3935 24db 83EC04   		sub	esp, 4
 3936 24de 50       		push	eax
 3937 24df 6A00     		push	0
 3938 24e1 68080500 		push	OFFSET FLAT:.LC71
 3938      00
 3939 24e6 E8FCFFFF 		call	printAt
 3939      FF
 3940 24eb 83C410   		add	esp, 16
 886:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->cs.base, pErr, 16);
 3941              		.loc 1 886 0
 3942 24ee A1040000 		mov	eax, DWORD PTR guest+4
 3942      00
 3943 24f3 8B901C04 		mov	edx, DWORD PTR [eax+1052]
 3943      0000
 3944 24f9 8B801804 		mov	eax, DWORD PTR [eax+1048]
 3944      0000
 3945 24ff 83EC04   		sub	esp, 4
 3946 2502 6A10     		push	16
 3947 2504 FF75F4   		push	DWORD PTR [ebp-12]
 3948 2507 50       		push	eax
 3949 2508 E8FCFFFF 		call	Itoa
 3949      FF
 3950 250d 83C410   		add	esp, 16
 3951 2510 8945F4   		mov	DWORD PTR [ebp-12], eax
 887:host.c        ****     print(pErr);
 3952              		.loc 1 887 0
 3953 2513 83EC0C   		sub	esp, 12
 3954 2516 FF75F4   		push	DWORD PTR [ebp-12]
 3955 2519 E8FCFFFF 		call	print
 3955      FF
 3956 251e 83C410   		add	esp, 16
 888:host.c        ****     print(":");
 3957              		.loc 1 888 0
 3958 2521 83EC0C   		sub	esp, 12
 3959 2524 681A0000 		push	OFFSET FLAT:.LC1
 3959      00
 3960 2529 E8FCFFFF 		call	print
 3960      FF
 3961 252e 83C410   		add	esp, 16
 889:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->cs.limit, pErr, 16);
 3962              		.loc 1 889 0
 3963 2531 A1040000 		mov	eax, DWORD PTR guest+4
 3963      00
 3964 2536 8B801404 		mov	eax, DWORD PTR [eax+1044]
 3964      0000
 3965 253c 83EC04   		sub	esp, 4
 3966 253f 6A10     		push	16
 3967 2541 FF75F4   		push	DWORD PTR [ebp-12]
 3968 2544 50       		push	eax
 3969 2545 E8FCFFFF 		call	Itoa
 3969      FF
 3970 254a 83C410   		add	esp, 16
 3971 254d 8945F4   		mov	DWORD PTR [ebp-12], eax
 890:host.c        ****     print(pErr);
 3972              		.loc 1 890 0
 3973 2550 83EC0C   		sub	esp, 12
 3974 2553 FF75F4   		push	DWORD PTR [ebp-12]
 3975 2556 E8FCFFFF 		call	print
 3975      FF
 3976 255b 83C410   		add	esp, 16
 891:host.c        ****     print(":");
 3977              		.loc 1 891 0
 3978 255e 83EC0C   		sub	esp, 12
 3979 2561 681A0000 		push	OFFSET FLAT:.LC1
 3979      00
 3980 2566 E8FCFFFF 		call	print
 3980      FF
 3981 256b 83C410   		add	esp, 16
 892:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->cs.sel, pErr, 16);
 3982              		.loc 1 892 0
 3983 256e A1040000 		mov	eax, DWORD PTR guest+4
 3983      00
 3984 2573 0FB78010 		movzx	eax, WORD PTR [eax+1040]
 3984      040000
 3985 257a 0FB7C0   		movzx	eax, ax
 3986 257d 83EC04   		sub	esp, 4
 3987 2580 6A10     		push	16
 3988 2582 FF75F4   		push	DWORD PTR [ebp-12]
 3989 2585 50       		push	eax
 3990 2586 E8FCFFFF 		call	Itoa
 3990      FF
 3991 258b 83C410   		add	esp, 16
 3992 258e 8945F4   		mov	DWORD PTR [ebp-12], eax
 893:host.c        ****     print(pErr);
 3993              		.loc 1 893 0
 3994 2591 83EC0C   		sub	esp, 12
 3995 2594 FF75F4   		push	DWORD PTR [ebp-12]
 3996 2597 E8FCFFFF 		call	print
 3996      FF
 3997 259c 83C410   		add	esp, 16
 894:host.c        **** 
 895:host.c        ****     print("   DS: ");
 3998              		.loc 1 895 0
 3999 259f 83EC0C   		sub	esp, 12
 4000 25a2 680D0500 		push	OFFSET FLAT:.LC72
 4000      00
 4001 25a7 E8FCFFFF 		call	print
 4001      FF
 4002 25ac 83C410   		add	esp, 16
 896:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->ds.base, pErr, 16);
 4003              		.loc 1 896 0
 4004 25af A1040000 		mov	eax, DWORD PTR guest+4
 4004      00
 4005 25b4 8B903C04 		mov	edx, DWORD PTR [eax+1084]
 4005      0000
 4006 25ba 8B803804 		mov	eax, DWORD PTR [eax+1080]
 4006      0000
 4007 25c0 83EC04   		sub	esp, 4
 4008 25c3 6A10     		push	16
 4009 25c5 FF75F4   		push	DWORD PTR [ebp-12]
 4010 25c8 50       		push	eax
 4011 25c9 E8FCFFFF 		call	Itoa
 4011      FF
 4012 25ce 83C410   		add	esp, 16
 4013 25d1 8945F4   		mov	DWORD PTR [ebp-12], eax
 897:host.c        ****     print(pErr);
 4014              		.loc 1 897 0
 4015 25d4 83EC0C   		sub	esp, 12
 4016 25d7 FF75F4   		push	DWORD PTR [ebp-12]
 4017 25da E8FCFFFF 		call	print
 4017      FF
 4018 25df 83C410   		add	esp, 16
 898:host.c        ****     print(":");
 4019              		.loc 1 898 0
 4020 25e2 83EC0C   		sub	esp, 12
 4021 25e5 681A0000 		push	OFFSET FLAT:.LC1
 4021      00
 4022 25ea E8FCFFFF 		call	print
 4022      FF
 4023 25ef 83C410   		add	esp, 16
 899:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->ds.limit, pErr, 16);
 4024              		.loc 1 899 0
 4025 25f2 A1040000 		mov	eax, DWORD PTR guest+4
 4025      00
 4026 25f7 8B803404 		mov	eax, DWORD PTR [eax+1076]
 4026      0000
 4027 25fd 83EC04   		sub	esp, 4
 4028 2600 6A10     		push	16
 4029 2602 FF75F4   		push	DWORD PTR [ebp-12]
 4030 2605 50       		push	eax
 4031 2606 E8FCFFFF 		call	Itoa
 4031      FF
 4032 260b 83C410   		add	esp, 16
 4033 260e 8945F4   		mov	DWORD PTR [ebp-12], eax
 900:host.c        ****     print(pErr);
 4034              		.loc 1 900 0
 4035 2611 83EC0C   		sub	esp, 12
 4036 2614 FF75F4   		push	DWORD PTR [ebp-12]
 4037 2617 E8FCFFFF 		call	print
 4037      FF
 4038 261c 83C410   		add	esp, 16
 901:host.c        ****     print(":");
 4039              		.loc 1 901 0
 4040 261f 83EC0C   		sub	esp, 12
 4041 2622 681A0000 		push	OFFSET FLAT:.LC1
 4041      00
 4042 2627 E8FCFFFF 		call	print
 4042      FF
 4043 262c 83C410   		add	esp, 16
 902:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->ds.sel, pErr, 16);
 4044              		.loc 1 902 0
 4045 262f A1040000 		mov	eax, DWORD PTR guest+4
 4045      00
 4046 2634 0FB78030 		movzx	eax, WORD PTR [eax+1072]
 4046      040000
 4047 263b 0FB7C0   		movzx	eax, ax
 4048 263e 83EC04   		sub	esp, 4
 4049 2641 6A10     		push	16
 4050 2643 FF75F4   		push	DWORD PTR [ebp-12]
 4051 2646 50       		push	eax
 4052 2647 E8FCFFFF 		call	Itoa
 4052      FF
 4053 264c 83C410   		add	esp, 16
 4054 264f 8945F4   		mov	DWORD PTR [ebp-12], eax
 903:host.c        ****     print(pErr);
 4055              		.loc 1 903 0
 4056 2652 83EC0C   		sub	esp, 12
 4057 2655 FF75F4   		push	DWORD PTR [ebp-12]
 4058 2658 E8FCFFFF 		call	print
 4058      FF
 4059 265d 83C410   		add	esp, 16
 904:host.c        **** 
 905:host.c        ****     print("   ES: ");
 4060              		.loc 1 905 0
 4061 2660 83EC0C   		sub	esp, 12
 4062 2663 68150500 		push	OFFSET FLAT:.LC73
 4062      00
 4063 2668 E8FCFFFF 		call	print
 4063      FF
 4064 266d 83C410   		add	esp, 16
 906:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->es.base, pErr, 16);
 4065              		.loc 1 906 0
 4066 2670 A1040000 		mov	eax, DWORD PTR guest+4
 4066      00
 4067 2675 8B900C04 		mov	edx, DWORD PTR [eax+1036]
 4067      0000
 4068 267b 8B800804 		mov	eax, DWORD PTR [eax+1032]
 4068      0000
 4069 2681 83EC04   		sub	esp, 4
 4070 2684 6A10     		push	16
 4071 2686 FF75F4   		push	DWORD PTR [ebp-12]
 4072 2689 50       		push	eax
 4073 268a E8FCFFFF 		call	Itoa
 4073      FF
 4074 268f 83C410   		add	esp, 16
 4075 2692 8945F4   		mov	DWORD PTR [ebp-12], eax
 907:host.c        ****     print(pErr);
 4076              		.loc 1 907 0
 4077 2695 83EC0C   		sub	esp, 12
 4078 2698 FF75F4   		push	DWORD PTR [ebp-12]
 4079 269b E8FCFFFF 		call	print
 4079      FF
 4080 26a0 83C410   		add	esp, 16
 908:host.c        ****     print(":");
 4081              		.loc 1 908 0
 4082 26a3 83EC0C   		sub	esp, 12
 4083 26a6 681A0000 		push	OFFSET FLAT:.LC1
 4083      00
 4084 26ab E8FCFFFF 		call	print
 4084      FF
 4085 26b0 83C410   		add	esp, 16
 909:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->es.limit, pErr, 16);
 4086              		.loc 1 909 0
 4087 26b3 A1040000 		mov	eax, DWORD PTR guest+4
 4087      00
 4088 26b8 8B800404 		mov	eax, DWORD PTR [eax+1028]
 4088      0000
 4089 26be 83EC04   		sub	esp, 4
 4090 26c1 6A10     		push	16
 4091 26c3 FF75F4   		push	DWORD PTR [ebp-12]
 4092 26c6 50       		push	eax
 4093 26c7 E8FCFFFF 		call	Itoa
 4093      FF
 4094 26cc 83C410   		add	esp, 16
 4095 26cf 8945F4   		mov	DWORD PTR [ebp-12], eax
 910:host.c        ****     print(pErr);
 4096              		.loc 1 910 0
 4097 26d2 83EC0C   		sub	esp, 12
 4098 26d5 FF75F4   		push	DWORD PTR [ebp-12]
 4099 26d8 E8FCFFFF 		call	print
 4099      FF
 4100 26dd 83C410   		add	esp, 16
 911:host.c        ****     print(":");
 4101              		.loc 1 911 0
 4102 26e0 83EC0C   		sub	esp, 12
 4103 26e3 681A0000 		push	OFFSET FLAT:.LC1
 4103      00
 4104 26e8 E8FCFFFF 		call	print
 4104      FF
 4105 26ed 83C410   		add	esp, 16
 912:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->es.sel, pErr, 16);
 4106              		.loc 1 912 0
 4107 26f0 A1040000 		mov	eax, DWORD PTR guest+4
 4107      00
 4108 26f5 0FB78000 		movzx	eax, WORD PTR [eax+1024]
 4108      040000
 4109 26fc 0FB7C0   		movzx	eax, ax
 4110 26ff 83EC04   		sub	esp, 4
 4111 2702 6A10     		push	16
 4112 2704 FF75F4   		push	DWORD PTR [ebp-12]
 4113 2707 50       		push	eax
 4114 2708 E8FCFFFF 		call	Itoa
 4114      FF
 4115 270d 83C410   		add	esp, 16
 4116 2710 8945F4   		mov	DWORD PTR [ebp-12], eax
 913:host.c        ****     print(pErr);
 4117              		.loc 1 913 0
 4118 2713 83EC0C   		sub	esp, 12
 4119 2716 FF75F4   		push	DWORD PTR [ebp-12]
 4120 2719 E8FCFFFF 		call	print
 4120      FF
 4121 271e 83C410   		add	esp, 16
 914:host.c        **** 
 915:host.c        ****         printAt("FS: ",0,rownum++);
 4122              		.loc 1 915 0
 4123 2721 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 4124 2724 8D5001   		lea	edx, [eax+1]
 4125 2727 8955F0   		mov	DWORD PTR [ebp-16], edx
 4126 272a 83EC04   		sub	esp, 4
 4127 272d 50       		push	eax
 4128 272e 6A00     		push	0
 4129 2730 681D0500 		push	OFFSET FLAT:.LC74
 4129      00
 4130 2735 E8FCFFFF 		call	printAt
 4130      FF
 4131 273a 83C410   		add	esp, 16
 916:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->fs.base, pErr, 16);
 4132              		.loc 1 916 0
 4133 273d A1040000 		mov	eax, DWORD PTR guest+4
 4133      00
 4134 2742 8B904C04 		mov	edx, DWORD PTR [eax+1100]
 4134      0000
 4135 2748 8B804804 		mov	eax, DWORD PTR [eax+1096]
 4135      0000
 4136 274e 83EC04   		sub	esp, 4
 4137 2751 6A10     		push	16
 4138 2753 FF75F4   		push	DWORD PTR [ebp-12]
 4139 2756 50       		push	eax
 4140 2757 E8FCFFFF 		call	Itoa
 4140      FF
 4141 275c 83C410   		add	esp, 16
 4142 275f 8945F4   		mov	DWORD PTR [ebp-12], eax
 917:host.c        ****     print(pErr);
 4143              		.loc 1 917 0
 4144 2762 83EC0C   		sub	esp, 12
 4145 2765 FF75F4   		push	DWORD PTR [ebp-12]
 4146 2768 E8FCFFFF 		call	print
 4146      FF
 4147 276d 83C410   		add	esp, 16
 918:host.c        ****     print(":");
 4148              		.loc 1 918 0
 4149 2770 83EC0C   		sub	esp, 12
 4150 2773 681A0000 		push	OFFSET FLAT:.LC1
 4150      00
 4151 2778 E8FCFFFF 		call	print
 4151      FF
 4152 277d 83C410   		add	esp, 16
 919:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->fs.limit, pErr, 16);
 4153              		.loc 1 919 0
 4154 2780 A1040000 		mov	eax, DWORD PTR guest+4
 4154      00
 4155 2785 8B804404 		mov	eax, DWORD PTR [eax+1092]
 4155      0000
 4156 278b 83EC04   		sub	esp, 4
 4157 278e 6A10     		push	16
 4158 2790 FF75F4   		push	DWORD PTR [ebp-12]
 4159 2793 50       		push	eax
 4160 2794 E8FCFFFF 		call	Itoa
 4160      FF
 4161 2799 83C410   		add	esp, 16
 4162 279c 8945F4   		mov	DWORD PTR [ebp-12], eax
 920:host.c        ****     print(pErr);
 4163              		.loc 1 920 0
 4164 279f 83EC0C   		sub	esp, 12
 4165 27a2 FF75F4   		push	DWORD PTR [ebp-12]
 4166 27a5 E8FCFFFF 		call	print
 4166      FF
 4167 27aa 83C410   		add	esp, 16
 921:host.c        ****     print(":");
 4168              		.loc 1 921 0
 4169 27ad 83EC0C   		sub	esp, 12
 4170 27b0 681A0000 		push	OFFSET FLAT:.LC1
 4170      00
 4171 27b5 E8FCFFFF 		call	print
 4171      FF
 4172 27ba 83C410   		add	esp, 16
 922:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->fs.sel, pErr, 16);
 4173              		.loc 1 922 0
 4174 27bd A1040000 		mov	eax, DWORD PTR guest+4
 4174      00
 4175 27c2 0FB78040 		movzx	eax, WORD PTR [eax+1088]
 4175      040000
 4176 27c9 0FB7C0   		movzx	eax, ax
 4177 27cc 83EC04   		sub	esp, 4
 4178 27cf 6A10     		push	16
 4179 27d1 FF75F4   		push	DWORD PTR [ebp-12]
 4180 27d4 50       		push	eax
 4181 27d5 E8FCFFFF 		call	Itoa
 4181      FF
 4182 27da 83C410   		add	esp, 16
 4183 27dd 8945F4   		mov	DWORD PTR [ebp-12], eax
 923:host.c        ****     print(pErr);
 4184              		.loc 1 923 0
 4185 27e0 83EC0C   		sub	esp, 12
 4186 27e3 FF75F4   		push	DWORD PTR [ebp-12]
 4187 27e6 E8FCFFFF 		call	print
 4187      FF
 4188 27eb 83C410   		add	esp, 16
 924:host.c        **** 
 925:host.c        ****     print("   GS: ");
 4189              		.loc 1 925 0
 4190 27ee 83EC0C   		sub	esp, 12
 4191 27f1 68220500 		push	OFFSET FLAT:.LC75
 4191      00
 4192 27f6 E8FCFFFF 		call	print
 4192      FF
 4193 27fb 83C410   		add	esp, 16
 926:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->gs.base, pErr, 16);
 4194              		.loc 1 926 0
 4195 27fe A1040000 		mov	eax, DWORD PTR guest+4
 4195      00
 4196 2803 8B905C04 		mov	edx, DWORD PTR [eax+1116]
 4196      0000
 4197 2809 8B805804 		mov	eax, DWORD PTR [eax+1112]
 4197      0000
 4198 280f 83EC04   		sub	esp, 4
 4199 2812 6A10     		push	16
 4200 2814 FF75F4   		push	DWORD PTR [ebp-12]
 4201 2817 50       		push	eax
 4202 2818 E8FCFFFF 		call	Itoa
 4202      FF
 4203 281d 83C410   		add	esp, 16
 4204 2820 8945F4   		mov	DWORD PTR [ebp-12], eax
 927:host.c        ****     print(pErr);
 4205              		.loc 1 927 0
 4206 2823 83EC0C   		sub	esp, 12
 4207 2826 FF75F4   		push	DWORD PTR [ebp-12]
 4208 2829 E8FCFFFF 		call	print
 4208      FF
 4209 282e 83C410   		add	esp, 16
 928:host.c        ****     print(":");
 4210              		.loc 1 928 0
 4211 2831 83EC0C   		sub	esp, 12
 4212 2834 681A0000 		push	OFFSET FLAT:.LC1
 4212      00
 4213 2839 E8FCFFFF 		call	print
 4213      FF
 4214 283e 83C410   		add	esp, 16
 929:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->gs.limit, pErr, 16);
 4215              		.loc 1 929 0
 4216 2841 A1040000 		mov	eax, DWORD PTR guest+4
 4216      00
 4217 2846 8B805404 		mov	eax, DWORD PTR [eax+1108]
 4217      0000
 4218 284c 83EC04   		sub	esp, 4
 4219 284f 6A10     		push	16
 4220 2851 FF75F4   		push	DWORD PTR [ebp-12]
 4221 2854 50       		push	eax
 4222 2855 E8FCFFFF 		call	Itoa
 4222      FF
 4223 285a 83C410   		add	esp, 16
 4224 285d 8945F4   		mov	DWORD PTR [ebp-12], eax
 930:host.c        ****     print(pErr);
 4225              		.loc 1 930 0
 4226 2860 83EC0C   		sub	esp, 12
 4227 2863 FF75F4   		push	DWORD PTR [ebp-12]
 4228 2866 E8FCFFFF 		call	print
 4228      FF
 4229 286b 83C410   		add	esp, 16
 931:host.c        ****     print(":");
 4230              		.loc 1 931 0
 4231 286e 83EC0C   		sub	esp, 12
 4232 2871 681A0000 		push	OFFSET FLAT:.LC1
 4232      00
 4233 2876 E8FCFFFF 		call	print
 4233      FF
 4234 287b 83C410   		add	esp, 16
 932:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->gs.sel, pErr, 16);
 4235              		.loc 1 932 0
 4236 287e A1040000 		mov	eax, DWORD PTR guest+4
 4236      00
 4237 2883 0FB78050 		movzx	eax, WORD PTR [eax+1104]
 4237      040000
 4238 288a 0FB7C0   		movzx	eax, ax
 4239 288d 83EC04   		sub	esp, 4
 4240 2890 6A10     		push	16
 4241 2892 FF75F4   		push	DWORD PTR [ebp-12]
 4242 2895 50       		push	eax
 4243 2896 E8FCFFFF 		call	Itoa
 4243      FF
 4244 289b 83C410   		add	esp, 16
 4245 289e 8945F4   		mov	DWORD PTR [ebp-12], eax
 933:host.c        ****     print(pErr);
 4246              		.loc 1 933 0
 4247 28a1 83EC0C   		sub	esp, 12
 4248 28a4 FF75F4   		push	DWORD PTR [ebp-12]
 4249 28a7 E8FCFFFF 		call	print
 4249      FF
 4250 28ac 83C410   		add	esp, 16
 934:host.c        **** 
 935:host.c        ****     print("   SS: ");
 4251              		.loc 1 935 0
 4252 28af 83EC0C   		sub	esp, 12
 4253 28b2 682A0500 		push	OFFSET FLAT:.LC76
 4253      00
 4254 28b7 E8FCFFFF 		call	print
 4254      FF
 4255 28bc 83C410   		add	esp, 16
 936:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->ss.base, pErr, 16);
 4256              		.loc 1 936 0
 4257 28bf A1040000 		mov	eax, DWORD PTR guest+4
 4257      00
 4258 28c4 8B902C04 		mov	edx, DWORD PTR [eax+1068]
 4258      0000
 4259 28ca 8B802804 		mov	eax, DWORD PTR [eax+1064]
 4259      0000
 4260 28d0 83EC04   		sub	esp, 4
 4261 28d3 6A10     		push	16
 4262 28d5 FF75F4   		push	DWORD PTR [ebp-12]
 4263 28d8 50       		push	eax
 4264 28d9 E8FCFFFF 		call	Itoa
 4264      FF
 4265 28de 83C410   		add	esp, 16
 4266 28e1 8945F4   		mov	DWORD PTR [ebp-12], eax
 937:host.c        ****     print(pErr);
 4267              		.loc 1 937 0
 4268 28e4 83EC0C   		sub	esp, 12
 4269 28e7 FF75F4   		push	DWORD PTR [ebp-12]
 4270 28ea E8FCFFFF 		call	print
 4270      FF
 4271 28ef 83C410   		add	esp, 16
 938:host.c        ****     print(":");
 4272              		.loc 1 938 0
 4273 28f2 83EC0C   		sub	esp, 12
 4274 28f5 681A0000 		push	OFFSET FLAT:.LC1
 4274      00
 4275 28fa E8FCFFFF 		call	print
 4275      FF
 4276 28ff 83C410   		add	esp, 16
 939:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->ss.limit, pErr, 16);
 4277              		.loc 1 939 0
 4278 2902 A1040000 		mov	eax, DWORD PTR guest+4
 4278      00
 4279 2907 8B802404 		mov	eax, DWORD PTR [eax+1060]
 4279      0000
 4280 290d 83EC04   		sub	esp, 4
 4281 2910 6A10     		push	16
 4282 2912 FF75F4   		push	DWORD PTR [ebp-12]
 4283 2915 50       		push	eax
 4284 2916 E8FCFFFF 		call	Itoa
 4284      FF
 4285 291b 83C410   		add	esp, 16
 4286 291e 8945F4   		mov	DWORD PTR [ebp-12], eax
 940:host.c        ****     print(pErr);
 4287              		.loc 1 940 0
 4288 2921 83EC0C   		sub	esp, 12
 4289 2924 FF75F4   		push	DWORD PTR [ebp-12]
 4290 2927 E8FCFFFF 		call	print
 4290      FF
 4291 292c 83C410   		add	esp, 16
 941:host.c        ****     print(":");
 4292              		.loc 1 941 0
 4293 292f 83EC0C   		sub	esp, 12
 4294 2932 681A0000 		push	OFFSET FLAT:.LC1
 4294      00
 4295 2937 E8FCFFFF 		call	print
 4295      FF
 4296 293c 83C410   		add	esp, 16
 942:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->ss.sel, pErr, 16);
 4297              		.loc 1 942 0
 4298 293f A1040000 		mov	eax, DWORD PTR guest+4
 4298      00
 4299 2944 0FB78020 		movzx	eax, WORD PTR [eax+1056]
 4299      040000
 4300 294b 0FB7C0   		movzx	eax, ax
 4301 294e 83EC04   		sub	esp, 4
 4302 2951 6A10     		push	16
 4303 2953 FF75F4   		push	DWORD PTR [ebp-12]
 4304 2956 50       		push	eax
 4305 2957 E8FCFFFF 		call	Itoa
 4305      FF
 4306 295c 83C410   		add	esp, 16
 4307 295f 8945F4   		mov	DWORD PTR [ebp-12], eax
 943:host.c        ****     print(pErr);
 4308              		.loc 1 943 0
 4309 2962 83EC0C   		sub	esp, 12
 4310 2965 FF75F4   		push	DWORD PTR [ebp-12]
 4311 2968 E8FCFFFF 		call	print
 4311      FF
 4312 296d 83C410   		add	esp, 16
 944:host.c        **** 
 945:host.c        ****     printAt("   GDTR: ",0,rownum++);
 4313              		.loc 1 945 0
 4314 2970 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 4315 2973 8D5001   		lea	edx, [eax+1]
 4316 2976 8955F0   		mov	DWORD PTR [ebp-16], edx
 4317 2979 83EC04   		sub	esp, 4
 4318 297c 50       		push	eax
 4319 297d 6A00     		push	0
 4320 297f 68320500 		push	OFFSET FLAT:.LC77
 4320      00
 4321 2984 E8FCFFFF 		call	printAt
 4321      FF
 4322 2989 83C410   		add	esp, 16
 946:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->gdtr.base, pErr, 16);
 4323              		.loc 1 946 0
 4324 298c A1040000 		mov	eax, DWORD PTR guest+4
 4324      00
 4325 2991 8B906C04 		mov	edx, DWORD PTR [eax+1132]
 4325      0000
 4326 2997 8B806804 		mov	eax, DWORD PTR [eax+1128]
 4326      0000
 4327 299d 83EC04   		sub	esp, 4
 4328 29a0 6A10     		push	16
 4329 29a2 FF75F4   		push	DWORD PTR [ebp-12]
 4330 29a5 50       		push	eax
 4331 29a6 E8FCFFFF 		call	Itoa
 4331      FF
 4332 29ab 83C410   		add	esp, 16
 4333 29ae 8945F4   		mov	DWORD PTR [ebp-12], eax
 947:host.c        ****     print(pErr);
 4334              		.loc 1 947 0
 4335 29b1 83EC0C   		sub	esp, 12
 4336 29b4 FF75F4   		push	DWORD PTR [ebp-12]
 4337 29b7 E8FCFFFF 		call	print
 4337      FF
 4338 29bc 83C410   		add	esp, 16
 948:host.c        ****     print(":");
 4339              		.loc 1 948 0
 4340 29bf 83EC0C   		sub	esp, 12
 4341 29c2 681A0000 		push	OFFSET FLAT:.LC1
 4341      00
 4342 29c7 E8FCFFFF 		call	print
 4342      FF
 4343 29cc 83C410   		add	esp, 16
 949:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->gdtr.limit, pErr, 16);
 4344              		.loc 1 949 0
 4345 29cf A1040000 		mov	eax, DWORD PTR guest+4
 4345      00
 4346 29d4 8B806404 		mov	eax, DWORD PTR [eax+1124]
 4346      0000
 4347 29da 83EC04   		sub	esp, 4
 4348 29dd 6A10     		push	16
 4349 29df FF75F4   		push	DWORD PTR [ebp-12]
 4350 29e2 50       		push	eax
 4351 29e3 E8FCFFFF 		call	Itoa
 4351      FF
 4352 29e8 83C410   		add	esp, 16
 4353 29eb 8945F4   		mov	DWORD PTR [ebp-12], eax
 950:host.c        ****     print(pErr);
 4354              		.loc 1 950 0
 4355 29ee 83EC0C   		sub	esp, 12
 4356 29f1 FF75F4   		push	DWORD PTR [ebp-12]
 4357 29f4 E8FCFFFF 		call	print
 4357      FF
 4358 29f9 83C410   		add	esp, 16
 951:host.c        ****     print(":");
 4359              		.loc 1 951 0
 4360 29fc 83EC0C   		sub	esp, 12
 4361 29ff 681A0000 		push	OFFSET FLAT:.LC1
 4361      00
 4362 2a04 E8FCFFFF 		call	print
 4362      FF
 4363 2a09 83C410   		add	esp, 16
 952:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->gdtr.sel, pErr, 16);
 4364              		.loc 1 952 0
 4365 2a0c A1040000 		mov	eax, DWORD PTR guest+4
 4365      00
 4366 2a11 0FB78060 		movzx	eax, WORD PTR [eax+1120]
 4366      040000
 4367 2a18 0FB7C0   		movzx	eax, ax
 4368 2a1b 83EC04   		sub	esp, 4
 4369 2a1e 6A10     		push	16
 4370 2a20 FF75F4   		push	DWORD PTR [ebp-12]
 4371 2a23 50       		push	eax
 4372 2a24 E8FCFFFF 		call	Itoa
 4372      FF
 4373 2a29 83C410   		add	esp, 16
 4374 2a2c 8945F4   		mov	DWORD PTR [ebp-12], eax
 953:host.c        ****     print(pErr);
 4375              		.loc 1 953 0
 4376 2a2f 83EC0C   		sub	esp, 12
 4377 2a32 FF75F4   		push	DWORD PTR [ebp-12]
 4378 2a35 E8FCFFFF 		call	print
 4378      FF
 4379 2a3a 83C410   		add	esp, 16
 954:host.c        **** 
 955:host.c        ****     print("   LDTR: ");
 4380              		.loc 1 955 0
 4381 2a3d 83EC0C   		sub	esp, 12
 4382 2a40 683C0500 		push	OFFSET FLAT:.LC78
 4382      00
 4383 2a45 E8FCFFFF 		call	print
 4383      FF
 4384 2a4a 83C410   		add	esp, 16
 956:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->ldtr.base, pErr, 16);
 4385              		.loc 1 956 0
 4386 2a4d A1040000 		mov	eax, DWORD PTR guest+4
 4386      00
 4387 2a52 8B907C04 		mov	edx, DWORD PTR [eax+1148]
 4387      0000
 4388 2a58 8B807804 		mov	eax, DWORD PTR [eax+1144]
 4388      0000
 4389 2a5e 83EC04   		sub	esp, 4
 4390 2a61 6A10     		push	16
 4391 2a63 FF75F4   		push	DWORD PTR [ebp-12]
 4392 2a66 50       		push	eax
 4393 2a67 E8FCFFFF 		call	Itoa
 4393      FF
 4394 2a6c 83C410   		add	esp, 16
 4395 2a6f 8945F4   		mov	DWORD PTR [ebp-12], eax
 957:host.c        ****     print(pErr);
 4396              		.loc 1 957 0
 4397 2a72 83EC0C   		sub	esp, 12
 4398 2a75 FF75F4   		push	DWORD PTR [ebp-12]
 4399 2a78 E8FCFFFF 		call	print
 4399      FF
 4400 2a7d 83C410   		add	esp, 16
 958:host.c        ****     print(":");
 4401              		.loc 1 958 0
 4402 2a80 83EC0C   		sub	esp, 12
 4403 2a83 681A0000 		push	OFFSET FLAT:.LC1
 4403      00
 4404 2a88 E8FCFFFF 		call	print
 4404      FF
 4405 2a8d 83C410   		add	esp, 16
 959:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->ldtr.limit, pErr, 16);
 4406              		.loc 1 959 0
 4407 2a90 A1040000 		mov	eax, DWORD PTR guest+4
 4407      00
 4408 2a95 8B807404 		mov	eax, DWORD PTR [eax+1140]
 4408      0000
 4409 2a9b 83EC04   		sub	esp, 4
 4410 2a9e 6A10     		push	16
 4411 2aa0 FF75F4   		push	DWORD PTR [ebp-12]
 4412 2aa3 50       		push	eax
 4413 2aa4 E8FCFFFF 		call	Itoa
 4413      FF
 4414 2aa9 83C410   		add	esp, 16
 4415 2aac 8945F4   		mov	DWORD PTR [ebp-12], eax
 960:host.c        ****     print(pErr);
 4416              		.loc 1 960 0
 4417 2aaf 83EC0C   		sub	esp, 12
 4418 2ab2 FF75F4   		push	DWORD PTR [ebp-12]
 4419 2ab5 E8FCFFFF 		call	print
 4419      FF
 4420 2aba 83C410   		add	esp, 16
 961:host.c        ****     print(":");
 4421              		.loc 1 961 0
 4422 2abd 83EC0C   		sub	esp, 12
 4423 2ac0 681A0000 		push	OFFSET FLAT:.LC1
 4423      00
 4424 2ac5 E8FCFFFF 		call	print
 4424      FF
 4425 2aca 83C410   		add	esp, 16
 962:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->ldtr.sel, pErr, 16);
 4426              		.loc 1 962 0
 4427 2acd A1040000 		mov	eax, DWORD PTR guest+4
 4427      00
 4428 2ad2 0FB78070 		movzx	eax, WORD PTR [eax+1136]
 4428      040000
 4429 2ad9 0FB7C0   		movzx	eax, ax
 4430 2adc 83EC04   		sub	esp, 4
 4431 2adf 6A10     		push	16
 4432 2ae1 FF75F4   		push	DWORD PTR [ebp-12]
 4433 2ae4 50       		push	eax
 4434 2ae5 E8FCFFFF 		call	Itoa
 4434      FF
 4435 2aea 83C410   		add	esp, 16
 4436 2aed 8945F4   		mov	DWORD PTR [ebp-12], eax
 963:host.c        ****     print(pErr);
 4437              		.loc 1 963 0
 4438 2af0 83EC0C   		sub	esp, 12
 4439 2af3 FF75F4   		push	DWORD PTR [ebp-12]
 4440 2af6 E8FCFFFF 		call	print
 4440      FF
 4441 2afb 83C410   		add	esp, 16
 964:host.c        **** 
 965:host.c        ****     print("   IDTR: ");
 4442              		.loc 1 965 0
 4443 2afe 83EC0C   		sub	esp, 12
 4444 2b01 68460500 		push	OFFSET FLAT:.LC79
 4444      00
 4445 2b06 E8FCFFFF 		call	print
 4445      FF
 4446 2b0b 83C410   		add	esp, 16
 966:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->idtr.base, pErr, 16);
 4447              		.loc 1 966 0
 4448 2b0e A1040000 		mov	eax, DWORD PTR guest+4
 4448      00
 4449 2b13 8B908C04 		mov	edx, DWORD PTR [eax+1164]
 4449      0000
 4450 2b19 8B808804 		mov	eax, DWORD PTR [eax+1160]
 4450      0000
 4451 2b1f 83EC04   		sub	esp, 4
 4452 2b22 6A10     		push	16
 4453 2b24 FF75F4   		push	DWORD PTR [ebp-12]
 4454 2b27 50       		push	eax
 4455 2b28 E8FCFFFF 		call	Itoa
 4455      FF
 4456 2b2d 83C410   		add	esp, 16
 4457 2b30 8945F4   		mov	DWORD PTR [ebp-12], eax
 967:host.c        ****     print(pErr);
 4458              		.loc 1 967 0
 4459 2b33 83EC0C   		sub	esp, 12
 4460 2b36 FF75F4   		push	DWORD PTR [ebp-12]
 4461 2b39 E8FCFFFF 		call	print
 4461      FF
 4462 2b3e 83C410   		add	esp, 16
 968:host.c        ****     print(":");
 4463              		.loc 1 968 0
 4464 2b41 83EC0C   		sub	esp, 12
 4465 2b44 681A0000 		push	OFFSET FLAT:.LC1
 4465      00
 4466 2b49 E8FCFFFF 		call	print
 4466      FF
 4467 2b4e 83C410   		add	esp, 16
 969:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->idtr.limit, pErr, 16);
 4468              		.loc 1 969 0
 4469 2b51 A1040000 		mov	eax, DWORD PTR guest+4
 4469      00
 4470 2b56 8B808404 		mov	eax, DWORD PTR [eax+1156]
 4470      0000
 4471 2b5c 83EC04   		sub	esp, 4
 4472 2b5f 6A10     		push	16
 4473 2b61 FF75F4   		push	DWORD PTR [ebp-12]
 4474 2b64 50       		push	eax
 4475 2b65 E8FCFFFF 		call	Itoa
 4475      FF
 4476 2b6a 83C410   		add	esp, 16
 4477 2b6d 8945F4   		mov	DWORD PTR [ebp-12], eax
 970:host.c        ****     print(pErr);
 4478              		.loc 1 970 0
 4479 2b70 83EC0C   		sub	esp, 12
 4480 2b73 FF75F4   		push	DWORD PTR [ebp-12]
 4481 2b76 E8FCFFFF 		call	print
 4481      FF
 4482 2b7b 83C410   		add	esp, 16
 971:host.c        ****     print(":");
 4483              		.loc 1 971 0
 4484 2b7e 83EC0C   		sub	esp, 12
 4485 2b81 681A0000 		push	OFFSET FLAT:.LC1
 4485      00
 4486 2b86 E8FCFFFF 		call	print
 4486      FF
 4487 2b8b 83C410   		add	esp, 16
 972:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->idtr.sel, pErr, 16);
 4488              		.loc 1 972 0
 4489 2b8e A1040000 		mov	eax, DWORD PTR guest+4
 4489      00
 4490 2b93 0FB78080 		movzx	eax, WORD PTR [eax+1152]
 4490      040000
 4491 2b9a 0FB7C0   		movzx	eax, ax
 4492 2b9d 83EC04   		sub	esp, 4
 4493 2ba0 6A10     		push	16
 4494 2ba2 FF75F4   		push	DWORD PTR [ebp-12]
 4495 2ba5 50       		push	eax
 4496 2ba6 E8FCFFFF 		call	Itoa
 4496      FF
 4497 2bab 83C410   		add	esp, 16
 4498 2bae 8945F4   		mov	DWORD PTR [ebp-12], eax
 973:host.c        ****     print(pErr);
 4499              		.loc 1 973 0
 4500 2bb1 83EC0C   		sub	esp, 12
 4501 2bb4 FF75F4   		push	DWORD PTR [ebp-12]
 4502 2bb7 E8FCFFFF 		call	print
 4502      FF
 4503 2bbc 83C410   		add	esp, 16
 974:host.c        **** 
 975:host.c        ****     printAt("CPL: ",0,rownum++);
 4504              		.loc 1 975 0
 4505 2bbf 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 4506 2bc2 8D5001   		lea	edx, [eax+1]
 4507 2bc5 8955F0   		mov	DWORD PTR [ebp-16], edx
 4508 2bc8 83EC04   		sub	esp, 4
 4509 2bcb 50       		push	eax
 4510 2bcc 6A00     		push	0
 4511 2bce 68500500 		push	OFFSET FLAT:.LC80
 4511      00
 4512 2bd3 E8FCFFFF 		call	printAt
 4512      FF
 4513 2bd8 83C410   		add	esp, 16
 976:host.c        ****     pErr = Itoa((BYTE)guest.vmcb->cpl, pErr, 16);
 4514              		.loc 1 976 0
 4515 2bdb A1040000 		mov	eax, DWORD PTR guest+4
 4515      00
 4516 2be0 0FB680CB 		movzx	eax, BYTE PTR [eax+1227]
 4516      040000
 4517 2be7 0FB6C0   		movzx	eax, al
 4518 2bea 83EC04   		sub	esp, 4
 4519 2bed 6A10     		push	16
 4520 2bef FF75F4   		push	DWORD PTR [ebp-12]
 4521 2bf2 50       		push	eax
 4522 2bf3 E8FCFFFF 		call	Itoa
 4522      FF
 4523 2bf8 83C410   		add	esp, 16
 4524 2bfb 8945F4   		mov	DWORD PTR [ebp-12], eax
 977:host.c        ****       print(pErr);
 4525              		.loc 1 977 0
 4526 2bfe 83EC0C   		sub	esp, 12
 4527 2c01 FF75F4   		push	DWORD PTR [ebp-12]
 4528 2c04 E8FCFFFF 		call	print
 4528      FF
 4529 2c09 83C410   		add	esp, 16
 978:host.c        ****     
 979:host.c        ****      print(" - EFER: ");
 4530              		.loc 1 979 0
 4531 2c0c 83EC0C   		sub	esp, 12
 4532 2c0f 68560500 		push	OFFSET FLAT:.LC81
 4532      00
 4533 2c14 E8FCFFFF 		call	print
 4533      FF
 4534 2c19 83C410   		add	esp, 16
 980:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->efer, pErr, 16);
 4535              		.loc 1 980 0
 4536 2c1c A1040000 		mov	eax, DWORD PTR guest+4
 4536      00
 4537 2c21 8B90D404 		mov	edx, DWORD PTR [eax+1236]
 4537      0000
 4538 2c27 8B80D004 		mov	eax, DWORD PTR [eax+1232]
 4538      0000
 4539 2c2d 83EC04   		sub	esp, 4
 4540 2c30 6A10     		push	16
 4541 2c32 FF75F4   		push	DWORD PTR [ebp-12]
 4542 2c35 50       		push	eax
 4543 2c36 E8FCFFFF 		call	Itoa
 4543      FF
 4544 2c3b 83C410   		add	esp, 16
 4545 2c3e 8945F4   		mov	DWORD PTR [ebp-12], eax
 981:host.c        ****      print(pErr);
 4546              		.loc 1 981 0
 4547 2c41 83EC0C   		sub	esp, 12
 4548 2c44 FF75F4   		push	DWORD PTR [ebp-12]
 4549 2c47 E8FCFFFF 		call	print
 4549      FF
 4550 2c4c 83C410   		add	esp, 16
 982:host.c        ****     
 983:host.c        ****      print(" - CR4: ");
 4551              		.loc 1 983 0
 4552 2c4f 83EC0C   		sub	esp, 12
 4553 2c52 68600500 		push	OFFSET FLAT:.LC82
 4553      00
 4554 2c57 E8FCFFFF 		call	print
 4554      FF
 4555 2c5c 83C410   		add	esp, 16
 984:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->cr4, pErr, 16);
 4556              		.loc 1 984 0
 4557 2c5f A1040000 		mov	eax, DWORD PTR guest+4
 4557      00
 4558 2c64 8B904C05 		mov	edx, DWORD PTR [eax+1356]
 4558      0000
 4559 2c6a 8B804805 		mov	eax, DWORD PTR [eax+1352]
 4559      0000
 4560 2c70 83EC04   		sub	esp, 4
 4561 2c73 6A10     		push	16
 4562 2c75 FF75F4   		push	DWORD PTR [ebp-12]
 4563 2c78 50       		push	eax
 4564 2c79 E8FCFFFF 		call	Itoa
 4564      FF
 4565 2c7e 83C410   		add	esp, 16
 4566 2c81 8945F4   		mov	DWORD PTR [ebp-12], eax
 985:host.c        ****      print(pErr);
 4567              		.loc 1 985 0
 4568 2c84 83EC0C   		sub	esp, 12
 4569 2c87 FF75F4   		push	DWORD PTR [ebp-12]
 4570 2c8a E8FCFFFF 		call	print
 4570      FF
 4571 2c8f 83C410   		add	esp, 16
 986:host.c        ****     
 987:host.c        ****      print(" - CR3: ");
 4572              		.loc 1 987 0
 4573 2c92 83EC0C   		sub	esp, 12
 4574 2c95 68690500 		push	OFFSET FLAT:.LC83
 4574      00
 4575 2c9a E8FCFFFF 		call	print
 4575      FF
 4576 2c9f 83C410   		add	esp, 16
 988:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->cr3, pErr, 16);
 4577              		.loc 1 988 0
 4578 2ca2 A1040000 		mov	eax, DWORD PTR guest+4
 4578      00
 4579 2ca7 8B905405 		mov	edx, DWORD PTR [eax+1364]
 4579      0000
 4580 2cad 8B805005 		mov	eax, DWORD PTR [eax+1360]
 4580      0000
 4581 2cb3 83EC04   		sub	esp, 4
 4582 2cb6 6A10     		push	16
 4583 2cb8 FF75F4   		push	DWORD PTR [ebp-12]
 4584 2cbb 50       		push	eax
 4585 2cbc E8FCFFFF 		call	Itoa
 4585      FF
 4586 2cc1 83C410   		add	esp, 16
 4587 2cc4 8945F4   		mov	DWORD PTR [ebp-12], eax
 989:host.c        ****      print(pErr);
 4588              		.loc 1 989 0
 4589 2cc7 83EC0C   		sub	esp, 12
 4590 2cca FF75F4   		push	DWORD PTR [ebp-12]
 4591 2ccd E8FCFFFF 		call	print
 4591      FF
 4592 2cd2 83C410   		add	esp, 16
 990:host.c        ****     
 991:host.c        ****      print(" - CR0: ");
 4593              		.loc 1 991 0
 4594 2cd5 83EC0C   		sub	esp, 12
 4595 2cd8 68720500 		push	OFFSET FLAT:.LC84
 4595      00
 4596 2cdd E8FCFFFF 		call	print
 4596      FF
 4597 2ce2 83C410   		add	esp, 16
 992:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->cr0, pErr, 16);
 4598              		.loc 1 992 0
 4599 2ce5 A1040000 		mov	eax, DWORD PTR guest+4
 4599      00
 4600 2cea 8B905C05 		mov	edx, DWORD PTR [eax+1372]
 4600      0000
 4601 2cf0 8B805805 		mov	eax, DWORD PTR [eax+1368]
 4601      0000
 4602 2cf6 83EC04   		sub	esp, 4
 4603 2cf9 6A10     		push	16
 4604 2cfb FF75F4   		push	DWORD PTR [ebp-12]
 4605 2cfe 50       		push	eax
 4606 2cff E8FCFFFF 		call	Itoa
 4606      FF
 4607 2d04 83C410   		add	esp, 16
 4608 2d07 8945F4   		mov	DWORD PTR [ebp-12], eax
 993:host.c        ****      print(pErr);
 4609              		.loc 1 993 0
 4610 2d0a 83EC0C   		sub	esp, 12
 4611 2d0d FF75F4   		push	DWORD PTR [ebp-12]
 4612 2d10 E8FCFFFF 		call	print
 4612      FF
 4613 2d15 83C410   		add	esp, 16
 994:host.c        ****     
 995:host.c        ****      print(" - RFLAGS: ");
 4614              		.loc 1 995 0
 4615 2d18 83EC0C   		sub	esp, 12
 4616 2d1b 687B0500 		push	OFFSET FLAT:.LC85
 4616      00
 4617 2d20 E8FCFFFF 		call	print
 4617      FF
 4618 2d25 83C410   		add	esp, 16
 996:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->rflags, pErr, 16);
 4619              		.loc 1 996 0
 4620 2d28 A1040000 		mov	eax, DWORD PTR guest+4
 4620      00
 4621 2d2d 8B907405 		mov	edx, DWORD PTR [eax+1396]
 4621      0000
 4622 2d33 8B807005 		mov	eax, DWORD PTR [eax+1392]
 4622      0000
 4623 2d39 83EC04   		sub	esp, 4
 4624 2d3c 6A10     		push	16
 4625 2d3e FF75F4   		push	DWORD PTR [ebp-12]
 4626 2d41 50       		push	eax
 4627 2d42 E8FCFFFF 		call	Itoa
 4627      FF
 4628 2d47 83C410   		add	esp, 16
 4629 2d4a 8945F4   		mov	DWORD PTR [ebp-12], eax
 997:host.c        ****      print(pErr);
 4630              		.loc 1 997 0
 4631 2d4d 83EC0C   		sub	esp, 12
 4632 2d50 FF75F4   		push	DWORD PTR [ebp-12]
 4633 2d53 E8FCFFFF 		call	print
 4633      FF
 4634 2d58 83C410   		add	esp, 16
 998:host.c        ****     
 999:host.c        ****     printAt(" - RIP: ",0,rownum);
 4635              		.loc 1 999 0
 4636 2d5b 83EC04   		sub	esp, 4
 4637 2d5e FF75F0   		push	DWORD PTR [ebp-16]
 4638 2d61 6A00     		push	0
 4639 2d63 68870500 		push	OFFSET FLAT:.LC86
 4639      00
 4640 2d68 E8FCFFFF 		call	printAt
 4640      FF
 4641 2d6d 83C410   		add	esp, 16
1000:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->rip, pErr, 16);
 4642              		.loc 1 1000 0
 4643 2d70 A1040000 		mov	eax, DWORD PTR guest+4
 4643      00
 4644 2d75 8B907C05 		mov	edx, DWORD PTR [eax+1404]
 4644      0000
 4645 2d7b 8B807805 		mov	eax, DWORD PTR [eax+1400]
 4645      0000
 4646 2d81 83EC04   		sub	esp, 4
 4647 2d84 6A10     		push	16
 4648 2d86 FF75F4   		push	DWORD PTR [ebp-12]
 4649 2d89 50       		push	eax
 4650 2d8a E8FCFFFF 		call	Itoa
 4650      FF
 4651 2d8f 83C410   		add	esp, 16
 4652 2d92 8945F4   		mov	DWORD PTR [ebp-12], eax
1001:host.c        ****     print(pErr);
 4653              		.loc 1 1001 0
 4654 2d95 83EC0C   		sub	esp, 12
 4655 2d98 FF75F4   		push	DWORD PTR [ebp-12]
 4656 2d9b E8FCFFFF 		call	print
 4656      FF
 4657 2da0 83C410   		add	esp, 16
1002:host.c        ****     
1003:host.c        ****     print(" - RSP: ");
 4658              		.loc 1 1003 0
 4659 2da3 83EC0C   		sub	esp, 12
 4660 2da6 68900500 		push	OFFSET FLAT:.LC87
 4660      00
 4661 2dab E8FCFFFF 		call	print
 4661      FF
 4662 2db0 83C410   		add	esp, 16
1004:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->rsp, pErr, 16);
 4663              		.loc 1 1004 0
 4664 2db3 A1040000 		mov	eax, DWORD PTR guest+4
 4664      00
 4665 2db8 8B90DC05 		mov	edx, DWORD PTR [eax+1500]
 4665      0000
 4666 2dbe 8B80D805 		mov	eax, DWORD PTR [eax+1496]
 4666      0000
 4667 2dc4 83EC04   		sub	esp, 4
 4668 2dc7 6A10     		push	16
 4669 2dc9 FF75F4   		push	DWORD PTR [ebp-12]
 4670 2dcc 50       		push	eax
 4671 2dcd E8FCFFFF 		call	Itoa
 4671      FF
 4672 2dd2 83C410   		add	esp, 16
 4673 2dd5 8945F4   		mov	DWORD PTR [ebp-12], eax
1005:host.c        ****     print(pErr);
 4674              		.loc 1 1005 0
 4675 2dd8 83EC0C   		sub	esp, 12
 4676 2ddb FF75F4   		push	DWORD PTR [ebp-12]
 4677 2dde E8FCFFFF 		call	print
 4677      FF
 4678 2de3 83C410   		add	esp, 16
1006:host.c        ****     
1007:host.c        ****     print(" - RAX: ");
 4679              		.loc 1 1007 0
 4680 2de6 83EC0C   		sub	esp, 12
 4681 2de9 68990500 		push	OFFSET FLAT:.LC88
 4681      00
 4682 2dee E8FCFFFF 		call	print
 4682      FF
 4683 2df3 83C410   		add	esp, 16
1008:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->rax, pErr, 16);
 4684              		.loc 1 1008 0
 4685 2df6 A1040000 		mov	eax, DWORD PTR guest+4
 4685      00
 4686 2dfb 8B90FC05 		mov	edx, DWORD PTR [eax+1532]
 4686      0000
 4687 2e01 8B80F805 		mov	eax, DWORD PTR [eax+1528]
 4687      0000
 4688 2e07 83EC04   		sub	esp, 4
 4689 2e0a 6A10     		push	16
 4690 2e0c FF75F4   		push	DWORD PTR [ebp-12]
 4691 2e0f 50       		push	eax
 4692 2e10 E8FCFFFF 		call	Itoa
 4692      FF
 4693 2e15 83C410   		add	esp, 16
 4694 2e18 8945F4   		mov	DWORD PTR [ebp-12], eax
1009:host.c        ****     print(pErr);
 4695              		.loc 1 1009 0
 4696 2e1b 83EC0C   		sub	esp, 12
 4697 2e1e FF75F4   		push	DWORD PTR [ebp-12]
 4698 2e21 E8FCFFFF 		call	print
 4698      FF
 4699 2e26 83C410   		add	esp, 16
1010:host.c        ****     
1011:host.c        ****     print(" - CR2: ");
 4700              		.loc 1 1011 0
 4701 2e29 83EC0C   		sub	esp, 12
 4702 2e2c 68A20500 		push	OFFSET FLAT:.LC89
 4702      00
 4703 2e31 E8FCFFFF 		call	print
 4703      FF
 4704 2e36 83C410   		add	esp, 16
1012:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->cr2, pErr, 16);
 4705              		.loc 1 1012 0
 4706 2e39 A1040000 		mov	eax, DWORD PTR guest+4
 4706      00
 4707 2e3e 8B904406 		mov	edx, DWORD PTR [eax+1604]
 4707      0000
 4708 2e44 8B804006 		mov	eax, DWORD PTR [eax+1600]
 4708      0000
 4709 2e4a 83EC04   		sub	esp, 4
 4710 2e4d 6A10     		push	16
 4711 2e4f FF75F4   		push	DWORD PTR [ebp-12]
 4712 2e52 50       		push	eax
 4713 2e53 E8FCFFFF 		call	Itoa
 4713      FF
 4714 2e58 83C410   		add	esp, 16
 4715 2e5b 8945F4   		mov	DWORD PTR [ebp-12], eax
1013:host.c        ****     print(pErr);
 4716              		.loc 1 1013 0
 4717 2e5e 83EC0C   		sub	esp, 12
 4718 2e61 FF75F4   		push	DWORD PTR [ebp-12]
 4719 2e64 E8FCFFFF 		call	print
 4719      FF
 4720 2e69 83C410   		add	esp, 16
1014:host.c        **** 
1015:host.c        ****     printAt("ExitCode: ",0,rownum++);
 4721              		.loc 1 1015 0
 4722 2e6c 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 4723 2e6f 8D5001   		lea	edx, [eax+1]
 4724 2e72 8955F0   		mov	DWORD PTR [ebp-16], edx
 4725 2e75 83EC04   		sub	esp, 4
 4726 2e78 50       		push	eax
 4727 2e79 6A00     		push	0
 4728 2e7b 68AB0500 		push	OFFSET FLAT:.LC90
 4728      00
 4729 2e80 E8FCFFFF 		call	printAt
 4729      FF
 4730 2e85 83C410   		add	esp, 16
1016:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->exitcode, pErr, 16);
 4731              		.loc 1 1016 0
 4732 2e88 A1040000 		mov	eax, DWORD PTR guest+4
 4732      00
 4733 2e8d 8B5074   		mov	edx, DWORD PTR [eax+116]
 4734 2e90 8B4070   		mov	eax, DWORD PTR [eax+112]
 4735 2e93 83EC04   		sub	esp, 4
 4736 2e96 6A10     		push	16
 4737 2e98 FF75F4   		push	DWORD PTR [ebp-12]
 4738 2e9b 50       		push	eax
 4739 2e9c E8FCFFFF 		call	Itoa
 4739      FF
 4740 2ea1 83C410   		add	esp, 16
 4741 2ea4 8945F4   		mov	DWORD PTR [ebp-12], eax
1017:host.c        ****     print(pErr);
 4742              		.loc 1 1017 0
 4743 2ea7 83EC0C   		sub	esp, 12
 4744 2eaa FF75F4   		push	DWORD PTR [ebp-12]
 4745 2ead E8FCFFFF 		call	print
 4745      FF
 4746 2eb2 83C410   		add	esp, 16
1018:host.c        **** 
1019:host.c        ****     print(" - ExitInfo1: ");
 4747              		.loc 1 1019 0
 4748 2eb5 83EC0C   		sub	esp, 12
 4749 2eb8 68B60500 		push	OFFSET FLAT:.LC91
 4749      00
 4750 2ebd E8FCFFFF 		call	print
 4750      FF
 4751 2ec2 83C410   		add	esp, 16
1020:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->exitinfo1, pErr, 16);
 4752              		.loc 1 1020 0
 4753 2ec5 A1040000 		mov	eax, DWORD PTR guest+4
 4753      00
 4754 2eca 8B507C   		mov	edx, DWORD PTR [eax+124]
 4755 2ecd 8B4078   		mov	eax, DWORD PTR [eax+120]
 4756 2ed0 83EC04   		sub	esp, 4
 4757 2ed3 6A10     		push	16
 4758 2ed5 FF75F4   		push	DWORD PTR [ebp-12]
 4759 2ed8 50       		push	eax
 4760 2ed9 E8FCFFFF 		call	Itoa
 4760      FF
 4761 2ede 83C410   		add	esp, 16
 4762 2ee1 8945F4   		mov	DWORD PTR [ebp-12], eax
1021:host.c        ****     print(pErr);
 4763              		.loc 1 1021 0
 4764 2ee4 83EC0C   		sub	esp, 12
 4765 2ee7 FF75F4   		push	DWORD PTR [ebp-12]
 4766 2eea E8FCFFFF 		call	print
 4766      FF
 4767 2eef 83C410   		add	esp, 16
1022:host.c        ****     
1023:host.c        ****     print(" - ExitInfo2: ");
 4768              		.loc 1 1023 0
 4769 2ef2 83EC0C   		sub	esp, 12
 4770 2ef5 68C50500 		push	OFFSET FLAT:.LC92
 4770      00
 4771 2efa E8FCFFFF 		call	print
 4771      FF
 4772 2eff 83C410   		add	esp, 16
1024:host.c        ****     pErr = Itoa((DWORD)guest.vmcb->exitinfo2, pErr, 16);
 4773              		.loc 1 1024 0
 4774 2f02 A1040000 		mov	eax, DWORD PTR guest+4
 4774      00
 4775 2f07 8B908400 		mov	edx, DWORD PTR [eax+132]
 4775      0000
 4776 2f0d 8B808000 		mov	eax, DWORD PTR [eax+128]
 4776      0000
 4777 2f13 83EC04   		sub	esp, 4
 4778 2f16 6A10     		push	16
 4779 2f18 FF75F4   		push	DWORD PTR [ebp-12]
 4780 2f1b 50       		push	eax
 4781 2f1c E8FCFFFF 		call	Itoa
 4781      FF
 4782 2f21 83C410   		add	esp, 16
 4783 2f24 8945F4   		mov	DWORD PTR [ebp-12], eax
1025:host.c        ****     print(pErr);
 4784              		.loc 1 1025 0
 4785 2f27 83EC0C   		sub	esp, 12
 4786 2f2a FF75F4   		push	DWORD PTR [ebp-12]
 4787 2f2d E8FCFFFF 		call	print
 4787      FF
 4788 2f32 83C410   		add	esp, 16
1026:host.c        **** 
1027:host.c        ****     //    print(" - : ");
1028:host.c        **** //    pErr = Itoa((DWORD)guest.vmcb-, pErr, 16);
1029:host.c        **** //    print(pErr);
1030:host.c        ****     
1031:host.c        ****     HostScancode = 0;
 4789              		.loc 1 1031 0
 4790 2f35 C6050000 		mov	BYTE PTR HostScancode, 0
 4790      000000
1032:host.c        ****     while (HostScancode == 0)
 4791              		.loc 1 1032 0
 4792 2f3c 90       		nop
 4793              	.L124:
 4794              		.loc 1 1032 0 is_stmt 0 discriminator 1
 4795 2f3d 0FB60500 		movzx	eax, BYTE PTR HostScancode
 4795      000000
 4796 2f44 84C0     		test	al, al
 4797 2f46 74F5     		je	.L124
1033:host.c        ****     {}
1034:host.c        **** }
 4798              		.loc 1 1034 0 is_stmt 1
 4799 2f48 90       		nop
 4800 2f49 C9       		leave
 4801              		.cfi_restore 5
 4802              		.cfi_def_cfa 4, 4
 4803 2f4a C3       		ret
 4804              		.cfi_endproc
 4805              	.LFE14:
 4807              		.section	.rodata
 4808              	.LC93:
 4809 05d4 50726573 		.string	"Press a key to continue"
 4809      73206120 
 4809      6B657920 
 4809      746F2063 
 4809      6F6E7469 
 4810              	.LC94:
 4811 05ec 2A2A2A20 		.string	"*** E820 Information ***"
 4811      45383230 
 4811      20496E66 
 4811      6F726D61 
 4811      74696F6E 
 4812 0605 00       		.string	""
 4813 0606 0000     		.align 4
 4814              	.LC95:
 4815 0608 53742F53 		.string	"St/Sz/T 0x%08x_%08lx/0x%08lx_%08lx/"
 4815      7A2F5420 
 4815      30782530 
 4815      38785F25 
 4815      30386C78 
 4816              	.LC96:
 4817 062c 72616D00 		.string	"ram"
 4818              	.LC97:
 4819 0630 72657365 		.string	"reserved"
 4819      72766564 
 4819      00
 4820              	.LC98:
 4821 0639 41435049 		.string	"ACPI Reclaimable"
 4821      20526563 
 4821      6C61696D 
 4821      61626C65 
 4821      00
 4822              	.LC99:
 4823 064a 00       		.string	""
 4824              	.LC100:
 4825 064b 25303278 		.string	"%02x"
 4825      00
 4826              	.LC101:
 4827 0650 2A2A2A44 		.string	"***Done***"
 4827      6F6E652A 
 4827      2A2A00
 4828              		.text
 4829              		.globl	PrintE820Data
 4831              	PrintE820Data:
 4832              	.LFB15:
1035:host.c        **** 
1036:host.c        **** void PrintE820Data()
1037:host.c        **** {
 4833              		.loc 1 1037 0
 4834              		.cfi_startproc
 4835 2f4b 55       		push	ebp
 4836              		.cfi_def_cfa_offset 8
 4837              		.cfi_offset 5, -8
 4838 2f4c 89E5     		mov	ebp, esp
 4839              		.cfi_def_cfa_register 5
 4840 2f4e 56       		push	esi
 4841 2f4f 53       		push	ebx
 4842 2f50 83C480   		add	esp, -128
 4843              		.cfi_offset 6, -12
 4844              		.cfi_offset 3, -16
1038:host.c        ****     char *pErr = "                    \0";
 4845              		.loc 1 1038 0
 4846 2f53 C745F4C9 		mov	DWORD PTR [ebp-12], OFFSET FLAT:.LC3
 4846      000000
1039:host.c        ****     int cnt = 0, cnt2 = 0;
 4847              		.loc 1 1039 0
 4848 2f5a C745F000 		mov	DWORD PTR [ebp-16], 0
 4848      000000
 4849 2f61 C745EC00 		mov	DWORD PTR [ebp-20], 0
 4849      000000
1040:host.c        ****     struct e820entry* e820 = (struct e820entry*)(vhost.e820MemMap);
 4850              		.loc 1 1040 0
 4851 2f68 A1400000 		mov	eax, DWORD PTR vhost+64
 4851      00
 4852 2f6d 8945E8   		mov	DWORD PTR [ebp-24], eax
 4853              	.L138:
 4854              	.LBB3:
1041:host.c        ****     char ol[100];
1042:host.c        ****     do
1043:host.c        ****     {
1044:host.c        ****         if (cnt == 0 || cnt % 9==0)
 4855              		.loc 1 1044 0
 4856 2f70 837DF000 		cmp	DWORD PTR [ebp-16], 0
 4857 2f74 7426     		je	.L126
 4858              		.loc 1 1044 0 is_stmt 0 discriminator 1
 4859 2f76 8B4DF0   		mov	ecx, DWORD PTR [ebp-16]
 4860 2f79 BA398EE3 		mov	edx, 954437177
 4860      38
 4861 2f7e 89C8     		mov	eax, ecx
 4862 2f80 F7EA     		imul	edx
 4863 2f82 D1FA     		sar	edx
 4864 2f84 89C8     		mov	eax, ecx
 4865 2f86 C1F81F   		sar	eax, 31
 4866 2f89 29C2     		sub	edx, eax
 4867 2f8b 89D0     		mov	eax, edx
 4868 2f8d 89C2     		mov	edx, eax
 4869 2f8f C1E203   		sal	edx, 3
 4870 2f92 01C2     		add	edx, eax
 4871 2f94 89C8     		mov	eax, ecx
 4872 2f96 29D0     		sub	eax, edx
 4873 2f98 85C0     		test	eax, eax
 4874 2f9a 7542     		jne	.L127
 4875              	.L126:
1045:host.c        ****         {
1046:host.c        ****             if (cnt > 0)
 4876              		.loc 1 1046 0 is_stmt 1
 4877 2f9c 837DF000 		cmp	DWORD PTR [ebp-16], 0
 4878 2fa0 7E27     		jle	.L128
1047:host.c        ****             {
1048:host.c        ****                 printAt("Press a key to continue",10,21);
 4879              		.loc 1 1048 0
 4880 2fa2 83EC04   		sub	esp, 4
 4881 2fa5 6A15     		push	21
 4882 2fa7 6A0A     		push	10
 4883 2fa9 68D40500 		push	OFFSET FLAT:.LC93
 4883      00
 4884 2fae E8FCFFFF 		call	printAt
 4884      FF
 4885 2fb3 83C410   		add	esp, 16
1049:host.c        ****                 HostScancode = 0;
 4886              		.loc 1 1049 0
 4887 2fb6 C6050000 		mov	BYTE PTR HostScancode, 0
 4887      000000
1050:host.c        ****                 while (HostScancode == 0)
 4888              		.loc 1 1050 0
 4889 2fbd 90       		nop
 4890              	.L129:
 4891              		.loc 1 1050 0 is_stmt 0 discriminator 1
 4892 2fbe 0FB60500 		movzx	eax, BYTE PTR HostScancode
 4892      000000
 4893 2fc5 84C0     		test	al, al
 4894 2fc7 74F5     		je	.L129
 4895              	.L128:
1051:host.c        ****                 {}
1052:host.c        ****             }
1053:host.c        ****             clrscr();
 4896              		.loc 1 1053 0 is_stmt 1
 4897 2fc9 E8FCFFFF 		call	clrscr
 4897      FF
1054:host.c        ****             println("*** E820 Information ***\0");
 4898              		.loc 1 1054 0
 4899 2fce 83EC0C   		sub	esp, 12
 4900 2fd1 68EC0500 		push	OFFSET FLAT:.LC94
 4900      00
 4901 2fd6 E8FCFFFF 		call	println
 4901      FF
 4902 2fdb 83C410   		add	esp, 16
 4903              	.L127:
1055:host.c        ****         }
1056:host.c        ****         memset(ol,0,100);
 4904              		.loc 1 1056 0
 4905 2fde 83EC04   		sub	esp, 4
 4906 2fe1 6A64     		push	100
 4907 2fe3 6A00     		push	0
 4908 2fe5 8D4580   		lea	eax, [ebp-128]
 4909 2fe8 50       		push	eax
 4910 2fe9 E8FCFFFF 		call	memset
 4910      FF
 4911 2fee 83C410   		add	esp, 16
1057:host.c        ****         sprintf(ol, "St/Sz/T 0x%08x_%08lx/0x%08lx_%08lx/",  (DWORD)(e820[cnt].addr >> 32), (DWORD)(
1058:host.c        ****                                                           (DWORD)(e820[cnt].size >> 32), (DWORD)(e8
 4912              		.loc 1 1058 0
 4913 2ff1 8B55F0   		mov	edx, DWORD PTR [ebp-16]
 4914 2ff4 89D0     		mov	eax, edx
 4915 2ff6 01C0     		add	eax, eax
 4916 2ff8 01D0     		add	eax, edx
 4917 2ffa C1E003   		sal	eax, 3
 4918 2ffd 89C2     		mov	edx, eax
 4919 2fff 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 4920 3002 01D0     		add	eax, edx
 4921 3004 8B500C   		mov	edx, DWORD PTR [eax+12]
 4922 3007 8B4008   		mov	eax, DWORD PTR [eax+8]
1057:host.c        ****         sprintf(ol, "St/Sz/T 0x%08x_%08lx/0x%08lx_%08lx/",  (DWORD)(e820[cnt].addr >> 32), (DWORD)(
 4923              		.loc 1 1057 0
 4924 300a 89C6     		mov	esi, eax
 4925              		.loc 1 1058 0
 4926 300c 8B55F0   		mov	edx, DWORD PTR [ebp-16]
 4927 300f 89D0     		mov	eax, edx
 4928 3011 01C0     		add	eax, eax
 4929 3013 01D0     		add	eax, edx
 4930 3015 C1E003   		sal	eax, 3
 4931 3018 89C2     		mov	edx, eax
 4932 301a 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 4933 301d 01D0     		add	eax, edx
 4934 301f 8B500C   		mov	edx, DWORD PTR [eax+12]
 4935 3022 8B4008   		mov	eax, DWORD PTR [eax+8]
 4936 3025 89D0     		mov	eax, edx
 4937 3027 31D2     		xor	edx, edx
1057:host.c        ****         sprintf(ol, "St/Sz/T 0x%08x_%08lx/0x%08lx_%08lx/",  (DWORD)(e820[cnt].addr >> 32), (DWORD)(
 4938              		.loc 1 1057 0
 4939 3029 89C3     		mov	ebx, eax
 4940 302b 8B55F0   		mov	edx, DWORD PTR [ebp-16]
 4941 302e 89D0     		mov	eax, edx
 4942 3030 01C0     		add	eax, eax
 4943 3032 01D0     		add	eax, edx
 4944 3034 C1E003   		sal	eax, 3
 4945 3037 89C2     		mov	edx, eax
 4946 3039 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 4947 303c 01D0     		add	eax, edx
 4948 303e 8B5004   		mov	edx, DWORD PTR [eax+4]
 4949 3041 8B00     		mov	eax, DWORD PTR [eax]
 4950 3043 89C1     		mov	ecx, eax
 4951 3045 8B55F0   		mov	edx, DWORD PTR [ebp-16]
 4952 3048 89D0     		mov	eax, edx
 4953 304a 01C0     		add	eax, eax
 4954 304c 01D0     		add	eax, edx
 4955 304e C1E003   		sal	eax, 3
 4956 3051 89C2     		mov	edx, eax
 4957 3053 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 4958 3056 01D0     		add	eax, edx
 4959 3058 8B5004   		mov	edx, DWORD PTR [eax+4]
 4960 305b 8B00     		mov	eax, DWORD PTR [eax]
 4961 305d 89D0     		mov	eax, edx
 4962 305f 31D2     		xor	edx, edx
 4963 3061 83EC08   		sub	esp, 8
 4964 3064 56       		push	esi
 4965 3065 53       		push	ebx
 4966 3066 51       		push	ecx
 4967 3067 50       		push	eax
 4968 3068 68080600 		push	OFFSET FLAT:.LC95
 4968      00
 4969 306d 8D4580   		lea	eax, [ebp-128]
 4970 3070 50       		push	eax
 4971 3071 E8FCFFFF 		call	sprintf
 4971      FF
 4972 3076 83C420   		add	esp, 32
1059:host.c        ****         print(ol);
 4973              		.loc 1 1059 0
 4974 3079 83EC0C   		sub	esp, 12
 4975 307c 8D4580   		lea	eax, [ebp-128]
 4976 307f 50       		push	eax
 4977 3080 E8FCFFFF 		call	print
 4977      FF
 4978 3085 83C410   		add	esp, 16
1060:host.c        ****         switch (e820[cnt].type)
 4979              		.loc 1 1060 0
 4980 3088 8B55F0   		mov	edx, DWORD PTR [ebp-16]
 4981 308b 89D0     		mov	eax, edx
 4982 308d 01C0     		add	eax, eax
 4983 308f 01D0     		add	eax, edx
 4984 3091 C1E003   		sal	eax, 3
 4985 3094 89C2     		mov	edx, eax
 4986 3096 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 4987 3099 01D0     		add	eax, edx
 4988 309b 8B4010   		mov	eax, DWORD PTR [eax+16]
 4989 309e 83F802   		cmp	eax, 2
 4990 30a1 741C     		je	.L131
 4991 30a3 83F803   		cmp	eax, 3
 4992 30a6 7429     		je	.L132
 4993 30a8 83F801   		cmp	eax, 1
 4994 30ab 7536     		jne	.L140
1061:host.c        ****         {
1062:host.c        ****             case 0x1:
1063:host.c        ****                 print("ram");
 4995              		.loc 1 1063 0
 4996 30ad 83EC0C   		sub	esp, 12
 4997 30b0 682C0600 		push	OFFSET FLAT:.LC96
 4997      00
 4998 30b5 E8FCFFFF 		call	print
 4998      FF
 4999 30ba 83C410   		add	esp, 16
1064:host.c        ****             break;
 5000              		.loc 1 1064 0
 5001 30bd EB5D     		jmp	.L134
 5002              	.L131:
1065:host.c        ****             case 0x2:
1066:host.c        ****                 print("reserved");
 5003              		.loc 1 1066 0
 5004 30bf 83EC0C   		sub	esp, 12
 5005 30c2 68300600 		push	OFFSET FLAT:.LC97
 5005      00
 5006 30c7 E8FCFFFF 		call	print
 5006      FF
 5007 30cc 83C410   		add	esp, 16
1067:host.c        ****                 break;
 5008              		.loc 1 1067 0
 5009 30cf EB4B     		jmp	.L134
 5010              	.L132:
1068:host.c        ****             case 0x3:
1069:host.c        ****                 print("ACPI Reclaimable");
 5011              		.loc 1 1069 0
 5012 30d1 83EC0C   		sub	esp, 12
 5013 30d4 68390600 		push	OFFSET FLAT:.LC98
 5013      00
 5014 30d9 E8FCFFFF 		call	print
 5014      FF
 5015 30de 83C410   		add	esp, 16
1070:host.c        ****                 break;
 5016              		.loc 1 1070 0
 5017 30e1 EB39     		jmp	.L134
 5018              	.L140:
1071:host.c        ****             default:
1072:host.c        ****                 pErr = Itoa(e820[cnt].type, pErr, 16);
 5019              		.loc 1 1072 0
 5020 30e3 8B55F0   		mov	edx, DWORD PTR [ebp-16]
 5021 30e6 89D0     		mov	eax, edx
 5022 30e8 01C0     		add	eax, eax
 5023 30ea 01D0     		add	eax, edx
 5024 30ec C1E003   		sal	eax, 3
 5025 30ef 89C2     		mov	edx, eax
 5026 30f1 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 5027 30f4 01D0     		add	eax, edx
 5028 30f6 8B4010   		mov	eax, DWORD PTR [eax+16]
 5029 30f9 83EC04   		sub	esp, 4
 5030 30fc 6A10     		push	16
 5031 30fe FF75F4   		push	DWORD PTR [ebp-12]
 5032 3101 50       		push	eax
 5033 3102 E8FCFFFF 		call	Itoa
 5033      FF
 5034 3107 83C410   		add	esp, 16
 5035 310a 8945F4   		mov	DWORD PTR [ebp-12], eax
1073:host.c        ****                 print(pErr);
 5036              		.loc 1 1073 0
 5037 310d 83EC0C   		sub	esp, 12
 5038 3110 FF75F4   		push	DWORD PTR [ebp-12]
 5039 3113 E8FCFFFF 		call	print
 5039      FF
 5040 3118 83C410   		add	esp, 16
1074:host.c        ****                 break;
 5041              		.loc 1 1074 0
 5042 311b 90       		nop
 5043              	.L134:
1075:host.c        ****         }
1076:host.c        ****         println("");
 5044              		.loc 1 1076 0
 5045 311c 83EC0C   		sub	esp, 12
 5046 311f 684A0600 		push	OFFSET FLAT:.LC99
 5046      00
 5047 3124 E8FCFFFF 		call	println
 5047      FF
 5048 3129 83C410   		add	esp, 16
1077:host.c        ****         for (cnt2=0;cnt2<24;cnt2++)
 5049              		.loc 1 1077 0
 5050 312c C745EC00 		mov	DWORD PTR [ebp-20], 0
 5050      000000
 5051 3133 EB7B     		jmp	.L135
 5052              	.L137:
 5053              	.LBB4:
1078:host.c        ****         {
1079:host.c        ****             BYTE* lTemp = (BYTE *)(vhost.e820MemMap);
 5054              		.loc 1 1079 0
 5055 3135 A1400000 		mov	eax, DWORD PTR vhost+64
 5055      00
 5056 313a 8945E4   		mov	DWORD PTR [ebp-28], eax
1080:host.c        ****             sprintf(pErr,"%02x",lTemp[(cnt*24)+cnt2]);
 5057              		.loc 1 1080 0
 5058 313d 8B55F0   		mov	edx, DWORD PTR [ebp-16]
 5059 3140 89D0     		mov	eax, edx
 5060 3142 01C0     		add	eax, eax
 5061 3144 01D0     		add	eax, edx
 5062 3146 C1E003   		sal	eax, 3
 5063 3149 89C2     		mov	edx, eax
 5064 314b 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 5065 314e 01D0     		add	eax, edx
 5066 3150 89C2     		mov	edx, eax
 5067 3152 8B45E4   		mov	eax, DWORD PTR [ebp-28]
 5068 3155 01D0     		add	eax, edx
 5069 3157 0FB600   		movzx	eax, BYTE PTR [eax]
 5070 315a 0FB6C0   		movzx	eax, al
 5071 315d 83EC04   		sub	esp, 4
 5072 3160 50       		push	eax
 5073 3161 684B0600 		push	OFFSET FLAT:.LC100
 5073      00
 5074 3166 FF75F4   		push	DWORD PTR [ebp-12]
 5075 3169 E8FCFFFF 		call	sprintf
 5075      FF
 5076 316e 83C410   		add	esp, 16
1081:host.c        ****             print(pErr);
 5077              		.loc 1 1081 0
 5078 3171 83EC0C   		sub	esp, 12
 5079 3174 FF75F4   		push	DWORD PTR [ebp-12]
 5080 3177 E8FCFFFF 		call	print
 5080      FF
 5081 317c 83C410   		add	esp, 16
1082:host.c        ****             print(" ");
 5082              		.loc 1 1082 0
 5083 317f 83EC0C   		sub	esp, 12
 5084 3182 68E70200 		push	OFFSET FLAT:.LC31
 5084      00
 5085 3187 E8FCFFFF 		call	print
 5085      FF
 5086 318c 83C410   		add	esp, 16
1083:host.c        ****             if ( (cnt2+1) % 8 == 0)
 5087              		.loc 1 1083 0
 5088 318f 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 5089 3192 83C001   		add	eax, 1
 5090 3195 83E007   		and	eax, 7
 5091 3198 85C0     		test	eax, eax
 5092 319a 7510     		jne	.L136
1084:host.c        ****                 print(" ");
 5093              		.loc 1 1084 0
 5094 319c 83EC0C   		sub	esp, 12
 5095 319f 68E70200 		push	OFFSET FLAT:.LC31
 5095      00
 5096 31a4 E8FCFFFF 		call	print
 5096      FF
 5097 31a9 83C410   		add	esp, 16
 5098              	.L136:
 5099              	.LBE4:
1077:host.c        ****         {
 5100              		.loc 1 1077 0 discriminator 2
 5101 31ac 8345EC01 		add	DWORD PTR [ebp-20], 1
 5102              	.L135:
1077:host.c        ****         {
 5103              		.loc 1 1077 0 is_stmt 0 discriminator 1
 5104 31b0 837DEC17 		cmp	DWORD PTR [ebp-20], 23
 5105 31b4 0F8E7BFF 		jle	.L137
 5105      FFFF
1085:host.c        ****         }
1086:host.c        ****             
1087:host.c        ****         println("");
 5106              		.loc 1 1087 0 is_stmt 1
 5107 31ba 83EC0C   		sub	esp, 12
 5108 31bd 684A0600 		push	OFFSET FLAT:.LC99
 5108      00
 5109 31c2 E8FCFFFF 		call	println
 5109      FF
 5110 31c7 83C410   		add	esp, 16
 5111              	.LBE3:
1088:host.c        ****     } while (e820[++cnt].size != 0);
 5112              		.loc 1 1088 0
 5113 31ca 8345F001 		add	DWORD PTR [ebp-16], 1
 5114 31ce 8B55F0   		mov	edx, DWORD PTR [ebp-16]
 5115 31d1 89D0     		mov	eax, edx
 5116 31d3 01C0     		add	eax, eax
 5117 31d5 01D0     		add	eax, edx
 5118 31d7 C1E003   		sal	eax, 3
 5119 31da 89C2     		mov	edx, eax
 5120 31dc 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 5121 31df 01D0     		add	eax, edx
 5122 31e1 8B500C   		mov	edx, DWORD PTR [eax+12]
 5123 31e4 8B4008   		mov	eax, DWORD PTR [eax+8]
 5124 31e7 09D0     		or	eax, edx
 5125 31e9 85C0     		test	eax, eax
 5126 31eb 0F857FFD 		jne	.L138
 5126      FFFF
1089:host.c        ****     printAt("***Done***",0,21);
 5127              		.loc 1 1089 0
 5128 31f1 83EC04   		sub	esp, 4
 5129 31f4 6A15     		push	21
 5130 31f6 6A00     		push	0
 5131 31f8 68500600 		push	OFFSET FLAT:.LC101
 5131      00
 5132 31fd E8FCFFFF 		call	printAt
 5132      FF
 5133 3202 83C410   		add	esp, 16
1090:host.c        ****     HostScancode = 0;
 5134              		.loc 1 1090 0
 5135 3205 C6050000 		mov	BYTE PTR HostScancode, 0
 5135      000000
1091:host.c        ****     while (HostScancode == 0)
 5136              		.loc 1 1091 0
 5137 320c 90       		nop
 5138              	.L139:
 5139              		.loc 1 1091 0 is_stmt 0 discriminator 1
 5140 320d 0FB60500 		movzx	eax, BYTE PTR HostScancode
 5140      000000
 5141 3214 84C0     		test	al, al
 5142 3216 74F5     		je	.L139
1092:host.c        ****     {}
1093:host.c        **** }
 5143              		.loc 1 1093 0 is_stmt 1
 5144 3218 90       		nop
 5145 3219 8D65F8   		lea	esp, [ebp-8]
 5146 321c 5B       		pop	ebx
 5147              		.cfi_restore 3
 5148 321d 5E       		pop	esi
 5149              		.cfi_restore 6
 5150 321e 5D       		pop	ebp
 5151              		.cfi_restore 5
 5152              		.cfi_def_cfa 4, 4
 5153 321f C3       		ret
 5154              		.cfi_endproc
 5155              	.LFE15:
 5157              	.Letext0:
 5158              		.file 2 "types.h"
 5159              		.file 3 "xen_types.h"
 5160              		.file 4 "x86_architecture.h"
 5161              		.file 5 "vmcb.h"
 5162              		.file 6 "guest.h"
 5163              		.file 7 "pmode.h"
 5164              		.file 8 "host.h"
 5165              		.file 9 "isr_wrapper.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 host.c
     /tmp/ccb2vt7W.s:4      .text:0000000000000000 .Ltext0
                            *COM*:000000000000001c guest
                            *COM*:0000000000000038 GuestRegisters
                            *COM*:0000000000000002 _exception_number
                            *COM*:0000000000000002 _exc_CS
                            *COM*:0000000000000002 _exc_IP
                            *COM*:0000000000000044 vhost
                            *COM*:0000000000000004 lTempDest
                            *COM*:0000000000000004 lTempSource
                            *COM*:0000000000000038 HostRegisters
     /tmp/ccb2vt7W.s:19     .data:0000000000000000 HostExceptMsg
                            *COM*:0000000000000008 HostTimerTicks
                            *COM*:0000000000000001 HostScancode
                            *COM*:0000000000000004 VMCBFinalAddress
     /tmp/ccb2vt7W.s:30     .bss:0000000000000000 gInterceptCode
     /tmp/ccb2vt7W.s:36     .bss:0000000000000008 InterceptCount
     /tmp/ccb2vt7W.s:39     .rodata:0000000000000000 .LC0
     /tmp/ccb2vt7W.s:41     .rodata:000000000000001a .LC1
     /tmp/ccb2vt7W.s:46     .text:0000000000000000 host_isr_handler
     /tmp/ccb2vt7W.s:47     .text:0000000000000000 .LFB0
     /tmp/ccb2vt7W.s:373    .text:00000000000002cb .L42
     /tmp/ccb2vt7W.s:320    .text:0000000000000238 .L4
     /tmp/ccb2vt7W.s:85     .rodata:000000000000001c .L6
     /tmp/ccb2vt7W.s:121    .text:000000000000004a .L5
     /tmp/ccb2vt7W.s:126    .text:0000000000000056 .L7
     /tmp/ccb2vt7W.s:131    .text:0000000000000062 .L8
     /tmp/ccb2vt7W.s:136    .text:000000000000006e .L9
     /tmp/ccb2vt7W.s:141    .text:000000000000007a .L10
     /tmp/ccb2vt7W.s:146    .text:0000000000000086 .L11
     /tmp/ccb2vt7W.s:151    .text:0000000000000092 .L12
     /tmp/ccb2vt7W.s:156    .text:000000000000009e .L13
     /tmp/ccb2vt7W.s:161    .text:00000000000000aa .L14
     /tmp/ccb2vt7W.s:166    .text:00000000000000b6 .L15
     /tmp/ccb2vt7W.s:171    .text:00000000000000c2 .L16
     /tmp/ccb2vt7W.s:176    .text:00000000000000ce .L17
     /tmp/ccb2vt7W.s:181    .text:00000000000000da .L18
     /tmp/ccb2vt7W.s:186    .text:00000000000000e6 .L19
     /tmp/ccb2vt7W.s:191    .text:00000000000000f2 .L20
     /tmp/ccb2vt7W.s:196    .text:00000000000000fe .L21
     /tmp/ccb2vt7W.s:201    .text:000000000000010a .L22
     /tmp/ccb2vt7W.s:208    .text:000000000000011d .L23
     /tmp/ccb2vt7W.s:215    .text:0000000000000130 .L24
     /tmp/ccb2vt7W.s:222    .text:0000000000000143 .L25
     /tmp/ccb2vt7W.s:229    .text:0000000000000156 .L26
     /tmp/ccb2vt7W.s:236    .text:0000000000000169 .L27
     /tmp/ccb2vt7W.s:243    .text:000000000000017c .L28
     /tmp/ccb2vt7W.s:250    .text:000000000000018f .L29
     /tmp/ccb2vt7W.s:257    .text:00000000000001a2 .L30
     /tmp/ccb2vt7W.s:264    .text:00000000000001b5 .L31
     /tmp/ccb2vt7W.s:271    .text:00000000000001c8 .L32
     /tmp/ccb2vt7W.s:278    .text:00000000000001d8 .L33
     /tmp/ccb2vt7W.s:285    .text:00000000000001e8 .L34
     /tmp/ccb2vt7W.s:292    .text:00000000000001f8 .L35
     /tmp/ccb2vt7W.s:299    .text:0000000000000208 .L36
     /tmp/ccb2vt7W.s:306    .text:0000000000000218 .L37
     /tmp/ccb2vt7W.s:313    .text:0000000000000228 .L38
     /tmp/ccb2vt7W.s:327    .text:000000000000024d .L39
     /tmp/ccb2vt7W.s:370    .text:00000000000002c9 .L40
     /tmp/ccb2vt7W.s:382    .text:00000000000002ce .LFE0
     /tmp/ccb2vt7W.s:386    .rodata:00000000000000a4 .LC2
     /tmp/ccb2vt7W.s:391    .text:00000000000002ce host_paging_handler
     /tmp/ccb2vt7W.s:392    .text:00000000000002ce .LFB1
     /tmp/ccb2vt7W.s:408    .text:00000000000002e8 .L44
     /tmp/ccb2vt7W.s:412    .text:00000000000002ea .LFE1
     /tmp/ccb2vt7W.s:416    .text:00000000000002ea timer_handler
     /tmp/ccb2vt7W.s:417    .text:00000000000002ea .LFB2
     /tmp/ccb2vt7W.s:459    .text:0000000000000301 .LFE2
     /tmp/ccb2vt7W.s:463    .text:0000000000000301 kbd_handler
     /tmp/ccb2vt7W.s:464    .text:0000000000000301 .LFB3
              host.c:220    .text:0000000000000313 overSaveScanCode
     /tmp/ccb2vt7W.s:521    .text:000000000000031a .LFE3
     /tmp/ccb2vt7W.s:525    .text:000000000000031a setup_IDT_entry
     /tmp/ccb2vt7W.s:526    .text:000000000000031a .LFB4
     /tmp/ccb2vt7W.s:596    .text:0000000000000387 .LFE4
     /tmp/ccb2vt7W.s:600    .text:0000000000000387 SetupHostIDT
     /tmp/ccb2vt7W.s:601    .text:0000000000000387 .LFB5
     /tmp/ccb2vt7W.s:994    .text:00000000000007ba .LFE5
     /tmp/ccb2vt7W.s:998    .text:00000000000007ba UpdatePDEntry
     /tmp/ccb2vt7W.s:999    .text:00000000000007ba .LFB6
     /tmp/ccb2vt7W.s:1049   .text:00000000000007fc .LFE6
     /tmp/ccb2vt7W.s:1052   .rodata:00000000000000c9 .LC3
     /tmp/ccb2vt7W.s:1055   .rodata:00000000000000df .LC4
     /tmp/ccb2vt7W.s:1057   .rodata:00000000000000e2 .LC5
     /tmp/ccb2vt7W.s:1059   .rodata:00000000000000e9 .LC6
     /tmp/ccb2vt7W.s:1061   .rodata:00000000000000f0 .LC7
     /tmp/ccb2vt7W.s:1063   .rodata:00000000000000f7 .LC8
     /tmp/ccb2vt7W.s:1065   .rodata:00000000000000fa .LC9
     /tmp/ccb2vt7W.s:1067   .rodata:00000000000000fd .LC10
     /tmp/ccb2vt7W.s:1069   .rodata:0000000000000108 .LC11
     /tmp/ccb2vt7W.s:1071   .rodata:0000000000000114 .LC12
     /tmp/ccb2vt7W.s:1073   .rodata:0000000000000120 .LC13
     /tmp/ccb2vt7W.s:1076   .rodata:000000000000012c .LC14
     /tmp/ccb2vt7W.s:1078   .rodata:0000000000000158 .LC15
     /tmp/ccb2vt7W.s:1080   .rodata:000000000000015f .LC16
     /tmp/ccb2vt7W.s:1083   .rodata:000000000000016c .LC17
     /tmp/ccb2vt7W.s:1085   .rodata:000000000000018e .LC18
     /tmp/ccb2vt7W.s:1088   .rodata:000000000000019c .LC19
     /tmp/ccb2vt7W.s:1090   .rodata:00000000000001cc .LC20
     /tmp/ccb2vt7W.s:1092   .rodata:00000000000001e1 .LC21
     /tmp/ccb2vt7W.s:1094   .rodata:00000000000001f0 .LC22
     /tmp/ccb2vt7W.s:1096   .rodata:00000000000001f3 .LC23
     /tmp/ccb2vt7W.s:1098   .rodata:00000000000001ff .LC24
     /tmp/ccb2vt7W.s:1100   .rodata:000000000000020d .LC25
     /tmp/ccb2vt7W.s:1104   .rodata:000000000000022c .LC26
     /tmp/ccb2vt7W.s:1106   .rodata:000000000000025c .LC27
     /tmp/ccb2vt7W.s:1111   .text:00000000000007fc ProcessVMRunResults
     /tmp/ccb2vt7W.s:1112   .text:00000000000007fc .LFB7
     /tmp/ccb2vt7W.s:1194   .text:00000000000008cd .L51
     /tmp/ccb2vt7W.s:1187   .text:00000000000008bb .L52
     /tmp/ccb2vt7W.s:1200   .text:00000000000008dd .L54
     /tmp/ccb2vt7W.s:1223   .text:0000000000000921 .L55
     /tmp/ccb2vt7W.s:1229   .text:0000000000000931 .L56
     /tmp/ccb2vt7W.s:1453   .text:0000000000000be7 .L58
     /tmp/ccb2vt7W.s:1387   .text:0000000000000b21 .L59
     /tmp/ccb2vt7W.s:1777   .text:0000000000000fe1 .L60
     /tmp/ccb2vt7W.s:1394   .text:0000000000000b38 .L61
     /tmp/ccb2vt7W.s:1438   .text:0000000000000bb0 .L62
     /tmp/ccb2vt7W.s:1401   .text:0000000000000b47 .L63
     /tmp/ccb2vt7W.s:1408   .text:0000000000000b5e .L64
     /tmp/ccb2vt7W.s:1671   .text:0000000000000ead .L65
     /tmp/ccb2vt7W.s:1425   .text:0000000000000b8b .L66
     /tmp/ccb2vt7W.s:1420   .text:0000000000000b7c .L67
     /tmp/ccb2vt7W.s:1666   .text:0000000000000ea3 .L68
     /tmp/ccb2vt7W.s:2201   .text:000000000000154d .L57
     /tmp/ccb2vt7W.s:1676   .text:0000000000000eb7 .L69
     /tmp/ccb2vt7W.s:1751   .text:0000000000000fa1 .L70
     /tmp/ccb2vt7W.s:1445   .text:0000000000000bc7 .L71
     /tmp/ccb2vt7W.s:1531   .text:0000000000000cb7 .L73
     /tmp/ccb2vt7W.s:1596   .text:0000000000000d9c .L74
     /tmp/ccb2vt7W.s:1498   .text:0000000000000c5e .L75
     /tmp/ccb2vt7W.s:1465   .text:0000000000000c05 .L76
     /tmp/ccb2vt7W.s:2116   .text:0000000000001439 .L77
     /tmp/ccb2vt7W.s:1485   .text:0000000000000c39 .L78
     /tmp/ccb2vt7W.s:1477   .text:0000000000000c23 .L79
     /tmp/ccb2vt7W.s:2132   .text:0000000000001464 .L80
     /tmp/ccb2vt7W.s:1655   .text:0000000000000e7c .L81
     /tmp/ccb2vt7W.s:1756   .text:0000000000000fab .L82
     /tmp/ccb2vt7W.s:1518   .text:0000000000000c92 .L83
     /tmp/ccb2vt7W.s:1510   .text:0000000000000c7c .L84
     /tmp/ccb2vt7W.s:2074   .text:00000000000013b4 .L85
     /tmp/ccb2vt7W.s:1761   .text:0000000000000fb5 .L86
     /tmp/ccb2vt7W.s:2235   .text:00000000000015a7 .L101
     /tmp/ccb2vt7W.s:1549   .text:0000000000000cea .L89
     /tmp/ccb2vt7W.s:2445   .text:0000000000001706 InfiniteLoop
     /tmp/ccb2vt7W.s:2242   .text:00000000000015ab .L88
     /tmp/ccb2vt7W.s:1623   .text:0000000000000dfd .L91
     /tmp/ccb2vt7W.s:1934   .text:00000000000011cc .L93
     /tmp/ccb2vt7W.s:2239   .text:00000000000015aa .L102
     /tmp/ccb2vt7W.s:1970   .text:0000000000001245 .L95
     /tmp/ccb2vt7W.s:2006   .text:00000000000012be .L96
     /tmp/ccb2vt7W.s:2065   .text:0000000000001398 .L97
     /tmp/ccb2vt7W.s:2106   .text:0000000000001411 .L98
     /tmp/ccb2vt7W.s:2145   .text:0000000000001499 .L99
     /tmp/ccb2vt7W.s:2190   .text:0000000000001528 .L100
     /tmp/ccb2vt7W.s:2146   .text:0000000000001499 .LBB2
     /tmp/ccb2vt7W.s:2191   .text:0000000000001528 .LBE2
     /tmp/ccb2vt7W.s:2277   .text:00000000000015bb .LFE7
     /tmp/ccb2vt7W.s:2281   .rodata:0000000000000274 .LC28
     /tmp/ccb2vt7W.s:2286   .text:00000000000015bb DoVisor
     /tmp/ccb2vt7W.s:2287   .text:00000000000015bb .LFB8
     /tmp/ccb2vt7W.s:2325   .text:000000000000161b .L105
     /tmp/ccb2vt7W.s:2360   .text:000000000000166e .L104
     /tmp/ccb2vt7W.s:2430   .text:0000000000001706 .LFE8
     /tmp/ccb2vt7W.s:2434   .rodata:000000000000029c .LC29
     /tmp/ccb2vt7W.s:2436   .rodata:00000000000002d6 .LC30
     /tmp/ccb2vt7W.s:2438   .rodata:00000000000002e7 .LC31
     /tmp/ccb2vt7W.s:2440   .rodata:00000000000002e9 .LC32
     /tmp/ccb2vt7W.s:2446   .text:0000000000001706 .LFB9
     /tmp/ccb2vt7W.s:2573   .text:0000000000001871 .L107
     /tmp/ccb2vt7W.s:2536   .text:0000000000001801 .L108
     /tmp/ccb2vt7W.s:3561   .text:00000000000020b0 DumpVMCB
     /tmp/ccb2vt7W.s:2606   .text:00000000000018cc .L109
     /tmp/ccb2vt7W.s:2610   .text:00000000000018ce .LFE9
     /tmp/ccb2vt7W.s:2614   .text:00000000000018ce SetupHostPaging
     /tmp/ccb2vt7W.s:2615   .text:00000000000018ce .LFB10
     /tmp/ccb2vt7W.s:2705   .text:000000000000199f .L111
     /tmp/ccb2vt7W.s:2664   .text:0000000000001933 .L114
     /tmp/ccb2vt7W.s:2697   .text:000000000000198b .L112
     /tmp/ccb2vt7W.s:2681   .text:0000000000001963 .L113
     /tmp/ccb2vt7W.s:2764   .text:0000000000001a35 .L115
     /tmp/ccb2vt7W.s:2721   .text:00000000000019c4 .L118
     /tmp/ccb2vt7W.s:2756   .text:0000000000001a21 .L116
     /tmp/ccb2vt7W.s:2738   .text:00000000000019f4 .L117
     /tmp/ccb2vt7W.s:2789   .text:0000000000001a4e .LFE10
     /tmp/ccb2vt7W.s:2793   .text:0000000000001a4e RelocateMyself
     /tmp/ccb2vt7W.s:2794   .text:0000000000001a4e .LFB11
              host.c:710    .text:0000000000001aa7 _jmp1
     /tmp/ccb2vt7W.s:2868   .text:0000000000001adc .LFE11
     /tmp/ccb2vt7W.s:2872   .text:0000000000001adc SaveHostBIOS
     /tmp/ccb2vt7W.s:2873   .text:0000000000001adc .LFB12
     /tmp/ccb2vt7W.s:2928   .text:0000000000001b4a .LFE12
     /tmp/ccb2vt7W.s:2931   .rodata:00000000000002f5 .LC33
     /tmp/ccb2vt7W.s:2933   .rodata:000000000000030e .LC34
     /tmp/ccb2vt7W.s:2936   .rodata:0000000000000324 .LC35
     /tmp/ccb2vt7W.s:2938   .rodata:0000000000000348 .LC36
     /tmp/ccb2vt7W.s:2940   .rodata:000000000000035e .LC37
     /tmp/ccb2vt7W.s:2942   .rodata:000000000000036b .LC38
     /tmp/ccb2vt7W.s:2944   .rodata:0000000000000379 .LC39
     /tmp/ccb2vt7W.s:2946   .rodata:0000000000000382 .LC40
     /tmp/ccb2vt7W.s:2948   .rodata:000000000000038b .LC41
     /tmp/ccb2vt7W.s:2950   .rodata:000000000000039b .LC42
     /tmp/ccb2vt7W.s:2952   .rodata:00000000000003a3 .LC43
     /tmp/ccb2vt7W.s:2954   .rodata:00000000000003ab .LC44
     /tmp/ccb2vt7W.s:2956   .rodata:00000000000003be .LC45
     /tmp/ccb2vt7W.s:2958   .rodata:00000000000003d1 .LC46
     /tmp/ccb2vt7W.s:2960   .rodata:00000000000003e5 .LC47
     /tmp/ccb2vt7W.s:2962   .rodata:00000000000003f4 .LC48
     /tmp/ccb2vt7W.s:2964   .rodata:000000000000040e .LC49
     /tmp/ccb2vt7W.s:2966   .rodata:000000000000041c .LC50
     /tmp/ccb2vt7W.s:2968   .rodata:000000000000042f .LC51
     /tmp/ccb2vt7W.s:2970   .rodata:0000000000000432 .LC52
     /tmp/ccb2vt7W.s:2975   .text:0000000000001b4a PrintHostInformation
     /tmp/ccb2vt7W.s:2976   .text:0000000000001b4a .LFB13
     /tmp/ccb2vt7W.s:3463   .text:00000000000020a2 .L122
     /tmp/ccb2vt7W.s:3475   .text:00000000000020b0 .LFE13
     /tmp/ccb2vt7W.s:3478   .rodata:000000000000043a .LC53
     /tmp/ccb2vt7W.s:3480   .rodata:000000000000044a .LC54
     /tmp/ccb2vt7W.s:3482   .rodata:0000000000000457 .LC55
     /tmp/ccb2vt7W.s:3484   .rodata:0000000000000461 .LC56
     /tmp/ccb2vt7W.s:3486   .rodata:000000000000046f .LC57
     /tmp/ccb2vt7W.s:3488   .rodata:000000000000047c .LC58
     /tmp/ccb2vt7W.s:3490   .rodata:000000000000048a .LC59
     /tmp/ccb2vt7W.s:3492   .rodata:0000000000000497 .LC60
     /tmp/ccb2vt7W.s:3494   .rodata:00000000000004a1 .LC61
     /tmp/ccb2vt7W.s:3496   .rodata:00000000000004ab .LC62
     /tmp/ccb2vt7W.s:3498   .rodata:00000000000004b6 .LC63
     /tmp/ccb2vt7W.s:3500   .rodata:00000000000004bf .LC64
     /tmp/ccb2vt7W.s:3502   .rodata:00000000000004c8 .LC65
     /tmp/ccb2vt7W.s:3504   .rodata:00000000000004d2 .LC66
     /tmp/ccb2vt7W.s:3506   .rodata:00000000000004dd .LC67
     /tmp/ccb2vt7W.s:3508   .rodata:00000000000004e8 .LC68
     /tmp/ccb2vt7W.s:3510   .rodata:00000000000004f0 .LC69
     /tmp/ccb2vt7W.s:3512   .rodata:00000000000004fb .LC70
     /tmp/ccb2vt7W.s:3514   .rodata:0000000000000508 .LC71
     /tmp/ccb2vt7W.s:3516   .rodata:000000000000050d .LC72
     /tmp/ccb2vt7W.s:3518   .rodata:0000000000000515 .LC73
     /tmp/ccb2vt7W.s:3520   .rodata:000000000000051d .LC74
     /tmp/ccb2vt7W.s:3522   .rodata:0000000000000522 .LC75
     /tmp/ccb2vt7W.s:3524   .rodata:000000000000052a .LC76
     /tmp/ccb2vt7W.s:3526   .rodata:0000000000000532 .LC77
     /tmp/ccb2vt7W.s:3528   .rodata:000000000000053c .LC78
     /tmp/ccb2vt7W.s:3530   .rodata:0000000000000546 .LC79
     /tmp/ccb2vt7W.s:3532   .rodata:0000000000000550 .LC80
     /tmp/ccb2vt7W.s:3534   .rodata:0000000000000556 .LC81
     /tmp/ccb2vt7W.s:3536   .rodata:0000000000000560 .LC82
     /tmp/ccb2vt7W.s:3538   .rodata:0000000000000569 .LC83
     /tmp/ccb2vt7W.s:3540   .rodata:0000000000000572 .LC84
     /tmp/ccb2vt7W.s:3542   .rodata:000000000000057b .LC85
     /tmp/ccb2vt7W.s:3544   .rodata:0000000000000587 .LC86
     /tmp/ccb2vt7W.s:3546   .rodata:0000000000000590 .LC87
     /tmp/ccb2vt7W.s:3548   .rodata:0000000000000599 .LC88
     /tmp/ccb2vt7W.s:3550   .rodata:00000000000005a2 .LC89
     /tmp/ccb2vt7W.s:3552   .rodata:00000000000005ab .LC90
     /tmp/ccb2vt7W.s:3554   .rodata:00000000000005b6 .LC91
     /tmp/ccb2vt7W.s:3556   .rodata:00000000000005c5 .LC92
     /tmp/ccb2vt7W.s:3562   .text:00000000000020b0 .LFB14
     /tmp/ccb2vt7W.s:4793   .text:0000000000002f3d .L124
     /tmp/ccb2vt7W.s:4805   .text:0000000000002f4b .LFE14
     /tmp/ccb2vt7W.s:4808   .rodata:00000000000005d4 .LC93
     /tmp/ccb2vt7W.s:4810   .rodata:00000000000005ec .LC94
     /tmp/ccb2vt7W.s:4814   .rodata:0000000000000608 .LC95
     /tmp/ccb2vt7W.s:4816   .rodata:000000000000062c .LC96
     /tmp/ccb2vt7W.s:4818   .rodata:0000000000000630 .LC97
     /tmp/ccb2vt7W.s:4820   .rodata:0000000000000639 .LC98
     /tmp/ccb2vt7W.s:4822   .rodata:000000000000064a .LC99
     /tmp/ccb2vt7W.s:4824   .rodata:000000000000064b .LC100
     /tmp/ccb2vt7W.s:4826   .rodata:0000000000000650 .LC101
     /tmp/ccb2vt7W.s:4831   .text:0000000000002f4b PrintE820Data
     /tmp/ccb2vt7W.s:4832   .text:0000000000002f4b .LFB15
     /tmp/ccb2vt7W.s:4853   .text:0000000000002f70 .L138
     /tmp/ccb2vt7W.s:4854   .text:0000000000002f70 .LBB3
     /tmp/ccb2vt7W.s:4875   .text:0000000000002f9c .L126
     /tmp/ccb2vt7W.s:4903   .text:0000000000002fde .L127
     /tmp/ccb2vt7W.s:4895   .text:0000000000002fc9 .L128
     /tmp/ccb2vt7W.s:4890   .text:0000000000002fbe .L129
     /tmp/ccb2vt7W.s:5002   .text:00000000000030bf .L131
     /tmp/ccb2vt7W.s:5010   .text:00000000000030d1 .L132
     /tmp/ccb2vt7W.s:5018   .text:00000000000030e3 .L140
     /tmp/ccb2vt7W.s:5043   .text:000000000000311c .L134
     /tmp/ccb2vt7W.s:5102   .text:00000000000031b0 .L135
     /tmp/ccb2vt7W.s:5052   .text:0000000000003135 .L137
     /tmp/ccb2vt7W.s:5053   .text:0000000000003135 .LBB4
     /tmp/ccb2vt7W.s:5098   .text:00000000000031ac .L136
     /tmp/ccb2vt7W.s:5099   .text:00000000000031ac .LBE4
     /tmp/ccb2vt7W.s:5111   .text:00000000000031ca .LBE3
     /tmp/ccb2vt7W.s:5138   .text:000000000000320d .L139
     /tmp/ccb2vt7W.s:5155   .text:0000000000003220 .LFE15
     /tmp/ccb2vt7W.s:5157   .text:0000000000003220 .Letext0
     /tmp/ccb2vt7W.s:5167   .debug_info:0000000000000000 .Ldebug_info0
     /tmp/ccb2vt7W.s:7647   .debug_abbrev:0000000000000000 .Ldebug_abbrev0
     /tmp/ccb2vt7W.s:8747   .debug_str:000000000000072e .LASF336
     /tmp/ccb2vt7W.s:8611   .debug_str:0000000000000387 .LASF337
     /tmp/ccb2vt7W.s:8711   .debug_str:0000000000000632 .LASF338
     /tmp/ccb2vt7W.s:8447   .debug_line:0000000000000000 .Ldebug_line0
     /tmp/ccb2vt7W.s:8557   .debug_str:000000000000022e .LASF0
     /tmp/ccb2vt7W.s:8631   .debug_str:000000000000040f .LASF2
     /tmp/ccb2vt7W.s:8917   .debug_str:0000000000000baa .LASF1
     /tmp/ccb2vt7W.s:9085   .debug_str:0000000000000fe8 .LASF3
     /tmp/ccb2vt7W.s:8891   .debug_str:0000000000000b14 .LASF4
     /tmp/ccb2vt7W.s:8753   .debug_str:00000000000007a1 .LASF5
     /tmp/ccb2vt7W.s:8881   .debug_str:0000000000000adf .LASF6
     /tmp/ccb2vt7W.s:8941   .debug_str:0000000000000c3e .LASF7
     /tmp/ccb2vt7W.s:8609   .debug_str:000000000000037b .LASF8
     /tmp/ccb2vt7W.s:9019   .debug_str:0000000000000e56 .LASF9
     /tmp/ccb2vt7W.s:8493   .debug_str:00000000000000de .LASF10
     /tmp/ccb2vt7W.s:8547   .debug_str:0000000000000202 .LASF11
     /tmp/ccb2vt7W.s:8851   .debug_str:0000000000000a0a .LASF12
     /tmp/ccb2vt7W.s:8819   .debug_str:000000000000093c .LASF13
     /tmp/ccb2vt7W.s:8617   .debug_str:00000000000003b5 .LASF14
     /tmp/ccb2vt7W.s:8663   .debug_str:00000000000004e3 .LASF15
     /tmp/ccb2vt7W.s:8955   .debug_str:0000000000000cc5 .LASF16
     /tmp/ccb2vt7W.s:9071   .debug_str:0000000000000f85 .LASF17
     /tmp/ccb2vt7W.s:9025   .debug_str:0000000000000e77 .LASF18
     /tmp/ccb2vt7W.s:8527   .debug_str:0000000000000190 .LASF19
     /tmp/ccb2vt7W.s:9119   .debug_str:00000000000010aa .LASF20
     /tmp/ccb2vt7W.s:8675   .debug_str:0000000000000533 .LASF21
     /tmp/ccb2vt7W.s:8661   .debug_str:00000000000004dd .LASF22
     /tmp/ccb2vt7W.s:8931   .debug_str:0000000000000c06 .LASF23
     /tmp/ccb2vt7W.s:8795   .debug_str:000000000000089c .LASF24
     /tmp/ccb2vt7W.s:8589   .debug_str:0000000000000301 .LASF42
     /tmp/ccb2vt7W.s:8669   .debug_str:000000000000050d .LASF25
     /tmp/ccb2vt7W.s:8695   .debug_str:00000000000005bc .LASF26
     /tmp/ccb2vt7W.s:9089   .debug_str:0000000000001006 .LASF27
     /tmp/ccb2vt7W.s:8975   .debug_str:0000000000000d38 .LASF28
     /tmp/ccb2vt7W.s:8487   .debug_str:00000000000000c2 .LASF29
     /tmp/ccb2vt7W.s:8755   .debug_str:00000000000007b3 .LASF30
     /tmp/ccb2vt7W.s:8509   .debug_str:000000000000010e .LASF31
     /tmp/ccb2vt7W.s:8739   .debug_str:0000000000000716 .LASF32
     /tmp/ccb2vt7W.s:8545   .debug_str:00000000000001fd .LASF33
     /tmp/ccb2vt7W.s:8533   .debug_str:00000000000001ae .LASF34
     /tmp/ccb2vt7W.s:8741   .debug_str:000000000000071c .LASF35
     /tmp/ccb2vt7W.s:8797   .debug_str:00000000000008b1 .LASF36
     /tmp/ccb2vt7W.s:8743   .debug_str:0000000000000722 .LASF37
     /tmp/ccb2vt7W.s:8745   .debug_str:0000000000000728 .LASF38
     /tmp/ccb2vt7W.s:9095   .debug_str:000000000000101f .LASF39
     /tmp/ccb2vt7W.s:8823   .debug_str:000000000000095b .LASF40
     /tmp/ccb2vt7W.s:9105   .debug_str:000000000000104e .LASF41
     /tmp/ccb2vt7W.s:8723   .debug_str:00000000000006a7 .LASF43
     /tmp/ccb2vt7W.s:8535   .debug_str:00000000000001b6 .LASF44
     /tmp/ccb2vt7W.s:9033   .debug_str:0000000000000ea3 .LASF45
     /tmp/ccb2vt7W.s:8615   .debug_str:00000000000003a0 .LASF46
     /tmp/ccb2vt7W.s:8761   .debug_str:00000000000007d4 .LASF47
     /tmp/ccb2vt7W.s:8835   .debug_str:00000000000009a8 .LASF48
     /tmp/ccb2vt7W.s:8459   .debug_str:0000000000000035 .LASF49
     /tmp/ccb2vt7W.s:8461   .debug_str:000000000000003b .LASF50
     /tmp/ccb2vt7W.s:8463   .debug_str:0000000000000041 .LASF51
     /tmp/ccb2vt7W.s:8465   .debug_str:0000000000000047 .LASF52
     /tmp/ccb2vt7W.s:8467   .debug_str:000000000000004d .LASF53
     /tmp/ccb2vt7W.s:8469   .debug_str:0000000000000053 .LASF54
     /tmp/ccb2vt7W.s:8827   .debug_str:000000000000096c .LASF55
     /tmp/ccb2vt7W.s:8561   .debug_str:0000000000000241 .LASF56
     /tmp/ccb2vt7W.s:8971   .debug_str:0000000000000d22 .LASF57
     /tmp/ccb2vt7W.s:9035   .debug_str:0000000000000eb1 .LASF58
     /tmp/ccb2vt7W.s:9063   .debug_str:0000000000000f5a .LASF59
     /tmp/ccb2vt7W.s:8471   .debug_str:0000000000000059 .LASF60
     /tmp/ccb2vt7W.s:8961   .debug_str:0000000000000ce7 .LASF61
     /tmp/ccb2vt7W.s:8565   .debug_str:0000000000000259 .LASF62
     /tmp/ccb2vt7W.s:8555   .debug_str:0000000000000225 .LASF63
     /tmp/ccb2vt7W.s:9121   .debug_str:00000000000010af .LASF64
     /tmp/ccb2vt7W.s:9123   .debug_str:00000000000010b9 .LASF65
     /tmp/ccb2vt7W.s:8799   .debug_str:00000000000008be .LASF66
     /tmp/ccb2vt7W.s:8921   .debug_str:0000000000000bbc .LASF67
     /tmp/ccb2vt7W.s:8473   .debug_str:000000000000005f .LASF68
     /tmp/ccb2vt7W.s:9057   .debug_str:0000000000000f39 .LASF69
     /tmp/ccb2vt7W.s:8973   .debug_str:0000000000000d2d .LASF70
     /tmp/ccb2vt7W.s:8801   .debug_str:00000000000008ca .LASF71
     /tmp/ccb2vt7W.s:9053   .debug_str:0000000000000f1c .LASF72
     /tmp/ccb2vt7W.s:8457   .debug_str:000000000000002f .LASF73
     /tmp/ccb2vt7W.s:8839   .debug_str:00000000000009cc .LASF74
     /tmp/ccb2vt7W.s:8779   .debug_str:000000000000083f .LASF75
     /tmp/ccb2vt7W.s:8543   .debug_str:00000000000001f8 .LASF76
     /tmp/ccb2vt7W.s:8895   .debug_str:0000000000000b24 .LASF77
     /tmp/ccb2vt7W.s:8553   .debug_str:0000000000000220 .LASF78
     /tmp/ccb2vt7W.s:8495   .debug_str:00000000000000e4 .LASF79
     /tmp/ccb2vt7W.s:8497   .debug_str:00000000000000ea .LASF80
     /tmp/ccb2vt7W.s:8499   .debug_str:00000000000000f0 .LASF81
     /tmp/ccb2vt7W.s:8451   .debug_str:0000000000000010 .LASF82
     /tmp/ccb2vt7W.s:8501   .debug_str:00000000000000f6 .LASF83
     /tmp/ccb2vt7W.s:8647   .debug_str:000000000000047e .LASF84
     /tmp/ccb2vt7W.s:8503   .debug_str:00000000000000fc .LASF85
     /tmp/ccb2vt7W.s:8505   .debug_str:0000000000000102 .LASF86
     /tmp/ccb2vt7W.s:8529   .debug_str:0000000000000195 .LASF87
     /tmp/ccb2vt7W.s:8841   .debug_str:00000000000009d4 .LASF88
     /tmp/ccb2vt7W.s:8809   .debug_str:00000000000008fd .LASF89
     /tmp/ccb2vt7W.s:8989   .debug_str:0000000000000d91 .LASF90
     /tmp/ccb2vt7W.s:8981   .debug_str:0000000000000d5e .LASF91
     /tmp/ccb2vt7W.s:9111   .debug_str:0000000000001077 .LASF92
     /tmp/ccb2vt7W.s:9107   .debug_str:0000000000001058 .LASF93
     /tmp/ccb2vt7W.s:8911   .debug_str:0000000000000b89 .LASF94
     /tmp/ccb2vt7W.s:8907   .debug_str:0000000000000b7d .LASF95
     /tmp/ccb2vt7W.s:8909   .debug_str:0000000000000b83 .LASF96
     /tmp/ccb2vt7W.s:8489   .debug_str:00000000000000c9 .LASF97
     /tmp/ccb2vt7W.s:8913   .debug_str:0000000000000b96 .LASF98
     /tmp/ccb2vt7W.s:8749   .debug_str:000000000000078a .LASF99
     /tmp/ccb2vt7W.s:8621   .debug_str:00000000000003cb .LASF100
     /tmp/ccb2vt7W.s:8999   .debug_str:0000000000000dd7 .LASF101
     /tmp/ccb2vt7W.s:8643   .debug_str:000000000000045e .LASF102
     /tmp/ccb2vt7W.s:8637   .debug_str:000000000000043e .LASF103
     /tmp/ccb2vt7W.s:9027   .debug_str:0000000000000e80 .LASF104
     /tmp/ccb2vt7W.s:8507   .debug_str:0000000000000108 .LASF105
     /tmp/ccb2vt7W.s:8455   .debug_str:0000000000000026 .LASF106
     /tmp/ccb2vt7W.s:8991   .debug_str:0000000000000d98 .LASF339
     /tmp/ccb2vt7W.s:8683   .debug_str:0000000000000565 .LASF107
     /tmp/ccb2vt7W.s:8859   .debug_str:0000000000000a41 .LASF108
     /tmp/ccb2vt7W.s:8601   .debug_str:0000000000000337 .LASF109
     /tmp/ccb2vt7W.s:9013   .debug_str:0000000000000e3b .LASF110
     /tmp/ccb2vt7W.s:8985   .debug_str:0000000000000d70 .LASF111
     /tmp/ccb2vt7W.s:8717   .debug_str:0000000000000674 .LASF112
     /tmp/ccb2vt7W.s:9117   .debug_str:000000000000109a .LASF113
     /tmp/ccb2vt7W.s:9079   .debug_str:0000000000000fb6 .LASF114
     /tmp/ccb2vt7W.s:8837   .debug_str:00000000000009bc .LASF115
     /tmp/ccb2vt7W.s:8573   .debug_str:000000000000028b .LASF116
     /tmp/ccb2vt7W.s:8933   .debug_str:0000000000000c0d .LASF117
     /tmp/ccb2vt7W.s:8677   .debug_str:0000000000000538 .LASF118
     /tmp/ccb2vt7W.s:8645   .debug_str:000000000000046d .LASF119
     /tmp/ccb2vt7W.s:9049   .debug_str:0000000000000f03 .LASF120
     /tmp/ccb2vt7W.s:8811   .debug_str:0000000000000903 .LASF121
     /tmp/ccb2vt7W.s:8751   .debug_str:0000000000000790 .LASF122
     /tmp/ccb2vt7W.s:8539   .debug_str:00000000000001ce .LASF123
     /tmp/ccb2vt7W.s:8571   .debug_str:000000000000027a .LASF124
     /tmp/ccb2vt7W.s:8607   .debug_str:000000000000036a .LASF125
     /tmp/ccb2vt7W.s:8653   .debug_str:00000000000004a1 .LASF126
     /tmp/ccb2vt7W.s:8671   .debug_str:0000000000000512 .LASF127
     /tmp/ccb2vt7W.s:8703   .debug_str:00000000000005f0 .LASF128
     /tmp/ccb2vt7W.s:8733   .debug_str:00000000000006ea .LASF129
     /tmp/ccb2vt7W.s:8793   .debug_str:000000000000088b .LASF130
     /tmp/ccb2vt7W.s:8821   .debug_str:000000000000094a .LASF131
     /tmp/ccb2vt7W.s:8847   .debug_str:00000000000009e9 .LASF132
     /tmp/ccb2vt7W.s:8575   .debug_str:000000000000029b .LASF133
     /tmp/ccb2vt7W.s:8613   .debug_str:000000000000038e .LASF134
     /tmp/ccb2vt7W.s:8659   .debug_str:00000000000004cb .LASF135
     /tmp/ccb2vt7W.s:8679   .debug_str:0000000000000549 .LASF136
     /tmp/ccb2vt7W.s:8709   .debug_str:0000000000000620 .LASF137
     /tmp/ccb2vt7W.s:9055   .debug_str:0000000000000f27 .LASF138
     /tmp/ccb2vt7W.s:8667   .debug_str:00000000000004fd .LASF139
     /tmp/ccb2vt7W.s:8619   .debug_str:00000000000003bb .LASF140
     /tmp/ccb2vt7W.s:9029   .debug_str:0000000000000e8c .LASF141
     /tmp/ccb2vt7W.s:8783   .debug_str:000000000000084f .LASF142
     /tmp/ccb2vt7W.s:8727   .debug_str:00000000000006bf .LASF143
     /tmp/ccb2vt7W.s:8449   .debug_str:0000000000000000 .LASF144
     /tmp/ccb2vt7W.s:8883   .debug_str:0000000000000ae5 .LASF145
     /tmp/ccb2vt7W.s:8849   .debug_str:00000000000009fa .LASF146
     /tmp/ccb2vt7W.s:8583   .debug_str:00000000000002d1 .LASF147
     /tmp/ccb2vt7W.s:9005   .debug_str:0000000000000dfb .LASF148
     /tmp/ccb2vt7W.s:9075   .debug_str:0000000000000f9f .LASF149
     /tmp/ccb2vt7W.s:8831   .debug_str:000000000000098a .LASF150
     /tmp/ccb2vt7W.s:8625   .debug_str:00000000000003e1 .LASF151
     /tmp/ccb2vt7W.s:8525   .debug_str:000000000000017f .LASF152
     /tmp/ccb2vt7W.s:8947   .debug_str:0000000000000c7d .LASF153
     /tmp/ccb2vt7W.s:8897   .debug_str:0000000000000b29 .LASF154
     /tmp/ccb2vt7W.s:8685   .debug_str:0000000000000575 .LASF155
     /tmp/ccb2vt7W.s:8719   .debug_str:0000000000000684 .LASF156
     /tmp/ccb2vt7W.s:8759   .debug_str:00000000000007c3 .LASF157
     /tmp/ccb2vt7W.s:8807   .debug_str:00000000000008ec .LASF158
     /tmp/ccb2vt7W.s:8829   .debug_str:0000000000000979 .LASF159
     /tmp/ccb2vt7W.s:8857   .debug_str:0000000000000a30 .LASF160
     /tmp/ccb2vt7W.s:8885   .debug_str:0000000000000af5 .LASF161
     /tmp/ccb2vt7W.s:8927   .debug_str:0000000000000be1 .LASF162
     /tmp/ccb2vt7W.s:8967   .debug_str:0000000000000d02 .LASF163
     /tmp/ccb2vt7W.s:8995   .debug_str:0000000000000db4 .LASF164
     /tmp/ccb2vt7W.s:9109   .debug_str:0000000000001065 .LASF165
     /tmp/ccb2vt7W.s:8475   .debug_str:0000000000000065 .LASF166
     /tmp/ccb2vt7W.s:8521   .debug_str:0000000000000160 .LASF167
     /tmp/ccb2vt7W.s:8721   .debug_str:0000000000000695 .LASF168
     /tmp/ccb2vt7W.s:8587   .debug_str:00000000000002ef .LASF169
     /tmp/ccb2vt7W.s:8629   .debug_str:00000000000003fd .LASF170
     /tmp/ccb2vt7W.s:8949   .debug_str:0000000000000c8e .LASF171
     /tmp/ccb2vt7W.s:8945   .debug_str:0000000000000c69 .LASF172
     /tmp/ccb2vt7W.s:9081   .debug_str:0000000000000fc6 .LASF173
     /tmp/ccb2vt7W.s:8899   .debug_str:0000000000000b3a .LASF174
     /tmp/ccb2vt7W.s:8511   .debug_str:0000000000000119 .LASF175
     /tmp/ccb2vt7W.s:8901   .debug_str:0000000000000b4e .LASF176
     /tmp/ccb2vt7W.s:8657   .debug_str:00000000000004b7 .LASF177
     /tmp/ccb2vt7W.s:8479   .debug_str:000000000000007c .LASF178
     /tmp/ccb2vt7W.s:8951   .debug_str:0000000000000ca2 .LASF179
     /tmp/ccb2vt7W.s:8485   .debug_str:00000000000000ae .LASF180
     /tmp/ccb2vt7W.s:8635   .debug_str:000000000000042a .LASF181
     /tmp/ccb2vt7W.s:8483   .debug_str:000000000000009a .LASF182
     /tmp/ccb2vt7W.s:8603   .debug_str:0000000000000347 .LASF183
     /tmp/ccb2vt7W.s:9011   .debug_str:0000000000000e27 .LASF184
     /tmp/ccb2vt7W.s:8531   .debug_str:000000000000019a .LASF185
     /tmp/ccb2vt7W.s:8515   .debug_str:0000000000000139 .LASF186
     /tmp/ccb2vt7W.s:9127   .debug_str:00000000000010d7 .LASF187
     /tmp/ccb2vt7W.s:8871   .debug_str:0000000000000a9b .LASF188
     /tmp/ccb2vt7W.s:9125   .debug_str:00000000000010c3 .LASF189
     /tmp/ccb2vt7W.s:8707   .debug_str:000000000000060c .LASF190
     /tmp/ccb2vt7W.s:8905   .debug_str:0000000000000b71 .LASF191
     /tmp/ccb2vt7W.s:8705   .debug_str:0000000000000601 .LASF192
     /tmp/ccb2vt7W.s:8715   .debug_str:0000000000000669 .LASF193
     /tmp/ccb2vt7W.s:8513   .debug_str:000000000000012d .LASF194
     /tmp/ccb2vt7W.s:8867   .debug_str:0000000000000a84 .LASF195
     /tmp/ccb2vt7W.s:8665   .debug_str:00000000000004e8 .LASF196
     /tmp/ccb2vt7W.s:8699   .debug_str:00000000000005d0 .LASF197
     /tmp/ccb2vt7W.s:9073   .debug_str:0000000000000f8e .LASF198
     /tmp/ccb2vt7W.s:8453   .debug_str:0000000000000015 .LASF199
     /tmp/ccb2vt7W.s:8861   .debug_str:0000000000000a51 .LASF200
     /tmp/ccb2vt7W.s:9059   .debug_str:0000000000000f42 .LASF201
     /tmp/ccb2vt7W.s:8649   .debug_str:0000000000000485 .LASF202
     /tmp/ccb2vt7W.s:8693   .debug_str:00000000000005aa .LASF203
     /tmp/ccb2vt7W.s:8855   .debug_str:0000000000000a20 .LASF204
     /tmp/ccb2vt7W.s:9045   .debug_str:0000000000000ee9 .LASF205
     /tmp/ccb2vt7W.s:9041   .debug_str:0000000000000ecf .LASF206
     /tmp/ccb2vt7W.s:8597   .debug_str:0000000000000322 .LASF207
     /tmp/ccb2vt7W.s:8641   .debug_str:0000000000000452 .LASF208
     /tmp/ccb2vt7W.s:8549   .debug_str:0000000000000208 .LASF209
     /tmp/ccb2vt7W.s:9103   .debug_str:0000000000001043 .LASF210
     /tmp/ccb2vt7W.s:9097   .debug_str:0000000000001027 .LASF211
     /tmp/ccb2vt7W.s:9083   .debug_str:0000000000000fdb .LASF212
     /tmp/ccb2vt7W.s:9069   .debug_str:0000000000000f79 .LASF213
     /tmp/ccb2vt7W.s:9043   .debug_str:0000000000000edc .LASF214
     /tmp/ccb2vt7W.s:8551   .debug_str:0000000000000215 .LASF215
     /tmp/ccb2vt7W.s:8879   .debug_str:0000000000000ad1 .LASF216
     /tmp/ccb2vt7W.s:8953   .debug_str:0000000000000cb6 .LASF217
     /tmp/ccb2vt7W.s:8813   .debug_str:0000000000000914 .LASF218
     /tmp/ccb2vt7W.s:9087   .debug_str:0000000000000ffb .LASF219
     /tmp/ccb2vt7W.s:8925   .debug_str:0000000000000bce .LASF220
     /tmp/ccb2vt7W.s:8713   .debug_str:0000000000000656 .LASF221
     /tmp/ccb2vt7W.s:8935   .debug_str:0000000000000c1e .LASF222
     /tmp/ccb2vt7W.s:8787   .debug_str:000000000000086e .LASF223
     /tmp/ccb2vt7W.s:8491   .debug_str:00000000000000cf .LASF224
     /tmp/ccb2vt7W.s:8775   .debug_str:0000000000000825 .LASF225
     /tmp/ccb2vt7W.s:9037   .debug_str:0000000000000ebc .LASF226
     /tmp/ccb2vt7W.s:8803   .debug_str:00000000000008d6 .LASF227
     /tmp/ccb2vt7W.s:8993   .debug_str:0000000000000da8 .LASF228
     /tmp/ccb2vt7W.s:8559   .debug_str:0000000000000233 .LASF229
     /tmp/ccb2vt7W.s:8915   .debug_str:0000000000000b9c .LASF230
     /tmp/ccb2vt7W.s:8579   .debug_str:00000000000002ba .LASF231
     /tmp/ccb2vt7W.s:8979   .debug_str:0000000000000d50 .LASF232
     /tmp/ccb2vt7W.s:8903   .debug_str:0000000000000b62 .LASF233
     /tmp/ccb2vt7W.s:8523   .debug_str:0000000000000172 .LASF234
     /tmp/ccb2vt7W.s:8541   .debug_str:00000000000001df .LASF235
     /tmp/ccb2vt7W.s:8791   .debug_str:0000000000000880 .LASF236
     /tmp/ccb2vt7W.s:8735   .debug_str:00000000000006fb .LASF237
     /tmp/ccb2vt7W.s:8737   .debug_str:000000000000070a .LASF238
     /tmp/ccb2vt7W.s:9091   .debug_str:000000000000100b .LASF239
     /tmp/ccb2vt7W.s:8655   .debug_str:00000000000004b2 .LASF240
     /tmp/ccb2vt7W.s:8865   .debug_str:0000000000000a6f .LASF241
     /tmp/ccb2vt7W.s:8633   .debug_str:000000000000041d .LASF242
     /tmp/ccb2vt7W.s:9047   .debug_str:0000000000000ef6 .LASF243
     /tmp/ccb2vt7W.s:8919   .debug_str:0000000000000baf .LASF244
     /tmp/ccb2vt7W.s:8627   .debug_str:00000000000003f2 .LASF245
     /tmp/ccb2vt7W.s:8725   .debug_str:00000000000006b3 .LASF246
     /tmp/ccb2vt7W.s:8595   .debug_str:000000000000031c .LASF247
     /tmp/ccb2vt7W.s:8887   .debug_str:0000000000000b06 .LASF248
     /tmp/ccb2vt7W.s:8889   .debug_str:0000000000000b0d .LASF249
     /tmp/ccb2vt7W.s:9101   .debug_str:000000000000103c .LASF250
     /tmp/ccb2vt7W.s:8923   .debug_str:0000000000000bc6 .LASF251
     /tmp/ccb2vt7W.s:8567   .debug_str:000000000000026a .LASF252
     /tmp/ccb2vt7W.s:8681   .debug_str:000000000000055b .LASF253
     /tmp/ccb2vt7W.s:8769   .debug_str:000000000000080e .LASF254
     /tmp/ccb2vt7W.s:9099   .debug_str:0000000000001033 .LASF255
     /tmp/ccb2vt7W.s:8563   .debug_str:000000000000024f .LASF256
     /tmp/ccb2vt7W.s:8765   .debug_str:00000000000007f5 .LASF257
     /tmp/ccb2vt7W.s:8869   .debug_str:0000000000000a91 .LASF258
     /tmp/ccb2vt7W.s:8843   .debug_str:00000000000009da .LASF259
     /tmp/ccb2vt7W.s:8845   .debug_str:00000000000009e4 .LASF260
     /tmp/ccb2vt7W.s:8937   .debug_str:0000000000000c2e .LASF261
     /tmp/ccb2vt7W.s:8599   .debug_str:000000000000032f .LASF262
     /tmp/ccb2vt7W.s:8959   .debug_str:0000000000000cdc .LASF263
     /tmp/ccb2vt7W.s:8729   .debug_str:00000000000006cf .LASF264
     /tmp/ccb2vt7W.s:9021   .debug_str:0000000000000e60 .LASF265
     /tmp/ccb2vt7W.s:8939   .debug_str:0000000000000c33 .LASF266
     /tmp/ccb2vt7W.s:8605   .debug_str:000000000000035b .LASF267
     /tmp/ccb2vt7W.s:8805   .debug_str:00000000000008e2 .LASF268
     /tmp/ccb2vt7W.s:8481   .debug_str:0000000000000090 .LASF269
     /tmp/ccb2vt7W.s:8833   .debug_str:000000000000099b .LASF270
     /tmp/ccb2vt7W.s:8781   .debug_str:0000000000000846 .LASF271
     /tmp/ccb2vt7W.s:8581   .debug_str:00000000000002c7 .LASF272
     /tmp/ccb2vt7W.s:8623   .debug_str:00000000000003d7 .LASF273
     /tmp/ccb2vt7W.s:8673   .debug_str:0000000000000523 .LASF274
     /tmp/ccb2vt7W.s:8863   .debug_str:0000000000000a60 .LASF275
     /tmp/ccb2vt7W.s:9129   .debug_str:00000000000010eb .LASF276
     /tmp/ccb2vt7W.s:8569   .debug_str:0000000000000271 .LASF277
     /tmp/ccb2vt7W.s:8977   .debug_str:0000000000000d3f .LASF280
     /tmp/ccb2vt7W.s:8773   .debug_str:000000000000081e .LASF278
     /tmp/ccb2vt7W.s:8593   .debug_str:0000000000000316 .LASF279
     /tmp/ccb2vt7W.s:8691   .debug_str:00000000000005a5 .LASF290
     /tmp/ccb2vt7W.s:8731   .debug_str:00000000000006d8 .LASF283
     /tmp/ccb2vt7W.s:8929   .debug_str:0000000000000bf2 .LASF281
     /tmp/ccb2vt7W.s:8651   .debug_str:0000000000000497 .LASF282
     /tmp/ccb2vt7W.s:8591   .debug_str:000000000000030d .LASF284
     /tmp/ccb2vt7W.s:8517   .debug_str:000000000000014d .LASF285
     /tmp/ccb2vt7W.s:9001   .debug_str:0000000000000de8 .LASF286
     /tmp/ccb2vt7W.s:8767   .debug_str:00000000000007fe .LASF287
     /tmp/ccb2vt7W.s:9039   .debug_str:0000000000000eca .LASF288
     /tmp/ccb2vt7W.s:9003   .debug_str:0000000000000df4 .LASF289
     /tmp/ccb2vt7W.s:8965   .debug_str:0000000000000cf5 .LASF295
     /tmp/ccb2vt7W.s:8875   .debug_str:0000000000000abe .LASF291
     /tmp/ccb2vt7W.s:8893   .debug_str:0000000000000b1a .LASF292
     /tmp/ccb2vt7W.s:8757   .debug_str:00000000000007bd .LASF293
     /tmp/ccb2vt7W.s:8789   .debug_str:000000000000087b .LASF294
     /tmp/ccb2vt7W.s:8943   .debug_str:0000000000000c55 .LASF296
     /tmp/ccb2vt7W.s:9017   .debug_str:0000000000000e50 .LASF297
     /tmp/ccb2vt7W.s:8537   .debug_str:00000000000001c4 .LASF298
     /tmp/ccb2vt7W.s:8963   .debug_str:0000000000000ced .LASF299
     /tmp/ccb2vt7W.s:9023   .debug_str:0000000000000e6a .LASF300
     /tmp/ccb2vt7W.s:9007   .debug_str:0000000000000e0b .LASF301
     /tmp/ccb2vt7W.s:9009   .debug_str:0000000000000e19 .LASF302
     /tmp/ccb2vt7W.s:8687   .debug_str:0000000000000586 .LASF303
     /tmp/ccb2vt7W.s:9015   .debug_str:0000000000000e4b .LASF304
     /tmp/ccb2vt7W.s:8639   .debug_str:000000000000044c .LASF305
     /tmp/ccb2vt7W.s:9093   .debug_str:0000000000001013 .LASF306
     /tmp/ccb2vt7W.s:8763   .debug_str:00000000000007e8 .LASF307
     /tmp/ccb2vt7W.s:8701   .debug_str:00000000000005e1 .LASF308
     /tmp/ccb2vt7W.s:8877   .debug_str:0000000000000acc .LASF309
     /tmp/ccb2vt7W.s:8519   .debug_str:000000000000015b .LASF310
     /tmp/ccb2vt7W.s:8689   .debug_str:0000000000000596 .LASF311
     /tmp/ccb2vt7W.s:8577   .debug_str:00000000000002ad .LASF312
     /tmp/ccb2vt7W.s:8817   .debug_str:0000000000000927 .LASF313
     /tmp/ccb2vt7W.s:8771   .debug_str:0000000000000817 .LASF314
     /tmp/ccb2vt7W.s:9031   .debug_str:0000000000000e9c .LASF315
     /tmp/ccb2vt7W.s:8853   .debug_str:0000000000000a17 .LASF316
     /tmp/ccb2vt7W.s:8815   .debug_str:0000000000000920 .LASF317
     /tmp/ccb2vt7W.s:8697   .debug_str:00000000000005c2 .LASF318
     /tmp/ccb2vt7W.s:8477   .debug_str:0000000000000077 .LASF319
     /tmp/ccb2vt7W.s:8983   .debug_str:0000000000000d69 .LASF340
     /tmp/ccb2vt7W.s:9077   .debug_str:0000000000000fb0 .LASF320
     /tmp/ccb2vt7W.s:9065   .debug_str:0000000000000f66 .LASF321
     /tmp/ccb2vt7W.s:9113   .debug_str:0000000000001083 .LASF322
     /tmp/ccb2vt7W.s:8997   .debug_str:0000000000000dc5 .LASF323
     /tmp/ccb2vt7W.s:9051   .debug_str:0000000000000f14 .LASF324
     /tmp/ccb2vt7W.s:9115   .debug_str:0000000000001092 .LASF325
     /tmp/ccb2vt7W.s:9061   .debug_str:0000000000000f54 .LASF326
     /tmp/ccb2vt7W.s:8825   .debug_str:0000000000000962 .LASF327
     /tmp/ccb2vt7W.s:8777   .debug_str:0000000000000833 .LASF328
     /tmp/ccb2vt7W.s:8585   .debug_str:00000000000002e1 .LASF329
     /tmp/ccb2vt7W.s:8957   .debug_str:0000000000000cce .LASF330
     /tmp/ccb2vt7W.s:8873   .debug_str:0000000000000aaf .LASF331
     /tmp/ccb2vt7W.s:9067   .debug_str:0000000000000f6c .LASF332
     /tmp/ccb2vt7W.s:8987   .debug_str:0000000000000d80 .LASF333
     /tmp/ccb2vt7W.s:8969   .debug_str:0000000000000d13 .LASF334
     /tmp/ccb2vt7W.s:8785   .debug_str:000000000000085f .LASF335

UNDEFINED SYMBOLS
printAt
Itoa
print
_isr_00_wrapper
_isr_01_wrapper
_isr_02_wrapper
_isr_03_wrapper
_isr_04_wrapper
_isr_05_wrapper
_isr_06_wrapper
_isr_07_wrapper
_isr_08_wrapper
_isr_09_wrapper
_isr_0A_wrapper
_isr_0B_wrapper
_isr_0C_wrapper
_isr_0D_wrapper
_isr_0F_wrapper
_isr_10_wrapper
_isr_11_wrapper
_isr_12_wrapper
_isr_13_wrapper
_isr_14_wrapper
_isr_15_wrapper
_isr_16_wrapper
_isr_17_wrapper
_isr_18_wrapper
_isr_19_wrapper
_isr_1A_wrapper
_isr_1B_wrapper
_isr_1C_wrapper
_isr_1D_wrapper
_isr_1E_wrapper
_isr_1F_wrapper
_isr_20_wrapper
_isr_21_wrapper
HandleRealModeSWInterrupt
HandleInterrutpReturn
HandleCR0Read
HandleCR3Read
HandleCR0Write
HandleCR3Write
HandleGuestIO
HandleGuestCPUID
clrscr
cpu_write_msr
GetMemB
inb
CopyMemory
setup_GDT32_entry_gcc
println
memset
sprintf
   1              		.file	"pmode.c"
   2              		.intel_syntax noprefix
   3              		.text
   4              	.Ltext0:
   5              		.comm	_exception_number,2,2
   6              		.comm	_exc_CS,2,2
   7              		.comm	_exc_IP,2,2
   8              		.comm	vhost,68,32
   9              		.comm	guest,28,4
  10              		.comm	GuestRegisters,56,32
  11              		.globl	setup_GDT32_entry_gcc
  13              	setup_GDT32_entry_gcc:
  14              	.LFB0:
  15              		.file 1 "pmode.c"
   1:pmode.c       **** #include "pmode.h"
   2:pmode.c       **** #include "BMVisor.h"
   3:pmode.c       **** #include "types.h"
   4:pmode.c       **** void setup_GDT32_entry_gcc (DESCR_SEG* item, DWORD base, DWORD limit, BYTE access, BYTE attribs)
   5:pmode.c       **** {
  16              		.loc 1 5 0
  17              		.cfi_startproc
  18 0000 55       		push	ebp
  19              		.cfi_def_cfa_offset 8
  20              		.cfi_offset 5, -8
  21 0001 89E5     		mov	ebp, esp
  22              		.cfi_def_cfa_register 5
  23 0003 83EC08   		sub	esp, 8
  24 0006 8B5514   		mov	edx, DWORD PTR [ebp+20]
  25 0009 8B4518   		mov	eax, DWORD PTR [ebp+24]
  26 000c 8855FC   		mov	BYTE PTR [ebp-4], dl
  27 000f 8845F8   		mov	BYTE PTR [ebp-8], al
   6:pmode.c       **** OPEN_UP_DS
  28              		.loc 1 6 0
  29              	#APP
  30              	# 6 "pmode.c" 1
   7 0013 B8100000 	  item->base_l = (WORD)(base & 0xFFFF);
   7      00
   8 0018 50       	  item->base_m = (BYTE)((base >> 16) & 0xFF);
   9 0019 1F       	  item->base_h = (BYTE)(base >> 24);
  10 001a 58       	  item->limit = (WORD)limit & 0xFFFF;
  11              	  item->attribs = (attribs << 4) | (BYTE)((limit >> 16) & 0x0F);
  12              	  item->access = access;
   7:pmode.c       ****   item->base_m = (BYTE)((base >> 16) & 0xFF);
  31              		push eax
  32              	 mov eax, 0x10
  33              	 push eax
  34              	 pop ds
  35              	 pop eax
  36              	
  37              	# 0 "" 2
  38              		.loc 1 7 0
  39              	#NO_APP
  40 001b 8B450C   		mov	eax, DWORD PTR [ebp+12]
  41 001e 89C2     		mov	edx, eax
  42 0020 8B4508   		mov	eax, DWORD PTR [ebp+8]
  43 0023 66895002 		mov	WORD PTR [eax+2], dx
   8:pmode.c       ****   item->base_h = (BYTE)(base >> 24);
  44              		.loc 1 8 0
  45 0027 8B450C   		mov	eax, DWORD PTR [ebp+12]
  46 002a C1E810   		shr	eax, 16
  47 002d 89C2     		mov	edx, eax
  48 002f 8B4508   		mov	eax, DWORD PTR [ebp+8]
  49 0032 885004   		mov	BYTE PTR [eax+4], dl
   9:pmode.c       ****   item->limit = (WORD)limit & 0xFFFF;
  50              		.loc 1 9 0
  51 0035 8B450C   		mov	eax, DWORD PTR [ebp+12]
  52 0038 C1E818   		shr	eax, 24
  53 003b 89C2     		mov	edx, eax
  54 003d 8B4508   		mov	eax, DWORD PTR [ebp+8]
  55 0040 885007   		mov	BYTE PTR [eax+7], dl
  10:pmode.c       ****   item->attribs = (attribs << 4) | (BYTE)((limit >> 16) & 0x0F);
  56              		.loc 1 10 0
  57 0043 8B4510   		mov	eax, DWORD PTR [ebp+16]
  58 0046 89C2     		mov	edx, eax
  59 0048 8B4508   		mov	eax, DWORD PTR [ebp+8]
  60 004b 668910   		mov	WORD PTR [eax], dx
  11:pmode.c       ****   item->access = access;
  61              		.loc 1 11 0
  62 004e 0FB645F8 		movzx	eax, BYTE PTR [ebp-8]
  63 0052 C1E004   		sal	eax, 4
  64 0055 89C2     		mov	edx, eax
  65 0057 8B4510   		mov	eax, DWORD PTR [ebp+16]
  66 005a C1E810   		shr	eax, 16
  67 005d 83E00F   		and	eax, 15
  68 0060 09D0     		or	eax, edx
  69 0062 89C2     		mov	edx, eax
  70 0064 8B4508   		mov	eax, DWORD PTR [ebp+8]
  71 0067 885006   		mov	BYTE PTR [eax+6], dl
  72              		.loc 1 12 0
  73 006a 8B4508   		mov	eax, DWORD PTR [ebp+8]
  74 006d 0FB655FC 		movzx	edx, BYTE PTR [ebp-4]
  75 0071 885005   		mov	BYTE PTR [eax+5], dl
  13:pmode.c       **** RESTORE_DS
  76              		.loc 1 13 0
  77 0074 B8380000 		mov	eax, 56
  77      00
  78              	#APP
  79              	# 13 "pmode.c" 1
  14 007a 89C0     	}
  15 007c 50       	
  16 007d 1F       	...
  14:pmode.c       **** }
  80              		push eax
  81              	 mov eax, eax
  82              	 push eax
  83              	 pop ds
  84              	 pop eax
  85              	
  86              	# 0 "" 2
  87              		.loc 1 14 0
  88              	#NO_APP
  89 007f 90       		nop
  90 0080 C9       		leave
  91              		.cfi_restore 5
  92              		.cfi_def_cfa 4, 4
  93 0081 C3       		ret
  94              		.cfi_endproc
  95              	.LFE0:
  97              	.Letext0:
  98              		.file 2 "types.h"
  99              		.file 3 "xen_types.h"
 100              		.file 4 "pmode.h"
 101              		.file 5 "x86_architecture.h"
 102              		.file 6 "vmcb.h"
 103              		.file 7 "host.h"
 104              		.file 8 "guest.h"
 105              		.file 9 "isr_wrapper.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 pmode.c
     /tmp/ccb2vt7W.s:4      .text:0000000000000000 .Ltext0
                            *COM*:0000000000000002 _exception_number
                            *COM*:0000000000000002 _exc_CS
                            *COM*:0000000000000002 _exc_IP
                            *COM*:0000000000000044 vhost
                            *COM*:000000000000001c guest
                            *COM*:0000000000000038 GuestRegisters
     /tmp/ccb2vt7W.s:13     .text:0000000000000000 setup_GDT32_entry_gcc
     /tmp/ccb2vt7W.s:14     .text:0000000000000000 .LFB0
     /tmp/ccb2vt7W.s:95     .text:0000000000000082 .LFE0
     /tmp/ccb2vt7W.s:97     .text:0000000000000082 .Letext0
     /tmp/ccb2vt7W.s:107    .debug_info:0000000000000000 .Ldebug_info0
     /tmp/ccb2vt7W.s:1462   .debug_abbrev:0000000000000000 .Ldebug_abbrev0
     /tmp/ccb2vt7W.s:2038   .debug_str:00000000000003a2 .LASF143
     /tmp/ccb2vt7W.s:1866   .debug_str:0000000000000092 .LASF144
     /tmp/ccb2vt7W.s:1952   .debug_str:00000000000001e6 .LASF145
     /tmp/ccb2vt7W.s:1838   .debug_line:0000000000000000 .Ldebug_line0
     /tmp/ccb2vt7W.s:2004   .debug_str:00000000000002f9 .LASF0
     /tmp/ccb2vt7W.s:2098   .debug_str:0000000000000530 .LASF2
     /tmp/ccb2vt7W.s:2010   .debug_str:000000000000030e .LASF1
     /tmp/ccb2vt7W.s:2120   .debug_str:000000000000059f .LASF3
     /tmp/ccb2vt7W.s:1914   .debug_str:0000000000000153 .LASF4
     /tmp/ccb2vt7W.s:2088   .debug_str:00000000000004ea .LASF5
     /tmp/ccb2vt7W.s:1918   .debug_str:0000000000000163 .LASF6
     /tmp/ccb2vt7W.s:2118   .debug_str:0000000000000593 .LASF7
     /tmp/ccb2vt7W.s:2046   .debug_str:0000000000000414 .LASF8
     /tmp/ccb2vt7W.s:1954   .debug_str:000000000000020a .LASF9
     /tmp/ccb2vt7W.s:1990   .debug_str:00000000000002a2 .LASF10
     /tmp/ccb2vt7W.s:1850   .debug_str:0000000000000030 .LASF11
     /tmp/ccb2vt7W.s:1996   .debug_str:00000000000002c3 .LASF12
     /tmp/ccb2vt7W.s:2042   .debug_str:0000000000000404 .LASF13
     /tmp/ccb2vt7W.s:2028   .debug_str:0000000000000368 .LASF14
     /tmp/ccb2vt7W.s:1886   .debug_str:00000000000000ec .LASF15
     /tmp/ccb2vt7W.s:2066   .debug_str:0000000000000477 .LASF16
     /tmp/ccb2vt7W.s:1986   .debug_str:0000000000000296 .LASF17
     /tmp/ccb2vt7W.s:1868   .debug_str:000000000000009a .LASF18
     /tmp/ccb2vt7W.s:2072   .debug_str:0000000000000494 .LASF19
     /tmp/ccb2vt7W.s:2074   .debug_str:000000000000049b .LASF20
     /tmp/ccb2vt7W.s:2022   .debug_str:000000000000034a .LASF21
     /tmp/ccb2vt7W.s:1972   .debug_str:0000000000000250 .LASF22
     /tmp/ccb2vt7W.s:2068   .debug_str:0000000000000480 .LASF23
     /tmp/ccb2vt7W.s:1900   .debug_str:0000000000000119 .LASF24
     /tmp/ccb2vt7W.s:2086   .debug_str:00000000000004e1 .LASF25
     /tmp/ccb2vt7W.s:2096   .debug_str:000000000000052b .LASF26
     /tmp/ccb2vt7W.s:1870   .debug_str:00000000000000a0 .LASF27
     /tmp/ccb2vt7W.s:2050   .debug_str:0000000000000429 .LASF28
     /tmp/ccb2vt7W.s:1968   .debug_str:0000000000000245 .LASF29
     /tmp/ccb2vt7W.s:1988   .debug_str:000000000000029b .LASF30
     /tmp/ccb2vt7W.s:2002   .debug_str:00000000000002e4 .LASF31
     /tmp/ccb2vt7W.s:1978   .debug_str:0000000000000272 .LASF48
     /tmp/ccb2vt7W.s:1932   .debug_str:000000000000019e .LASF32
     /tmp/ccb2vt7W.s:1908   .debug_str:000000000000013b .LASF33
     /tmp/ccb2vt7W.s:1920   .debug_str:000000000000017a .LASF34
     /tmp/ccb2vt7W.s:1848   .debug_str:0000000000000029 .LASF35
     /tmp/ccb2vt7W.s:1916   .debug_str:0000000000000159 .LASF36
     /tmp/ccb2vt7W.s:2008   .debug_str:0000000000000303 .LASF37
     /tmp/ccb2vt7W.s:2104   .debug_str:0000000000000560 .LASF38
     /tmp/ccb2vt7W.s:1980   .debug_str:000000000000027e .LASF39
     /tmp/ccb2vt7W.s:1948   .debug_str:00000000000001d4 .LASF40
     /tmp/ccb2vt7W.s:2106   .debug_str:0000000000000566 .LASF41
     /tmp/ccb2vt7W.s:2070   .debug_str:0000000000000487 .LASF42
     /tmp/ccb2vt7W.s:2108   .debug_str:000000000000056c .LASF43
     /tmp/ccb2vt7W.s:2110   .debug_str:0000000000000572 .LASF44
     /tmp/ccb2vt7W.s:1844   .debug_str:000000000000001c .LASF45
     /tmp/ccb2vt7W.s:1942   .debug_str:00000000000001c1 .LASF46
     /tmp/ccb2vt7W.s:2044   .debug_str:000000000000040a .LASF47
     /tmp/ccb2vt7W.s:1878   .debug_str:00000000000000c8 .LASF49
     /tmp/ccb2vt7W.s:2054   .debug_str:000000000000043b .LASF50
     /tmp/ccb2vt7W.s:1862   .debug_str:0000000000000078 .LASF51
     /tmp/ccb2vt7W.s:1974   .debug_str:0000000000000258 .LASF52
     /tmp/ccb2vt7W.s:2014   .debug_str:000000000000031f .LASF53
     /tmp/ccb2vt7W.s:1842   .debug_str:0000000000000008 .LASF54
     /tmp/ccb2vt7W.s:1882   .debug_str:00000000000000e0 .LASF55
     /tmp/ccb2vt7W.s:1884   .debug_str:00000000000000e6 .LASF56
     /tmp/ccb2vt7W.s:1896   .debug_str:000000000000010d .LASF57
     /tmp/ccb2vt7W.s:1888   .debug_str:00000000000000f5 .LASF58
     /tmp/ccb2vt7W.s:1890   .debug_str:00000000000000fb .LASF59
     /tmp/ccb2vt7W.s:1892   .debug_str:0000000000000101 .LASF60
     /tmp/ccb2vt7W.s:2076   .debug_str:00000000000004a2 .LASF61
     /tmp/ccb2vt7W.s:2094   .debug_str:000000000000051d .LASF62
     /tmp/ccb2vt7W.s:1854   .debug_str:000000000000004a .LASF63
     /tmp/ccb2vt7W.s:2036   .debug_str:0000000000000397 .LASF64
     /tmp/ccb2vt7W.s:2012   .debug_str:0000000000000313 .LASF65
     /tmp/ccb2vt7W.s:1894   .debug_str:0000000000000107 .LASF66
     /tmp/ccb2vt7W.s:2040   .debug_str:00000000000003fe .LASF67
     /tmp/ccb2vt7W.s:1856   .debug_str:0000000000000055 .LASF68
     /tmp/ccb2vt7W.s:2132   .debug_str:00000000000005e6 .LASF69
     /tmp/ccb2vt7W.s:2130   .debug_str:00000000000005dc .LASF70
     /tmp/ccb2vt7W.s:1964   .debug_str:0000000000000230 .LASF71
     /tmp/ccb2vt7W.s:2078   .debug_str:00000000000004af .LASF72
     /tmp/ccb2vt7W.s:1860   .debug_str:000000000000006e .LASF73
     /tmp/ccb2vt7W.s:1902   .debug_str:0000000000000123 .LASF74
     /tmp/ccb2vt7W.s:2018   .debug_str:000000000000033a .LASF75
     /tmp/ccb2vt7W.s:2048   .debug_str:000000000000041e .LASF76
     /tmp/ccb2vt7W.s:1864   .debug_str:0000000000000086 .LASF77
     /tmp/ccb2vt7W.s:2116   .debug_str:0000000000000588 .LASF78
     /tmp/ccb2vt7W.s:1898   .debug_str:0000000000000113 .LASF79
     /tmp/ccb2vt7W.s:1910   .debug_str:0000000000000140 .LASF80
     /tmp/ccb2vt7W.s:1946   .debug_str:00000000000001cd .LASF81
     /tmp/ccb2vt7W.s:1976   .debug_str:000000000000026d .LASF82
     /tmp/ccb2vt7W.s:1930   .debug_str:0000000000000199 .LASF83
     /tmp/ccb2vt7W.s:2006   .debug_str:00000000000002fe .LASF84
     /tmp/ccb2vt7W.s:1922   .debug_str:0000000000000181 .LASF85
     /tmp/ccb2vt7W.s:1924   .debug_str:0000000000000187 .LASF86
     /tmp/ccb2vt7W.s:1926   .debug_str:000000000000018d .LASF87
     /tmp/ccb2vt7W.s:1846   .debug_str:0000000000000024 .LASF88
     /tmp/ccb2vt7W.s:1928   .debug_str:0000000000000193 .LASF89
     /tmp/ccb2vt7W.s:2020   .debug_str:0000000000000343 .LASF90
     /tmp/ccb2vt7W.s:1958   .debug_str:000000000000021e .LASF91
     /tmp/ccb2vt7W.s:1960   .debug_str:0000000000000224 .LASF92
     /tmp/ccb2vt7W.s:1944   .debug_str:00000000000001c8 .LASF93
     /tmp/ccb2vt7W.s:1872   .debug_str:00000000000000a5 .LASF94
     /tmp/ccb2vt7W.s:1940   .debug_str:00000000000001bb .LASF95
     /tmp/ccb2vt7W.s:2016   .debug_str:0000000000000333 .LASF96
     /tmp/ccb2vt7W.s:1912   .debug_str:0000000000000148 .LASF97
     /tmp/ccb2vt7W.s:2034   .debug_str:000000000000038b .LASF98
     /tmp/ccb2vt7W.s:1982   .debug_str:0000000000000283 .LASF99
     /tmp/ccb2vt7W.s:1876   .debug_str:00000000000000bb .LASF100
     /tmp/ccb2vt7W.s:2056   .debug_str:0000000000000449 .LASF101
     /tmp/ccb2vt7W.s:2058   .debug_str:000000000000044f .LASF102
     /tmp/ccb2vt7W.s:2060   .debug_str:0000000000000455 .LASF103
     /tmp/ccb2vt7W.s:2062   .debug_str:000000000000045b .LASF104
     /tmp/ccb2vt7W.s:2080   .debug_str:00000000000004bb .LASF105
     /tmp/ccb2vt7W.s:1880   .debug_str:00000000000000d4 .LASF106
     /tmp/ccb2vt7W.s:2084   .debug_str:00000000000004d0 .LASF107
     /tmp/ccb2vt7W.s:2090   .debug_str:00000000000004fc .LASF108
     /tmp/ccb2vt7W.s:1956   .debug_str:0000000000000210 .LASF109
     /tmp/ccb2vt7W.s:1992   .debug_str:00000000000002a8 .LASF110
     /tmp/ccb2vt7W.s:1934   .debug_str:00000000000001a3 .LASF111
     /tmp/ccb2vt7W.s:2030   .debug_str:0000000000000371 .LASF112
     /tmp/ccb2vt7W.s:1904   .debug_str:0000000000000129 .LASF113
     /tmp/ccb2vt7W.s:2122   .debug_str:00000000000005b2 .LASF114
     /tmp/ccb2vt7W.s:1966   .debug_str:000000000000023a .LASF115
     /tmp/ccb2vt7W.s:2032   .debug_str:000000000000037c .LASF116
     /tmp/ccb2vt7W.s:2128   .debug_str:00000000000005d2 .LASF117
     /tmp/ccb2vt7W.s:1950   .debug_str:00000000000001dc .LASF118
     /tmp/ccb2vt7W.s:2052   .debug_str:000000000000042e .LASF119
     /tmp/ccb2vt7W.s:1906   .debug_str:0000000000000132 .LASF120
     /tmp/ccb2vt7W.s:2026   .debug_str:000000000000035e .LASF121
     /tmp/ccb2vt7W.s:2124   .debug_str:00000000000005bc .LASF122
     /tmp/ccb2vt7W.s:1874   .debug_str:00000000000000ab .LASF123
     /tmp/ccb2vt7W.s:2082   .debug_str:00000000000004c1 .LASF124
     /tmp/ccb2vt7W.s:1858   .debug_str:0000000000000066 .LASF125
     /tmp/ccb2vt7W.s:1998   .debug_str:00000000000002d1 .LASF126
     /tmp/ccb2vt7W.s:2126   .debug_str:00000000000005c6 .LASF127
     /tmp/ccb2vt7W.s:1970   .debug_str:000000000000024b .LASF128
     /tmp/ccb2vt7W.s:2100   .debug_str:000000000000053e .LASF129
     /tmp/ccb2vt7W.s:2024   .debug_str:0000000000000351 .LASF130
     /tmp/ccb2vt7W.s:2102   .debug_str:0000000000000553 .LASF131
     /tmp/ccb2vt7W.s:1852   .debug_str:000000000000003d .LASF132
     /tmp/ccb2vt7W.s:2112   .debug_str:0000000000000578 .LASF133
     /tmp/ccb2vt7W.s:1936   .debug_str:00000000000001a9 .LASF134
     /tmp/ccb2vt7W.s:1962   .debug_str:000000000000022a .LASF135
     /tmp/ccb2vt7W.s:2064   .debug_str:0000000000000461 .LASF146
     /tmp/ccb2vt7W.s:2114   .debug_str:0000000000000583 .LASF136
     /tmp/ccb2vt7W.s:2092   .debug_str:000000000000050b .LASF137
     /tmp/ccb2vt7W.s:1840   .debug_str:0000000000000000 .LASF138
     /tmp/ccb2vt7W.s:2000   .debug_str:00000000000002dc .LASF139
     /tmp/ccb2vt7W.s:1984   .debug_str:0000000000000290 .LASF140
     /tmp/ccb2vt7W.s:1938   .debug_str:00000000000001b5 .LASF141
     /tmp/ccb2vt7W.s:1994   .debug_str:00000000000002b4 .LASF142

NO UNDEFINED SYMBOLS
   1              		.file	"pmode_screen.c"
   2              		.intel_syntax noprefix
   3              		.text
   4              	.Ltext0:
   5              		.comm	_exception_number,2,2
   6              		.comm	_exc_CS,2,2
   7              		.comm	_exc_IP,2,2
   8              		.comm	vhost,68,32
   9              		.comm	guest,28,4
  10              		.comm	GuestRegisters,56,32
  11              		.globl	cursorLocation
  12              		.bss
  13              		.align 2
  16              	cursorLocation:
  17 0000 0000     		.zero	2
  18              		.globl	cursor_x
  19 0002 0000     		.align 4
  22              	cursor_x:
  23 0004 00000000 		.zero	4
  24              		.globl	cursor_y
  25              		.align 4
  28              	cursor_y:
  29 0008 00000000 		.zero	4
  30              		.text
  32              	move_cursor:
  33              	.LFB0:
  34              		.file 1 "pmode_screen.c"
   1:pmode_screen.c **** #include "xen_types.h"
   2:pmode_screen.c **** #include "utility.h"
   3:pmode_screen.c **** 
   4:pmode_screen.c **** #define switch_ds 	__asm__("mov eax,0X48\n push ds\n push eax\n pop ds\n");
   5:pmode_screen.c **** #define switch_ds_back __asm__("pop ds");
   6:pmode_screen.c **** 
   7:pmode_screen.c **** // Write a single character out to the screen.
   8:pmode_screen.c **** void monitor_put(char c);
   9:pmode_screen.c **** // Clear the screen to all black.
  10:pmode_screen.c **** void clrscr();
  11:pmode_screen.c **** // Output a null-terminated ASCII string to the monitor.
  12:pmode_screen.c **** 
  13:pmode_screen.c **** uint16_t cursorLocation=0;
  14:pmode_screen.c **** int cursor_x=0, cursor_y=0;
  15:pmode_screen.c **** 
  16:pmode_screen.c **** // Updates the hardware cursor.
  17:pmode_screen.c **** static void move_cursor()
  18:pmode_screen.c **** {
  35              		.loc 1 18 0
  36              		.cfi_startproc
  37 0000 55       		push	ebp
  38              		.cfi_def_cfa_offset 8
  39              		.cfi_offset 5, -8
  40 0001 89E5     		mov	ebp, esp
  41              		.cfi_def_cfa_register 5
  19:pmode_screen.c ****     return;
  42              		.loc 1 19 0
  43 0003 90       		nop
  20:pmode_screen.c ****    // Assume the screen is 80 characters wide...
  21:pmode_screen.c ****    cursorLocation = cursor_y * 160 + cursor_x;
  22:pmode_screen.c ****    outb(0x3D4, 14);                  // Tell the VGA board we are setting the high cursor byte.
  23:pmode_screen.c ****    outb(0x3D5, cursorLocation >> 8); // Send the high cursor byte.
  24:pmode_screen.c ****    outb(0x3D4, 15);                  // Tell the VGA board we are setting the low cursor byte.
  25:pmode_screen.c ****    outb(0x3D5, cursorLocation);      // Send the low cursor byte.
  26:pmode_screen.c **** } 
  44              		.loc 1 26 0
  45 0004 5D       		pop	ebp
  46              		.cfi_restore 5
  47              		.cfi_def_cfa 4, 4
  48 0005 C3       		ret
  49              		.cfi_endproc
  50              	.LFE0:
  53              	scroll:
  54              	.LFB1:
  27:pmode_screen.c **** 
  28:pmode_screen.c **** // Scrolls the text on the screen up by one line.
  29:pmode_screen.c **** static void scroll()
  30:pmode_screen.c **** {
  55              		.loc 1 30 0
  56              		.cfi_startproc
  57 0006 55       		push	ebp
  58              		.cfi_def_cfa_offset 8
  59              		.cfi_offset 5, -8
  60 0007 89E5     		mov	ebp, esp
  61              		.cfi_def_cfa_register 5
  62 0009 83EC10   		sub	esp, 16
  31:pmode_screen.c **** volatile char *video_memory = (volatile char*)0;
  63              		.loc 1 31 0
  64 000c C745F800 		mov	DWORD PTR [ebp-8], 0
  64      000000
  32:pmode_screen.c ****    // Get a space character with the default colour attributes.
  33:pmode_screen.c ****    uint8_t attributeByte = (0 /*black*/ << 4) | (15 /*white*/ & 0x0F);
  65              		.loc 1 33 0
  66 0013 C645F70F 		mov	BYTE PTR [ebp-9], 15
  34:pmode_screen.c ****    uint16_t blank = 0x20 /* space */ | (attributeByte << 8);
  67              		.loc 1 34 0
  68 0017 0FB645F7 		movzx	eax, BYTE PTR [ebp-9]
  69 001b C1E008   		sal	eax, 8
  70 001e 83C820   		or	eax, 32
  71 0021 668945F4 		mov	WORD PTR [ebp-12], ax
  35:pmode_screen.c **** 
  36:pmode_screen.c ****    // Row 25 is the end, this means we need to scroll up
  37:pmode_screen.c ****    if(cursor_y >= 25)
  72              		.loc 1 37 0
  73 0025 A1000000 		mov	eax, DWORD PTR cursor_y
  73      00
  74 002a 83F818   		cmp	eax, 24
  75 002d 7E65     		jle	.L9
  76              	.LBB2:
  38:pmode_screen.c ****    {
  39:pmode_screen.c ****        // Move the current text chunk that makes up the screen
  40:pmode_screen.c ****        // back in the buffer by a line
  41:pmode_screen.c ****        int i;
  42:pmode_screen.c **** switch_ds
  77              		.loc 1 42 0
  78              	#APP
  79              	# 42 "pmode_screen.c" 1
  43 0034 1E       	       for (i = 0*80; i < 24*80; i++)
  44 0035 50       	       {
  45 0036 1F       	           video_memory[i] = video_memory[i+80];
  46              	       }
  47              	       // The last line should now be blank. Do this by writing
  43:pmode_screen.c ****        {
  80              		mov eax,0X48
  81              	 push ds
  82              	 push eax
  83              	 pop ds
  84              	
  85              	# 0 "" 2
  86              		.loc 1 43 0
  87              	#NO_APP
  88 0037 C745FC00 		mov	DWORD PTR [ebp-4], 0
  88      000000
  89 003e EB1C     		jmp	.L5
  90              	.L6:
  45:pmode_screen.c ****        }
  91              		.loc 1 45 0 discriminator 3
  92 0040 8B55FC   		mov	edx, DWORD PTR [ebp-4]
  93 0043 8B45F8   		mov	eax, DWORD PTR [ebp-8]
  94 0046 01C2     		add	edx, eax
  95 0048 8B45FC   		mov	eax, DWORD PTR [ebp-4]
  96 004b 8D4850   		lea	ecx, [eax+80]
  97 004e 8B45F8   		mov	eax, DWORD PTR [ebp-8]
  98 0051 01C8     		add	eax, ecx
  99 0053 0FB600   		movzx	eax, BYTE PTR [eax]
 100 0056 8802     		mov	BYTE PTR [edx], al
  43:pmode_screen.c ****        {
 101              		.loc 1 43 0 discriminator 3
 102 0058 8345FC01 		add	DWORD PTR [ebp-4], 1
 103              	.L5:
  43:pmode_screen.c ****        {
 104              		.loc 1 43 0 is_stmt 0 discriminator 1
 105 005c 817DFC7F 		cmp	DWORD PTR [ebp-4], 1919
 105      070000
 106 0063 7EDB     		jle	.L6
  48:pmode_screen.c ****        // 80 spaces to it.
  49:pmode_screen.c ****        for (i = 24*80; i < 25*80; i++)
 107              		.loc 1 49 0 is_stmt 1
 108 0065 C745FC80 		mov	DWORD PTR [ebp-4], 1920
 108      070000
 109 006c EB12     		jmp	.L7
 110              	.L8:
  50:pmode_screen.c ****        {
  51:pmode_screen.c ****            video_memory[i] = blank;
 111              		.loc 1 51 0 discriminator 3
 112 006e 8B55FC   		mov	edx, DWORD PTR [ebp-4]
 113 0071 8B45F8   		mov	eax, DWORD PTR [ebp-8]
 114 0074 01D0     		add	eax, edx
 115 0076 0FB755F4 		movzx	edx, WORD PTR [ebp-12]
 116 007a 8810     		mov	BYTE PTR [eax], dl
  49:pmode_screen.c ****        {
 117              		.loc 1 49 0 discriminator 3
 118 007c 8345FC01 		add	DWORD PTR [ebp-4], 1
 119              	.L7:
  49:pmode_screen.c ****        {
 120              		.loc 1 49 0 is_stmt 0 discriminator 1
 121 0080 817DFCCF 		cmp	DWORD PTR [ebp-4], 1999
 121      070000
 122 0087 7EE5     		jle	.L8
  52:pmode_screen.c ****        }
  53:pmode_screen.c **** switch_ds_back
 123              		.loc 1 53 0 is_stmt 1
 124              	#APP
 125              	# 53 "pmode_screen.c" 1
  54              	       // The cursor should now be on the last line.
  55:pmode_screen.c ****        cursor_y = 24;
 126              		pop ds
 127              	# 0 "" 2
 128              		.loc 1 55 0
 129              	#NO_APP
 130 008a C7050000 		mov	DWORD PTR cursor_y, 24
 130      00001800 
 130      0000
 131              	.L9:
 132              	.LBE2:
  56:pmode_screen.c ****    }
  57:pmode_screen.c **** } 
 133              		.loc 1 57 0
 134 0094 90       		nop
 135 0095 C9       		leave
 136              		.cfi_restore 5
 137              		.cfi_def_cfa 4, 4
 138 0096 C3       		ret
 139              		.cfi_endproc
 140              	.LFE1:
 142              		.globl	monitor_put
 144              	monitor_put:
 145              	.LFB2:
  58:pmode_screen.c **** 
  59:pmode_screen.c **** // Writes a single character out to the screen.
  60:pmode_screen.c **** void monitor_put(char c)
  61:pmode_screen.c **** {
 146              		.loc 1 61 0
 147              		.cfi_startproc
 148 0097 55       		push	ebp
 149              		.cfi_def_cfa_offset 8
 150              		.cfi_offset 5, -8
 151 0098 89E5     		mov	ebp, esp
 152              		.cfi_def_cfa_register 5
 153 009a 83EC14   		sub	esp, 20
 154 009d 8B4508   		mov	eax, DWORD PTR [ebp+8]
 155 00a0 8845EC   		mov	BYTE PTR [ebp-20], al
  62:pmode_screen.c **** volatile char *video_memory = (volatile char*)0;
 156              		.loc 1 62 0
 157 00a3 C745FC00 		mov	DWORD PTR [ebp-4], 0
 157      000000
  63:pmode_screen.c ****    // The background colour is black (0), the foreground is white (15).
  64:pmode_screen.c **** //   uint8_t backColour = 0;
  65:pmode_screen.c **** //   uint8_t foreColour = 15;
  66:pmode_screen.c ****    // The attribute byte is made up of two nibbles - the lower being the
  67:pmode_screen.c ****    // foreground colour, and the upper the background colour.
  68:pmode_screen.c ****    uint8_t  attributeByte = 7; //(backColour << 4) | (foreColour & 0x0F);
 158              		.loc 1 68 0
 159 00aa C645FB07 		mov	BYTE PTR [ebp-5], 7
  69:pmode_screen.c ****    uint16_t location;
  70:pmode_screen.c ****    // Handle a backspace, by moving the cursor back one space (2 bytes because of attribute)
  71:pmode_screen.c ****    if (c == 0x08 && cursor_x)
 160              		.loc 1 71 0
 161 00ae 807DEC08 		cmp	BYTE PTR [ebp-20], 8
 162 00b2 751B     		jne	.L11
 163              		.loc 1 71 0 is_stmt 0 discriminator 1
 164 00b4 A1000000 		mov	eax, DWORD PTR cursor_x
 164      00
 165 00b9 85C0     		test	eax, eax
 166 00bb 7412     		je	.L11
  72:pmode_screen.c ****    {
  73:pmode_screen.c ****        cursor_x-=2;
 167              		.loc 1 73 0 is_stmt 1
 168 00bd A1000000 		mov	eax, DWORD PTR cursor_x
 168      00
 169 00c2 83E802   		sub	eax, 2
 170 00c5 A3000000 		mov	DWORD PTR cursor_x, eax
 170      00
 171 00ca E9B20000 		jmp	.L12
 171      00
 172              	.L11:
  74:pmode_screen.c ****    }
  75:pmode_screen.c ****    // Handle a tab by increasing the cursor's X, but only to a point
  76:pmode_screen.c ****    // where it is divisible by 8.
  77:pmode_screen.c ****    else if (c == 0x09)
 173              		.loc 1 77 0
 174 00cf 807DEC09 		cmp	BYTE PTR [ebp-20], 9
 175 00d3 7515     		jne	.L13
  78:pmode_screen.c ****    {
  79:pmode_screen.c ****        cursor_x = (cursor_x+8) & ~(8-1);
 176              		.loc 1 79 0
 177 00d5 A1000000 		mov	eax, DWORD PTR cursor_x
 177      00
 178 00da 83C008   		add	eax, 8
 179 00dd 83E0F8   		and	eax, -8
 180 00e0 A3000000 		mov	DWORD PTR cursor_x, eax
 180      00
 181 00e5 E9970000 		jmp	.L12
 181      00
 182              	.L13:
  80:pmode_screen.c ****    }
  81:pmode_screen.c **** 
  82:pmode_screen.c ****    // Handle carriage return
  83:pmode_screen.c ****    else if (c == '\r')
 183              		.loc 1 83 0
 184 00ea 807DEC0D 		cmp	BYTE PTR [ebp-20], 13
 185 00ee 750F     		jne	.L14
  84:pmode_screen.c ****    {
  85:pmode_screen.c ****        cursor_x = 0;
 186              		.loc 1 85 0
 187 00f0 C7050000 		mov	DWORD PTR cursor_x, 0
 187      00000000 
 187      0000
 188 00fa E9820000 		jmp	.L12
 188      00
 189              	.L14:
  86:pmode_screen.c ****    }
  87:pmode_screen.c **** 
  88:pmode_screen.c ****    // Handle newline by moving cursor back to left and increasing the row
  89:pmode_screen.c ****    else if (c == '\n')
 190              		.loc 1 89 0
 191 00ff 807DEC0A 		cmp	BYTE PTR [ebp-20], 10
 192 0103 7519     		jne	.L15
  90:pmode_screen.c ****    {
  91:pmode_screen.c ****        cursor_x = 0;
 193              		.loc 1 91 0
 194 0105 C7050000 		mov	DWORD PTR cursor_x, 0
 194      00000000 
 194      0000
  92:pmode_screen.c ****        cursor_y++;
 195              		.loc 1 92 0
 196 010f A1000000 		mov	eax, DWORD PTR cursor_y
 196      00
 197 0114 83C001   		add	eax, 1
 198 0117 A3000000 		mov	DWORD PTR cursor_y, eax
 198      00
 199 011c EB63     		jmp	.L12
 200              	.L15:
  93:pmode_screen.c ****    }
  94:pmode_screen.c ****    // Handle any other printable character.
  95:pmode_screen.c ****    else if(c >= ' ')
 201              		.loc 1 95 0
 202 011e 807DEC1F 		cmp	BYTE PTR [ebp-20], 31
 203 0122 7E5D     		jle	.L12
  96:pmode_screen.c ****    {
  97:pmode_screen.c ****        location = (cursor_y*160 + (cursor_x*2));
 204              		.loc 1 97 0
 205 0124 8B150000 		mov	edx, DWORD PTR cursor_y
 205      0000
 206 012a 89D0     		mov	eax, edx
 207 012c C1E002   		sal	eax, 2
 208 012f 01D0     		add	eax, edx
 209 0131 C1E004   		sal	eax, 4
 210 0134 89C2     		mov	edx, eax
 211 0136 A1000000 		mov	eax, DWORD PTR cursor_x
 211      00
 212 013b 01D0     		add	eax, edx
 213 013d 01C0     		add	eax, eax
 214 013f 668945F8 		mov	WORD PTR [ebp-8], ax
  98:pmode_screen.c **** switch_ds
 215              		.loc 1 98 0
 216              	#APP
 217              	# 98 "pmode_screen.c" 1
  99 0148 1E       			video_memory[location++] = c;
 100 0149 50       			video_memory[location] = attributeByte;
 101 014a 1F       	switch_ds_back
 102              	       cursor_x++;
 103              	   }
  99:pmode_screen.c **** 		video_memory[location] = attributeByte;
 218              		mov eax,0X48
 219              	 push ds
 220              	 push eax
 221              	 pop ds
 222              	
 223              	# 0 "" 2
 224              		.loc 1 99 0
 225              	#NO_APP
 226 014b 0FB745F8 		movzx	eax, WORD PTR [ebp-8]
 227 014f 8D5001   		lea	edx, [eax+1]
 228 0152 668955F8 		mov	WORD PTR [ebp-8], dx
 229 0156 0FB7D0   		movzx	edx, ax
 230 0159 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 231 015c 01C2     		add	edx, eax
 232 015e 0FB645EC 		movzx	eax, BYTE PTR [ebp-20]
 233 0162 8802     		mov	BYTE PTR [edx], al
 100:pmode_screen.c **** switch_ds_back
 234              		.loc 1 100 0
 235 0164 0FB755F8 		movzx	edx, WORD PTR [ebp-8]
 236 0168 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 237 016b 01C2     		add	edx, eax
 238 016d 0FB645FB 		movzx	eax, BYTE PTR [ebp-5]
 239 0171 8802     		mov	BYTE PTR [edx], al
 101:pmode_screen.c ****        cursor_x++;
 240              		.loc 1 101 0
 241              	#APP
 242              	# 101 "pmode_screen.c" 1
 102:pmode_screen.c ****    }
 243              		pop ds
 244              	# 0 "" 2
 245              		.loc 1 102 0
 246              	#NO_APP
 247 0174 A1000000 		mov	eax, DWORD PTR cursor_x
 247      00
 248 0179 83C001   		add	eax, 1
 249 017c A3000000 		mov	DWORD PTR cursor_x, eax
 249      00
 250              	.L12:
 104:pmode_screen.c **** 
 105:pmode_screen.c ****    // Check if we need to insert a new line because we have reached the end
 106:pmode_screen.c ****    // of the screen.
 107:pmode_screen.c ****    if (cursor_x >= 160)
 251              		.loc 1 107 0
 252 0181 A1000000 		mov	eax, DWORD PTR cursor_x
 252      00
 253 0186 3D9F0000 		cmp	eax, 159
 253      00
 254 018b 7E17     		jle	.L17
 108:pmode_screen.c ****    {
 109:pmode_screen.c ****        cursor_x = 0;
 255              		.loc 1 109 0
 256 018d C7050000 		mov	DWORD PTR cursor_x, 0
 256      00000000 
 256      0000
 110:pmode_screen.c ****        cursor_y ++;
 257              		.loc 1 110 0
 258 0197 A1000000 		mov	eax, DWORD PTR cursor_y
 258      00
 259 019c 83C001   		add	eax, 1
 260 019f A3000000 		mov	DWORD PTR cursor_y, eax
 260      00
 261              	.L17:
 111:pmode_screen.c ****    }
 112:pmode_screen.c **** 
 113:pmode_screen.c **** } 
 262              		.loc 1 113 0
 263 01a4 90       		nop
 264 01a5 C9       		leave
 265              		.cfi_restore 5
 266              		.cfi_def_cfa 4, 4
 267 01a6 C3       		ret
 268              		.cfi_endproc
 269              	.LFE2:
 271              		.globl	clrscr
 273              	clrscr:
 274              	.LFB3:
 114:pmode_screen.c **** 
 115:pmode_screen.c **** // Clears the screen, by copying lots of spaces to the framebuffer.
 116:pmode_screen.c **** void clrscr()
 117:pmode_screen.c **** {
 275              		.loc 1 117 0
 276              		.cfi_startproc
 277 01a7 55       		push	ebp
 278              		.cfi_def_cfa_offset 8
 279              		.cfi_offset 5, -8
 280 01a8 89E5     		mov	ebp, esp
 281              		.cfi_def_cfa_register 5
 282 01aa 83EC10   		sub	esp, 16
 118:pmode_screen.c ****    // Make an attribute byte for the default colours
 119:pmode_screen.c **** volatile char *video_memory = (volatile char*)0;
 283              		.loc 1 119 0
 284 01ad C745F800 		mov	DWORD PTR [ebp-8], 0
 284      000000
 120:pmode_screen.c ****    //uint8_t attributeByte = (0 /*black*/ << 4) | (15 /*white*/ & 0x0F);
 121:pmode_screen.c ****    char blank = 0x20;
 285              		.loc 1 121 0
 286 01b4 C645F720 		mov	BYTE PTR [ebp-9], 32
 122:pmode_screen.c ****    char attrib = 0x07;
 287              		.loc 1 122 0
 288 01b8 C645F607 		mov	BYTE PTR [ebp-10], 7
 123:pmode_screen.c **** 
 124:pmode_screen.c ****    int i;
 125:pmode_screen.c **** switch_ds
 289              		.loc 1 125 0
 290              	#APP
 291              	# 125 "pmode_screen.c" 1
 126 01c1 1E       	   for (i = 0; i < 160*25; i+=2)
 127 01c2 50       	   {
 128 01c3 1F       	       video_memory[i] = blank;
 129              		video_memory[i+1] = attrib;
 130              	   }
 126:pmode_screen.c ****    {
 292              		mov eax,0X48
 293              	 push ds
 294              	 push eax
 295              	 pop ds
 296              	
 297              	# 0 "" 2
 298              		.loc 1 126 0
 299              	#NO_APP
 300 01c4 C745FC00 		mov	DWORD PTR [ebp-4], 0
 300      000000
 301 01cb EB23     		jmp	.L19
 302              	.L20:
 128:pmode_screen.c **** 	video_memory[i+1] = attrib;
 303              		.loc 1 128 0 discriminator 3
 304 01cd 8B55FC   		mov	edx, DWORD PTR [ebp-4]
 305 01d0 8B45F8   		mov	eax, DWORD PTR [ebp-8]
 306 01d3 01C2     		add	edx, eax
 307 01d5 0FB645F7 		movzx	eax, BYTE PTR [ebp-9]
 308 01d9 8802     		mov	BYTE PTR [edx], al
 129:pmode_screen.c ****    }
 309              		.loc 1 129 0 discriminator 3
 310 01db 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 311 01de 8D5001   		lea	edx, [eax+1]
 312 01e1 8B45F8   		mov	eax, DWORD PTR [ebp-8]
 313 01e4 01C2     		add	edx, eax
 314 01e6 0FB645F6 		movzx	eax, BYTE PTR [ebp-10]
 315 01ea 8802     		mov	BYTE PTR [edx], al
 126:pmode_screen.c ****    {
 316              		.loc 1 126 0 discriminator 3
 317 01ec 8345FC02 		add	DWORD PTR [ebp-4], 2
 318              	.L19:
 126:pmode_screen.c ****    {
 319              		.loc 1 126 0 is_stmt 0 discriminator 1
 320 01f0 817DFC9F 		cmp	DWORD PTR [ebp-4], 3999
 320      0F0000
 321 01f7 7ED4     		jle	.L20
 131:pmode_screen.c **** switch_ds_back
 322              		.loc 1 131 0 is_stmt 1
 323              	#APP
 324              	# 131 "pmode_screen.c" 1
 132              	   // Move the hardware cursor back to the start.
 133:pmode_screen.c ****    cursor_x = 0;
 325              		pop ds
 326              	# 0 "" 2
 327              		.loc 1 133 0
 328              	#NO_APP
 329 01fa C7050000 		mov	DWORD PTR cursor_x, 0
 329      00000000 
 329      0000
 134:pmode_screen.c ****    cursor_y = 0;
 330              		.loc 1 134 0
 331 0204 C7050000 		mov	DWORD PTR cursor_y, 0
 331      00000000 
 331      0000
 135:pmode_screen.c ****    move_cursor();
 332              		.loc 1 135 0
 333 020e E8EDFDFF 		call	move_cursor
 333      FF
 136:pmode_screen.c **** } 
 334              		.loc 1 136 0
 335 0213 90       		nop
 336 0214 C9       		leave
 337              		.cfi_restore 5
 338              		.cfi_def_cfa 4, 4
 339 0215 C3       		ret
 340              		.cfi_endproc
 341              	.LFE3:
 343              		.globl	println
 345              	println:
 346              	.LFB4:
 137:pmode_screen.c **** 
 138:pmode_screen.c **** void println(char *c)
 139:pmode_screen.c **** {
 347              		.loc 1 139 0
 348              		.cfi_startproc
 349 0216 55       		push	ebp
 350              		.cfi_def_cfa_offset 8
 351              		.cfi_offset 5, -8
 352 0217 89E5     		mov	ebp, esp
 353              		.cfi_def_cfa_register 5
 354 0219 83EC08   		sub	esp, 8
 140:pmode_screen.c ****     print(c);
 355              		.loc 1 140 0
 356 021c 83EC0C   		sub	esp, 12
 357 021f FF7508   		push	DWORD PTR [ebp+8]
 358 0222 E8FCFFFF 		call	print
 358      FF
 359 0227 83C410   		add	esp, 16
 141:pmode_screen.c ****     monitor_put('\n');
 360              		.loc 1 141 0
 361 022a 83EC0C   		sub	esp, 12
 362 022d 6A0A     		push	10
 363 022f E8FCFFFF 		call	monitor_put
 363      FF
 364 0234 83C410   		add	esp, 16
 142:pmode_screen.c ****    // Scroll the screen if needed.
 143:pmode_screen.c ****    scroll();
 365              		.loc 1 143 0
 366 0237 E8CAFDFF 		call	scroll
 366      FF
 144:pmode_screen.c ****    // Move the hardware cursor.
 145:pmode_screen.c ****    move_cursor();
 367              		.loc 1 145 0
 368 023c E8BFFDFF 		call	move_cursor
 368      FF
 146:pmode_screen.c **** }
 369              		.loc 1 146 0
 370 0241 90       		nop
 371 0242 C9       		leave
 372              		.cfi_restore 5
 373              		.cfi_def_cfa 4, 4
 374 0243 C3       		ret
 375              		.cfi_endproc
 376              	.LFE4:
 378              		.globl	print
 380              	print:
 381              	.LFB5:
 147:pmode_screen.c **** 
 148:pmode_screen.c **** // Outputs a null-terminated ASCII string to the monitor.
 149:pmode_screen.c **** void print(char *c)
 150:pmode_screen.c **** {
 382              		.loc 1 150 0
 383              		.cfi_startproc
 384 0244 55       		push	ebp
 385              		.cfi_def_cfa_offset 8
 386              		.cfi_offset 5, -8
 387 0245 89E5     		mov	ebp, esp
 388              		.cfi_def_cfa_register 5
 389 0247 83EC10   		sub	esp, 16
 151:pmode_screen.c ****    int i = 0;
 390              		.loc 1 151 0
 391 024a C745FC00 		mov	DWORD PTR [ebp-4], 0
 391      000000
 152:pmode_screen.c ****    while (c[i])
 392              		.loc 1 152 0
 393 0251 EB1F     		jmp	.L23
 394              	.L24:
 153:pmode_screen.c ****    {
 154:pmode_screen.c ****        monitor_put(c[i++]);
 395              		.loc 1 154 0
 396 0253 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 397 0256 8D5001   		lea	edx, [eax+1]
 398 0259 8955FC   		mov	DWORD PTR [ebp-4], edx
 399 025c 89C2     		mov	edx, eax
 400 025e 8B4508   		mov	eax, DWORD PTR [ebp+8]
 401 0261 01D0     		add	eax, edx
 402 0263 0FB600   		movzx	eax, BYTE PTR [eax]
 403 0266 0FBEC0   		movsx	eax, al
 404 0269 50       		push	eax
 405 026a E8FCFFFF 		call	monitor_put
 405      FF
 406 026f 83C404   		add	esp, 4
 407              	.L23:
 152:pmode_screen.c ****    while (c[i])
 408              		.loc 1 152 0
 409 0272 8B55FC   		mov	edx, DWORD PTR [ebp-4]
 410 0275 8B4508   		mov	eax, DWORD PTR [ebp+8]
 411 0278 01D0     		add	eax, edx
 412 027a 0FB600   		movzx	eax, BYTE PTR [eax]
 413 027d 84C0     		test	al, al
 414 027f 75D2     		jne	.L24
 155:pmode_screen.c ****    }
 156:pmode_screen.c ****    // Scroll the screen if needed.
 157:pmode_screen.c ****    scroll();
 415              		.loc 1 157 0
 416 0281 E880FDFF 		call	scroll
 416      FF
 158:pmode_screen.c ****    // Move the hardware cursor.
 159:pmode_screen.c ****    move_cursor();
 417              		.loc 1 159 0
 418 0286 E875FDFF 		call	move_cursor
 418      FF
 160:pmode_screen.c **** } 
 419              		.loc 1 160 0
 420 028b 90       		nop
 421 028c C9       		leave
 422              		.cfi_restore 5
 423              		.cfi_def_cfa 4, 4
 424 028d C3       		ret
 425              		.cfi_endproc
 426              	.LFE5:
 428              		.globl	movecursor
 430              	movecursor:
 431              	.LFB6:
 161:pmode_screen.c **** 
 162:pmode_screen.c **** void movecursor(int locX, int locY)
 163:pmode_screen.c **** {
 432              		.loc 1 163 0
 433              		.cfi_startproc
 434 028e 55       		push	ebp
 435              		.cfi_def_cfa_offset 8
 436              		.cfi_offset 5, -8
 437 028f 89E5     		mov	ebp, esp
 438              		.cfi_def_cfa_register 5
 164:pmode_screen.c ****     cursor_x = locX;
 439              		.loc 1 164 0
 440 0291 8B4508   		mov	eax, DWORD PTR [ebp+8]
 441 0294 A3000000 		mov	DWORD PTR cursor_x, eax
 441      00
 165:pmode_screen.c ****     cursor_y = locY;
 442              		.loc 1 165 0
 443 0299 8B450C   		mov	eax, DWORD PTR [ebp+12]
 444 029c A3000000 		mov	DWORD PTR cursor_y, eax
 444      00
 166:pmode_screen.c ****     scroll();
 445              		.loc 1 166 0
 446 02a1 E860FDFF 		call	scroll
 446      FF
 167:pmode_screen.c **** }
 447              		.loc 1 167 0
 448 02a6 90       		nop
 449 02a7 5D       		pop	ebp
 450              		.cfi_restore 5
 451              		.cfi_def_cfa 4, 4
 452 02a8 C3       		ret
 453              		.cfi_endproc
 454              	.LFE6:
 456              		.globl	printAt
 458              	printAt:
 459              	.LFB7:
 168:pmode_screen.c **** 
 169:pmode_screen.c **** void printAt(char *c, int locX, int locY)
 170:pmode_screen.c **** {
 460              		.loc 1 170 0
 461              		.cfi_startproc
 462 02a9 55       		push	ebp
 463              		.cfi_def_cfa_offset 8
 464              		.cfi_offset 5, -8
 465 02aa 89E5     		mov	ebp, esp
 466              		.cfi_def_cfa_register 5
 171:pmode_screen.c **** 
 172:pmode_screen.c **** 	cursor_x = locX;
 467              		.loc 1 172 0
 468 02ac 8B450C   		mov	eax, DWORD PTR [ebp+12]
 469 02af A3000000 		mov	DWORD PTR cursor_x, eax
 469      00
 173:pmode_screen.c **** 	cursor_y = locY;
 470              		.loc 1 173 0
 471 02b4 8B4510   		mov	eax, DWORD PTR [ebp+16]
 472 02b7 A3000000 		mov	DWORD PTR cursor_y, eax
 472      00
 174:pmode_screen.c **** 	print(c);
 473              		.loc 1 174 0
 474 02bc FF7508   		push	DWORD PTR [ebp+8]
 475 02bf E8FCFFFF 		call	print
 475      FF
 476 02c4 83C404   		add	esp, 4
 175:pmode_screen.c **** }
 477              		.loc 1 175 0
 478 02c7 90       		nop
 479 02c8 C9       		leave
 480              		.cfi_restore 5
 481              		.cfi_def_cfa 4, 4
 482 02c9 C3       		ret
 483              		.cfi_endproc
 484              	.LFE7:
 486              		.globl	cursorX
 488              	cursorX:
 489              	.LFB8:
 176:pmode_screen.c **** 
 177:pmode_screen.c **** int cursorX()
 178:pmode_screen.c **** {
 490              		.loc 1 178 0
 491              		.cfi_startproc
 492 02ca 55       		push	ebp
 493              		.cfi_def_cfa_offset 8
 494              		.cfi_offset 5, -8
 495 02cb 89E5     		mov	ebp, esp
 496              		.cfi_def_cfa_register 5
 179:pmode_screen.c ****    return cursor_x / 2; 
 497              		.loc 1 179 0
 498 02cd A1000000 		mov	eax, DWORD PTR cursor_x
 498      00
 499 02d2 89C2     		mov	edx, eax
 500 02d4 C1EA1F   		shr	edx, 31
 501 02d7 01D0     		add	eax, edx
 502 02d9 D1F8     		sar	eax
 180:pmode_screen.c **** }
 503              		.loc 1 180 0
 504 02db 5D       		pop	ebp
 505              		.cfi_restore 5
 506              		.cfi_def_cfa 4, 4
 507 02dc C3       		ret
 508              		.cfi_endproc
 509              	.LFE8:
 511              		.globl	cursorY
 513              	cursorY:
 514              	.LFB9:
 181:pmode_screen.c **** 
 182:pmode_screen.c **** int cursorY()
 183:pmode_screen.c **** {
 515              		.loc 1 183 0
 516              		.cfi_startproc
 517 02dd 55       		push	ebp
 518              		.cfi_def_cfa_offset 8
 519              		.cfi_offset 5, -8
 520 02de 89E5     		mov	ebp, esp
 521              		.cfi_def_cfa_register 5
 184:pmode_screen.c ****    return cursor_y; 
 522              		.loc 1 184 0
 523 02e0 A1000000 		mov	eax, DWORD PTR cursor_y
 523      00
 185:pmode_screen.c **** }
 524              		.loc 1 185 0
 525 02e5 5D       		pop	ebp
 526              		.cfi_restore 5
 527              		.cfi_def_cfa 4, 4
 528 02e6 C3       		ret
 529              		.cfi_endproc
 530              	.LFE9:
 532              	.Letext0:
 533              		.file 2 "types.h"
 534              		.file 3 "xen_types.h"
 535              		.file 4 "x86_architecture.h"
 536              		.file 5 "vmcb.h"
 537              		.file 6 "host.h"
 538              		.file 7 "guest.h"
 539              		.file 8 "isr_wrapper.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 pmode_screen.c
     /tmp/ccb2vt7W.s:4      .text:0000000000000000 .Ltext0
                            *COM*:0000000000000002 _exception_number
                            *COM*:0000000000000002 _exc_CS
                            *COM*:0000000000000002 _exc_IP
                            *COM*:0000000000000044 vhost
                            *COM*:000000000000001c guest
                            *COM*:0000000000000038 GuestRegisters
     /tmp/ccb2vt7W.s:16     .bss:0000000000000000 cursorLocation
     /tmp/ccb2vt7W.s:22     .bss:0000000000000004 cursor_x
     /tmp/ccb2vt7W.s:28     .bss:0000000000000008 cursor_y
     /tmp/ccb2vt7W.s:32     .text:0000000000000000 move_cursor
     /tmp/ccb2vt7W.s:33     .text:0000000000000000 .LFB0
     /tmp/ccb2vt7W.s:50     .text:0000000000000006 .LFE0
     /tmp/ccb2vt7W.s:53     .text:0000000000000006 scroll
     /tmp/ccb2vt7W.s:54     .text:0000000000000006 .LFB1
     /tmp/ccb2vt7W.s:131    .text:0000000000000094 .L9
     /tmp/ccb2vt7W.s:76     .text:000000000000002f .LBB2
     /tmp/ccb2vt7W.s:103    .text:000000000000005c .L5
     /tmp/ccb2vt7W.s:90     .text:0000000000000040 .L6
     /tmp/ccb2vt7W.s:119    .text:0000000000000080 .L7
     /tmp/ccb2vt7W.s:110    .text:000000000000006e .L8
     /tmp/ccb2vt7W.s:132    .text:0000000000000094 .LBE2
     /tmp/ccb2vt7W.s:140    .text:0000000000000097 .LFE1
     /tmp/ccb2vt7W.s:144    .text:0000000000000097 monitor_put
     /tmp/ccb2vt7W.s:145    .text:0000000000000097 .LFB2
     /tmp/ccb2vt7W.s:172    .text:00000000000000cf .L11
     /tmp/ccb2vt7W.s:250    .text:0000000000000181 .L12
     /tmp/ccb2vt7W.s:182    .text:00000000000000ea .L13
     /tmp/ccb2vt7W.s:189    .text:00000000000000ff .L14
     /tmp/ccb2vt7W.s:200    .text:000000000000011e .L15
     /tmp/ccb2vt7W.s:261    .text:00000000000001a4 .L17
     /tmp/ccb2vt7W.s:269    .text:00000000000001a7 .LFE2
     /tmp/ccb2vt7W.s:273    .text:00000000000001a7 clrscr
     /tmp/ccb2vt7W.s:274    .text:00000000000001a7 .LFB3
     /tmp/ccb2vt7W.s:318    .text:00000000000001f0 .L19
     /tmp/ccb2vt7W.s:302    .text:00000000000001cd .L20
     /tmp/ccb2vt7W.s:341    .text:0000000000000216 .LFE3
     /tmp/ccb2vt7W.s:345    .text:0000000000000216 println
     /tmp/ccb2vt7W.s:346    .text:0000000000000216 .LFB4
     /tmp/ccb2vt7W.s:380    .text:0000000000000244 print
     /tmp/ccb2vt7W.s:376    .text:0000000000000244 .LFE4
     /tmp/ccb2vt7W.s:381    .text:0000000000000244 .LFB5
     /tmp/ccb2vt7W.s:407    .text:0000000000000272 .L23
     /tmp/ccb2vt7W.s:394    .text:0000000000000253 .L24
     /tmp/ccb2vt7W.s:426    .text:000000000000028e .LFE5
     /tmp/ccb2vt7W.s:430    .text:000000000000028e movecursor
     /tmp/ccb2vt7W.s:431    .text:000000000000028e .LFB6
     /tmp/ccb2vt7W.s:454    .text:00000000000002a9 .LFE6
     /tmp/ccb2vt7W.s:458    .text:00000000000002a9 printAt
     /tmp/ccb2vt7W.s:459    .text:00000000000002a9 .LFB7
     /tmp/ccb2vt7W.s:484    .text:00000000000002ca .LFE7
     /tmp/ccb2vt7W.s:488    .text:00000000000002ca cursorX
     /tmp/ccb2vt7W.s:489    .text:00000000000002ca .LFB8
     /tmp/ccb2vt7W.s:509    .text:00000000000002dd .LFE8
     /tmp/ccb2vt7W.s:513    .text:00000000000002dd cursorY
     /tmp/ccb2vt7W.s:514    .text:00000000000002dd .LFB9
     /tmp/ccb2vt7W.s:530    .text:00000000000002e7 .LFE9
     /tmp/ccb2vt7W.s:532    .text:00000000000002e7 .Letext0
     /tmp/ccb2vt7W.s:541    .debug_info:0000000000000000 .Ldebug_info0
     /tmp/ccb2vt7W.s:2093   .debug_abbrev:0000000000000000 .Ldebug_abbrev0
     /tmp/ccb2vt7W.s:2855   .debug_str:00000000000003e3 .LASF154
     /tmp/ccb2vt7W.s:2937   .debug_str:00000000000005dd .LASF155
     /tmp/ccb2vt7W.s:2765   .debug_str:0000000000000215 .LASF156
     /tmp/ccb2vt7W.s:2641   .debug_line:0000000000000000 .Ldebug_line0
     /tmp/ccb2vt7W.s:2821   .debug_str:0000000000000333 .LASF2
     /tmp/ccb2vt7W.s:2921   .debug_str:000000000000058a .LASF0
     /tmp/ccb2vt7W.s:2945   .debug_str:0000000000000609 .LASF1
     /tmp/ccb2vt7W.s:2727   .debug_str:0000000000000182 .LASF3
     /tmp/ccb2vt7W.s:2907   .debug_str:0000000000000530 .LASF4
     /tmp/ccb2vt7W.s:2731   .debug_str:0000000000000192 .LASF5
     /tmp/ccb2vt7W.s:2943   .debug_str:00000000000005fd .LASF6
     /tmp/ccb2vt7W.s:2909   .debug_str:0000000000000542 .LASF7
     /tmp/ccb2vt7W.s:2865   .debug_str:000000000000045b .LASF8
     /tmp/ccb2vt7W.s:2767   .debug_str:0000000000000239 .LASF9
     /tmp/ccb2vt7W.s:2805   .debug_str:00000000000002de .LASF10
     /tmp/ccb2vt7W.s:2659   .debug_str:000000000000004b .LASF11
     /tmp/ccb2vt7W.s:2813   .debug_str:00000000000002fd .LASF12
     /tmp/ccb2vt7W.s:2859   .debug_str:0000000000000445 .LASF13
     /tmp/ccb2vt7W.s:2797   .debug_str:00000000000002bd .LASF14
     /tmp/ccb2vt7W.s:2803   .debug_str:00000000000002d6 .LASF15
     /tmp/ccb2vt7W.s:2843   .debug_str:000000000000039d .LASF16
     /tmp/ccb2vt7W.s:2697   .debug_str:0000000000000113 .LASF17
     /tmp/ccb2vt7W.s:2885   .debug_str:00000000000004b1 .LASF18
     /tmp/ccb2vt7W.s:2917   .debug_str:0000000000000576 .LASF19
     /tmp/ccb2vt7W.s:2679   .debug_str:00000000000000bf .LASF20
     /tmp/ccb2vt7W.s:2869   .debug_str:0000000000000470 .LASF21
     /tmp/ccb2vt7W.s:2781   .debug_str:0000000000000274 .LASF22
     /tmp/ccb2vt7W.s:2799   .debug_str:00000000000002c2 .LASF23
     /tmp/ccb2vt7W.s:2819   .debug_str:000000000000031e .LASF24
     /tmp/ccb2vt7W.s:2789   .debug_str:0000000000000299 .LASF42
     /tmp/ccb2vt7W.s:2745   .debug_str:00000000000001cd .LASF25
     /tmp/ccb2vt7W.s:2677   .debug_str:00000000000000b9 .LASF26
     /tmp/ccb2vt7W.s:2717   .debug_str:0000000000000158 .LASF27
     /tmp/ccb2vt7W.s:2733   .debug_str:00000000000001a9 .LASF28
     /tmp/ccb2vt7W.s:2651   .debug_str:0000000000000029 .LASF29
     /tmp/ccb2vt7W.s:2729   .debug_str:0000000000000188 .LASF30
     /tmp/ccb2vt7W.s:2825   .debug_str:000000000000033d .LASF31
     /tmp/ccb2vt7W.s:2927   .debug_str:00000000000005ba .LASF32
     /tmp/ccb2vt7W.s:2791   .debug_str:00000000000002a5 .LASF33
     /tmp/ccb2vt7W.s:2761   .debug_str:0000000000000203 .LASF34
     /tmp/ccb2vt7W.s:2929   .debug_str:00000000000005c0 .LASF35
     /tmp/ccb2vt7W.s:2889   .debug_str:00000000000004c8 .LASF36
     /tmp/ccb2vt7W.s:2931   .debug_str:00000000000005c6 .LASF37
     /tmp/ccb2vt7W.s:2933   .debug_str:00000000000005cc .LASF38
     /tmp/ccb2vt7W.s:2647   .debug_str:000000000000001c .LASF39
     /tmp/ccb2vt7W.s:2755   .debug_str:00000000000001f0 .LASF40
     /tmp/ccb2vt7W.s:2863   .debug_str:0000000000000451 .LASF41
     /tmp/ccb2vt7W.s:2687   .debug_str:00000000000000e7 .LASF43
     /tmp/ccb2vt7W.s:2873   .debug_str:0000000000000482 .LASF44
     /tmp/ccb2vt7W.s:2673   .debug_str:000000000000009f .LASF45
     /tmp/ccb2vt7W.s:2785   .debug_str:000000000000027f .LASF46
     /tmp/ccb2vt7W.s:2829   .debug_str:0000000000000354 .LASF47
     /tmp/ccb2vt7W.s:2645   .debug_str:0000000000000008 .LASF48
     /tmp/ccb2vt7W.s:2693   .debug_str:0000000000000107 .LASF49
     /tmp/ccb2vt7W.s:2695   .debug_str:000000000000010d .LASF50
     /tmp/ccb2vt7W.s:2707   .debug_str:0000000000000134 .LASF51
     /tmp/ccb2vt7W.s:2699   .debug_str:000000000000011c .LASF52
     /tmp/ccb2vt7W.s:2701   .debug_str:0000000000000122 .LASF53
     /tmp/ccb2vt7W.s:2703   .debug_str:0000000000000128 .LASF54
     /tmp/ccb2vt7W.s:2893   .debug_str:00000000000004e1 .LASF55
     /tmp/ccb2vt7W.s:2915   .debug_str:0000000000000568 .LASF56
     /tmp/ccb2vt7W.s:2663   .debug_str:0000000000000065 .LASF57
     /tmp/ccb2vt7W.s:2853   .debug_str:00000000000003d8 .LASF58
     /tmp/ccb2vt7W.s:2827   .debug_str:0000000000000348 .LASF59
     /tmp/ccb2vt7W.s:2705   .debug_str:000000000000012e .LASF60
     /tmp/ccb2vt7W.s:2857   .debug_str:000000000000043f .LASF61
     /tmp/ccb2vt7W.s:2665   .debug_str:0000000000000070 .LASF62
     /tmp/ccb2vt7W.s:2959   .debug_str:0000000000000657 .LASF63
     /tmp/ccb2vt7W.s:2957   .debug_str:000000000000064d .LASF64
     /tmp/ccb2vt7W.s:2777   .debug_str:000000000000025f .LASF65
     /tmp/ccb2vt7W.s:2895   .debug_str:00000000000004ee .LASF66
     /tmp/ccb2vt7W.s:2671   .debug_str:0000000000000095 .LASF67
     /tmp/ccb2vt7W.s:2711   .debug_str:0000000000000140 .LASF68
     /tmp/ccb2vt7W.s:2833   .debug_str:000000000000036f .LASF69
     /tmp/ccb2vt7W.s:2867   .debug_str:0000000000000465 .LASF70
     /tmp/ccb2vt7W.s:2675   .debug_str:00000000000000ad .LASF71
     /tmp/ccb2vt7W.s:2941   .debug_str:00000000000005f2 .LASF72
     /tmp/ccb2vt7W.s:2709   .debug_str:000000000000013a .LASF73
     /tmp/ccb2vt7W.s:2723   .debug_str:000000000000016f .LASF74
     /tmp/ccb2vt7W.s:2759   .debug_str:00000000000001fc .LASF75
     /tmp/ccb2vt7W.s:2787   .debug_str:0000000000000294 .LASF76
     /tmp/ccb2vt7W.s:2743   .debug_str:00000000000001c8 .LASF77
     /tmp/ccb2vt7W.s:2823   .debug_str:0000000000000338 .LASF78
     /tmp/ccb2vt7W.s:2735   .debug_str:00000000000001b0 .LASF79
     /tmp/ccb2vt7W.s:2737   .debug_str:00000000000001b6 .LASF80
     /tmp/ccb2vt7W.s:2739   .debug_str:00000000000001bc .LASF81
     /tmp/ccb2vt7W.s:2649   .debug_str:0000000000000024 .LASF82
     /tmp/ccb2vt7W.s:2741   .debug_str:00000000000001c2 .LASF83
     /tmp/ccb2vt7W.s:2835   .debug_str:0000000000000378 .LASF84
     /tmp/ccb2vt7W.s:2771   .debug_str:000000000000024d .LASF85
     /tmp/ccb2vt7W.s:2773   .debug_str:0000000000000253 .LASF86
     /tmp/ccb2vt7W.s:2757   .debug_str:00000000000001f7 .LASF87
     /tmp/ccb2vt7W.s:2681   .debug_str:00000000000000c4 .LASF88
     /tmp/ccb2vt7W.s:2753   .debug_str:00000000000001ea .LASF89
     /tmp/ccb2vt7W.s:2831   .debug_str:0000000000000368 .LASF90
     /tmp/ccb2vt7W.s:2725   .debug_str:0000000000000177 .LASF91
     /tmp/ccb2vt7W.s:2851   .debug_str:00000000000003cc .LASF92
     /tmp/ccb2vt7W.s:2793   .debug_str:00000000000002aa .LASF93
     /tmp/ccb2vt7W.s:2685   .debug_str:00000000000000da .LASF94
     /tmp/ccb2vt7W.s:2877   .debug_str:0000000000000499 .LASF95
     /tmp/ccb2vt7W.s:2879   .debug_str:000000000000049f .LASF96
     /tmp/ccb2vt7W.s:2881   .debug_str:00000000000004a5 .LASF97
     /tmp/ccb2vt7W.s:2883   .debug_str:00000000000004ab .LASF98
     /tmp/ccb2vt7W.s:2897   .debug_str:00000000000004fa .LASF99
     /tmp/ccb2vt7W.s:2691   .debug_str:00000000000000fb .LASF100
     /tmp/ccb2vt7W.s:2901   .debug_str:000000000000050f .LASF101
     /tmp/ccb2vt7W.s:2911   .debug_str:0000000000000547 .LASF102
     /tmp/ccb2vt7W.s:2769   .debug_str:000000000000023f .LASF103
     /tmp/ccb2vt7W.s:2891   .debug_str:00000000000004d5 .LASF104
     /tmp/ccb2vt7W.s:2747   .debug_str:00000000000001d2 .LASF105
     /tmp/ccb2vt7W.s:2903   .debug_str:0000000000000520 .LASF106
     /tmp/ccb2vt7W.s:2845   .debug_str:00000000000003a6 .LASF107
     /tmp/ccb2vt7W.s:2713   .debug_str:0000000000000146 .LASF108
     /tmp/ccb2vt7W.s:2947   .debug_str:000000000000061c .LASF109
     /tmp/ccb2vt7W.s:2779   .debug_str:0000000000000269 .LASF110
     /tmp/ccb2vt7W.s:2847   .debug_str:00000000000003b1 .LASF111
     /tmp/ccb2vt7W.s:2955   .debug_str:0000000000000643 .LASF112
     /tmp/ccb2vt7W.s:2763   .debug_str:000000000000020b .LASF113
     /tmp/ccb2vt7W.s:2871   .debug_str:0000000000000475 .LASF114
     /tmp/ccb2vt7W.s:2715   .debug_str:000000000000014f .LASF115
     /tmp/ccb2vt7W.s:2839   .debug_str:000000000000038c .LASF116
     /tmp/ccb2vt7W.s:2949   .debug_str:0000000000000626 .LASF117
     /tmp/ccb2vt7W.s:2683   .debug_str:00000000000000ca .LASF118
     /tmp/ccb2vt7W.s:2899   .debug_str:0000000000000500 .LASF119
     /tmp/ccb2vt7W.s:2669   .debug_str:000000000000008d .LASF120
     /tmp/ccb2vt7W.s:2815   .debug_str:000000000000030b .LASF121
     /tmp/ccb2vt7W.s:2953   .debug_str:0000000000000637 .LASF122
     /tmp/ccb2vt7W.s:2783   .debug_str:000000000000027a .LASF123
     /tmp/ccb2vt7W.s:2923   .debug_str:0000000000000598 .LASF124
     /tmp/ccb2vt7W.s:2837   .debug_str:000000000000037f .LASF125
     /tmp/ccb2vt7W.s:2925   .debug_str:00000000000005ad .LASF126
     /tmp/ccb2vt7W.s:2661   .debug_str:0000000000000058 .LASF127
     /tmp/ccb2vt7W.s:2935   .debug_str:00000000000005d2 .LASF128
     /tmp/ccb2vt7W.s:2749   .debug_str:00000000000001d8 .LASF129
     /tmp/ccb2vt7W.s:2775   .debug_str:0000000000000259 .LASF130
     /tmp/ccb2vt7W.s:2849   .debug_str:00000000000003c0 .LASF157
     /tmp/ccb2vt7W.s:2841   .debug_str:0000000000000396 .LASF158
     /tmp/ccb2vt7W.s:2801   .debug_str:00000000000002c9 .LASF131
     /tmp/ccb2vt7W.s:2887   .debug_str:00000000000004ba .LASF132
     /tmp/ccb2vt7W.s:2939   .debug_str:00000000000005ec .LASF133
     /tmp/ccb2vt7W.s:2667   .debug_str:0000000000000081 .LASF136
     /tmp/ccb2vt7W.s:2875   .debug_str:0000000000000490 .LASF134
     /tmp/ccb2vt7W.s:2905   .debug_str:0000000000000529 .LASF159
     /tmp/ccb2vt7W.s:2951   .debug_str:0000000000000630 .LASF135
     /tmp/ccb2vt7W.s:2961   .debug_str:0000000000000660 .LASF137
     /tmp/ccb2vt7W.s:2861   .debug_str:000000000000044b .LASF138
     /tmp/ccb2vt7W.s:2653   .debug_str:0000000000000030 .LASF139
     /tmp/ccb2vt7W.s:2809   .debug_str:00000000000002f3 .LASF140
     /tmp/ccb2vt7W.s:2811   .debug_str:00000000000002f8 .LASF141
     /tmp/ccb2vt7W.s:2689   .debug_str:00000000000000f3 .LASF142
     /tmp/ccb2vt7W.s:2655   .debug_str:000000000000003b .LASF143
     /tmp/ccb2vt7W.s:2657   .debug_str:0000000000000043 .LASF144
     /tmp/ccb2vt7W.s:2913   .debug_str:0000000000000556 .LASF145
     /tmp/ccb2vt7W.s:2643   .debug_str:0000000000000000 .LASF146
     /tmp/ccb2vt7W.s:2817   .debug_str:0000000000000316 .LASF147
     /tmp/ccb2vt7W.s:2795   .debug_str:00000000000002b7 .LASF148
     /tmp/ccb2vt7W.s:2751   .debug_str:00000000000001e4 .LASF149
     /tmp/ccb2vt7W.s:2807   .debug_str:00000000000002e4 .LASF150
     /tmp/ccb2vt7W.s:2919   .debug_str:000000000000057b .LASF151
     /tmp/ccb2vt7W.s:2719   .debug_str:000000000000015d .LASF152
     /tmp/ccb2vt7W.s:2721   .debug_str:0000000000000166 .LASF153

NO UNDEFINED SYMBOLS
   1              		.file	"utility.c"
   2              		.intel_syntax noprefix
   3              		.text
   4              	.Ltext0:
   5              		.comm	_exception_number,2,2
   6              		.comm	_exc_CS,2,2
   7              		.comm	_exc_IP,2,2
   8              		.comm	vhost,68,32
   9              		.comm	guest,28,4
  10              		.comm	GuestRegisters,56,32
  11              		.comm	host,8,4
  12              		.globl	GuestMemOffset
  13              		.bss
  14              		.align 4
  17              	GuestMemOffset:
  18 0000 00000000 		.zero	4
  19              		.text
  20              		.globl	RetrieveStartModuleDiskCHSValues
  22              	RetrieveStartModuleDiskCHSValues:
  23              	.LFB0:
  24              		.file 1 "utility.c"
   1:utility.c     **** #include "utility.h"
   2:utility.c     **** #include "BMVisor.h"
   3:utility.c     **** #include "visor_main.h"
   4:utility.c     **** #include "x86.h"
   5:utility.c     **** #include "xen_types.h"
   6:utility.c     **** 
   7:utility.c     **** DWORD DoNestedPageLookup(DWORD GAddress);
   8:utility.c     **** DWORD DoGuestPageLookup(DWORD GAddress);
   9:utility.c     **** 
  10:utility.c     **** DWORD GuestMemOffset = 0;
  11:utility.c     **** extern DWORD fatalErrorNum;
  12:utility.c     **** /*
  13:utility.c     **** *Retrieve the CHS values for the physical disk, which were set in specific locations by the Start m
  14:utility.c     ****  *SPT: Sectors per Track - Stored to RealSectors
  15:utility.c     ****  *HEADS: Heads  - Stored to RealHeads
  16:utility.c     ****  * CYLS: Cylinders - Stored to RealCylinders
  17:utility.c     ****  */
  18:utility.c     **** void RetrieveStartModuleDiskCHSValues (WORD *Sectors, WORD *Heads,DWORD *Cylinders)
  19:utility.c     **** {
  25              		.loc 1 19 0
  26              		.cfi_startproc
  27 0000 55       		push	ebp
  28              		.cfi_def_cfa_offset 8
  29              		.cfi_offset 5, -8
  30 0001 89E5     		mov	ebp, esp
  31              		.cfi_def_cfa_register 5
  32 0003 53       		push	ebx
  33              		.cfi_offset 3, -12
  20:utility.c     ****     asm("mov eax,%[location]\n"
  34              		.loc 1 20 0
  35 0004 B8F0FF00 		mov	eax, 65520
  35      00
  36              	#APP
  37              	# 20 "utility.c" 1
  21 000b 50       	    "push eax\n"
  22 000c 648B00   	    "mov eax, fs:[eax]\n"
  23 000f 6689C3   	    "movw %[sectors],ax\n"
  24 0012 58       	    "pop eax\n"
  25 0013 83C004   	    "add eax,4\n"
  26 0016 50       	    "push eax\n"
  27 0017 648B00   	    "mov eax, fs:[eax]\n"
  28 001a 6689C1   	    "mov %[heads],ax\n"
  29 001d 58       	    "pop eax\n"
  30 001e 83C004   	    "add eax,4\n"
  31 0021 648B00   	    "mov eax, fs:[eax]\n"
  32 0024 89C2     	    "mov %[cylinders],eax\n"
  33              	    : [sectors] "=r" (*Sectors),
  34              	      [heads] "=r" (*Heads),
  38              		mov eax,eax
  39              	push eax
  40              	mov eax, fs:[eax]
  41              	movw bx,ax
  42              	pop eax
  43              	add eax,4
  44              	push eax
  45              	mov eax, fs:[eax]
  46              	mov cx,ax
  47              	pop eax
  48              	add eax,4
  49              	mov eax, fs:[eax]
  50              	mov edx,eax
  51              	
  52              	# 0 "" 2
  53              	#NO_APP
  54 0026 8B4508   		mov	eax, DWORD PTR [ebp+8]
  55 0029 668918   		mov	WORD PTR [eax], bx
  56 002c 8B450C   		mov	eax, DWORD PTR [ebp+12]
  57 002f 668908   		mov	WORD PTR [eax], cx
  58 0032 8B4510   		mov	eax, DWORD PTR [ebp+16]
  59 0035 8910     		mov	DWORD PTR [eax], edx
  35:utility.c     ****       [cylinders] "=r" (*Cylinders)
  36:utility.c     ****     :[location] "r" (START_MODULE_SPT_ADDR)
  37:utility.c     ****     );
  38:utility.c     **** }
  60              		.loc 1 38 0
  61 0037 90       		nop
  62 0038 5B       		pop	ebx
  63              		.cfi_restore 3
  64 0039 5D       		pop	ebp
  65              		.cfi_restore 5
  66              		.cfi_def_cfa 4, 4
  67 003a C3       		ret
  68              		.cfi_endproc
  69              	.LFE0:
  71              		.globl	CopyMemory
  73              	CopyMemory:
  74              	.LFB1:
  39:utility.c     **** 
  40:utility.c     **** /*Copy data from source location to destination location using FS and ES which are both ALL_MEM sel
  41:utility.c     **** void CopyMemory(DWORD from, DWORD to, DWORD cnt)
  42:utility.c     **** {
  75              		.loc 1 42 0
  76              		.cfi_startproc
  77 003b 55       		push	ebp
  78              		.cfi_def_cfa_offset 8
  79              		.cfi_offset 5, -8
  80 003c 89E5     		mov	ebp, esp
  81              		.cfi_def_cfa_register 5
  43:utility.c     **** 	asm(
  82              		.loc 1 43 0
  83 003e 8B4508   		mov	eax, DWORD PTR [ebp+8]
  84 0041 8B550C   		mov	edx, DWORD PTR [ebp+12]
  85 0044 8B4D10   		mov	ecx, DWORD PTR [ebp+16]
  86              	#APP
  87              	# 43 "utility.c" 1
  44 0049 89D7     					"mov esi, %[from]\n"
  45 004b 89C9     					"mov edi, %[to]\n"
  46 004d FC       					"mov ecx, %[cnt]\n"
  47 004e 64F3A4   					"cld\n"
  48              					"rep movsb es:[edi], fs:[esi]\n"
  49              					: //no return params
  50:utility.c     **** 				: [from] "r" (from),
  51:utility.c     **** 				  [to] "r" (to),
  52:utility.c     **** 				  [cnt] "r" (cnt)
  53:utility.c     **** 				);
  54:utility.c     **** }
  88              		mov esi, eax
  89              	mov edi, edx
  90              	mov ecx, ecx
  91              	cld
  92              	rep movsb es:[edi], fs:[esi]
  93              	
  94              	# 0 "" 2
  95              		.loc 1 54 0
  96              	#NO_APP
  97 0051 90       		nop
  98 0052 5D       		pop	ebp
  99              		.cfi_restore 5
 100              		.cfi_def_cfa 4, 4
 101 0053 C3       		ret
 102              		.cfi_endproc
 103              	.LFE1:
 105              		.globl	ZeroMemory
 107              	ZeroMemory:
 108              	.LFB2:
  55:utility.c     **** 
  56:utility.c     **** void ZeroMemory(DWORD location, DWORD cnt)
  57:utility.c     **** {
 109              		.loc 1 57 0
 110              		.cfi_startproc
 111 0054 55       		push	ebp
 112              		.cfi_def_cfa_offset 8
 113              		.cfi_offset 5, -8
 114 0055 89E5     		mov	ebp, esp
 115              		.cfi_def_cfa_register 5
  58:utility.c     ****     asm(
 116              		.loc 1 58 0
 117 0057 8B4508   		mov	eax, DWORD PTR [ebp+8]
 118 005a 8B550C   		mov	edx, DWORD PTR [ebp+12]
 119              	#APP
 120              	# 58 "utility.c" 1
  59 005f B8000000 	                                "mov edi, %[Location]\n"
  59      00
  60 0064 89D1     					"mov eax, 0\n"
  61 0066 FC       					"mov ecx, %[Cnt]\n"
  62 0067 F3AA     					"cld\n"
  63              					"rep stosb es:[edi]\n"
  64              	                                : : [Location] "r" (location),
  65:utility.c     ****                                     [Cnt] "r" (cnt)
  66:utility.c     ****         );
  67:utility.c     **** }
 121              		mov edi, eax
 122              	mov eax, 0
 123              	mov ecx, edx
 124              	cld
 125              	rep stosb es:[edi]
 126              	
 127              	# 0 "" 2
 128              		.loc 1 67 0
 129              	#NO_APP
 130 0069 90       		nop
 131 006a 5D       		pop	ebp
 132              		.cfi_restore 5
 133              		.cfi_def_cfa 4, 4
 134 006b C3       		ret
 135              		.cfi_endproc
 136              	.LFE2:
 138              		.globl	outb
 140              	outb:
 141              	.LFB3:
  68:utility.c     **** 
  69:utility.c     **** // common.c -- Defines some global functions.
  70:utility.c     **** // From JamesM's kernel development tutorials.
  71:utility.c     **** // Write a byte out to the specified port.
  72:utility.c     **** void outb(uint16_t port, uint8_t value)
  73:utility.c     **** {
 142              		.loc 1 73 0
 143              		.cfi_startproc
 144 006c 55       		push	ebp
 145              		.cfi_def_cfa_offset 8
 146              		.cfi_offset 5, -8
 147 006d 89E5     		mov	ebp, esp
 148              		.cfi_def_cfa_register 5
 149 006f 83EC08   		sub	esp, 8
 150 0072 8B5508   		mov	edx, DWORD PTR [ebp+8]
 151 0075 8B450C   		mov	eax, DWORD PTR [ebp+12]
 152 0078 668955FC 		mov	WORD PTR [ebp-4], dx
 153 007c 8845F8   		mov	BYTE PTR [ebp-8], al
  74:utility.c     ****     asm volatile ("outb %0, %1" : : "dN" (port), "a" (value));
 154              		.loc 1 74 0
 155 007f 0FB755FC 		movzx	edx, WORD PTR [ebp-4]
 156 0083 0FB645F8 		movzx	eax, BYTE PTR [ebp-8]
 157              	#APP
 158              	# 74 "utility.c" 1
  75              	}
 159              		outb dx, al
 160              	# 0 "" 2
 161              		.loc 1 75 0
 162              	#NO_APP
 163 0088 90       		nop
 164 0089 C9       		leave
 165              		.cfi_restore 5
 166              		.cfi_def_cfa 4, 4
 167 008a C3       		ret
 168              		.cfi_endproc
 169              	.LFE3:
 171              		.globl	outw
 173              	outw:
 174              	.LFB4:
  76:utility.c     **** 
  77:utility.c     **** void outw(uint16_t port, uint16_t value)
  78:utility.c     **** {
 175              		.loc 1 78 0
 176              		.cfi_startproc
 177 008b 55       		push	ebp
 178              		.cfi_def_cfa_offset 8
 179              		.cfi_offset 5, -8
 180 008c 89E5     		mov	ebp, esp
 181              		.cfi_def_cfa_register 5
 182 008e 83EC08   		sub	esp, 8
 183 0091 8B5508   		mov	edx, DWORD PTR [ebp+8]
 184 0094 8B450C   		mov	eax, DWORD PTR [ebp+12]
 185 0097 668955FC 		mov	WORD PTR [ebp-4], dx
 186 009b 668945F8 		mov	WORD PTR [ebp-8], ax
  79:utility.c     ****     asm volatile ("outw %0, %1" : : "dN" (port), "a" (value));
 187              		.loc 1 79 0
 188 009f 0FB755FC 		movzx	edx, WORD PTR [ebp-4]
 189 00a3 0FB745F8 		movzx	eax, WORD PTR [ebp-8]
 190              	#APP
 191              	# 79 "utility.c" 1
  80              	}
 192              		outw dx, ax
 193              	# 0 "" 2
 194              		.loc 1 80 0
 195              	#NO_APP
 196 00a9 90       		nop
 197 00aa C9       		leave
 198              		.cfi_restore 5
 199              		.cfi_def_cfa 4, 4
 200 00ab C3       		ret
 201              		.cfi_endproc
 202              	.LFE4:
 204              		.globl	outd
 206              	outd:
 207              	.LFB5:
  81:utility.c     **** 
  82:utility.c     **** void outd(uint16_t port, uint32_t value)
  83:utility.c     **** {
 208              		.loc 1 83 0
 209              		.cfi_startproc
 210 00ac 55       		push	ebp
 211              		.cfi_def_cfa_offset 8
 212              		.cfi_offset 5, -8
 213 00ad 89E5     		mov	ebp, esp
 214              		.cfi_def_cfa_register 5
 215 00af 83EC04   		sub	esp, 4
 216 00b2 8B4508   		mov	eax, DWORD PTR [ebp+8]
 217 00b5 668945FC 		mov	WORD PTR [ebp-4], ax
  84:utility.c     ****     asm volatile ("outd %0, %1" : : "dN" (port), "a" (value));
 218              		.loc 1 84 0
 219 00b9 0FB755FC 		movzx	edx, WORD PTR [ebp-4]
 220 00bd 8B450C   		mov	eax, DWORD PTR [ebp+12]
 221              	#APP
 222              	# 84 "utility.c" 1
  85              	}
 223              		outd dx, eax
 224              	# 0 "" 2
 225              		.loc 1 85 0
 226              	#NO_APP
 227 00c1 90       		nop
 228 00c2 C9       		leave
 229              		.cfi_restore 5
 230              		.cfi_def_cfa 4, 4
 231 00c3 C3       		ret
 232              		.cfi_endproc
 233              	.LFE5:
 235              		.globl	inb
 237              	inb:
 238              	.LFB6:
  86:utility.c     **** 
  87:utility.c     **** uint8_t inb(uint16_t port)
  88:utility.c     **** {
 239              		.loc 1 88 0
 240              		.cfi_startproc
 241 00c4 55       		push	ebp
 242              		.cfi_def_cfa_offset 8
 243              		.cfi_offset 5, -8
 244 00c5 89E5     		mov	ebp, esp
 245              		.cfi_def_cfa_register 5
 246 00c7 83EC14   		sub	esp, 20
 247 00ca 8B4508   		mov	eax, DWORD PTR [ebp+8]
 248 00cd 668945EC 		mov	WORD PTR [ebp-20], ax
  89:utility.c     ****    uint8_t ret;
  90:utility.c     ****    asm volatile("inb %0, %1" : "=a" (ret) : "dN" (port));
 249              		.loc 1 90 0
 250 00d1 0FB745EC 		movzx	eax, WORD PTR [ebp-20]
 251 00d5 89C2     		mov	edx, eax
 252              	#APP
 253              	# 90 "utility.c" 1
  91              	   return ret;
 254              		inb al, dx
 255              	# 0 "" 2
 256              	#NO_APP
 257 00d8 8845FF   		mov	BYTE PTR [ebp-1], al
 258              		.loc 1 91 0
 259 00db 0FB645FF 		movzx	eax, BYTE PTR [ebp-1]
  92:utility.c     **** }
 260              		.loc 1 92 0
 261 00df C9       		leave
 262              		.cfi_restore 5
 263              		.cfi_def_cfa 4, 4
 264 00e0 C3       		ret
 265              		.cfi_endproc
 266              	.LFE6:
 268              		.globl	inw
 270              	inw:
 271              	.LFB7:
  93:utility.c     **** 
  94:utility.c     **** uint16_t inw(uint16_t port)
  95:utility.c     **** {
 272              		.loc 1 95 0
 273              		.cfi_startproc
 274 00e1 55       		push	ebp
 275              		.cfi_def_cfa_offset 8
 276              		.cfi_offset 5, -8
 277 00e2 89E5     		mov	ebp, esp
 278              		.cfi_def_cfa_register 5
 279 00e4 83EC14   		sub	esp, 20
 280 00e7 8B4508   		mov	eax, DWORD PTR [ebp+8]
 281 00ea 668945EC 		mov	WORD PTR [ebp-20], ax
  96:utility.c     ****    uint16_t ret;
  97:utility.c     ****    asm volatile ("inw %0, %1" : "=a" (ret) : "dN" (port));
 282              		.loc 1 97 0
 283 00ee 0FB745EC 		movzx	eax, WORD PTR [ebp-20]
 284 00f2 89C2     		mov	edx, eax
 285              	#APP
 286              	# 97 "utility.c" 1
  98              	   return ret;
 287              		inw ax, dx
 288              	# 0 "" 2
 289              	#NO_APP
 290 00f6 668945FE 		mov	WORD PTR [ebp-2], ax
 291              		.loc 1 98 0
 292 00fa 0FB745FE 		movzx	eax, WORD PTR [ebp-2]
  99:utility.c     **** } 
 293              		.loc 1 99 0
 294 00fe C9       		leave
 295              		.cfi_restore 5
 296              		.cfi_def_cfa 4, 4
 297 00ff C3       		ret
 298              		.cfi_endproc
 299              	.LFE7:
 301              		.globl	ind
 303              	ind:
 304              	.LFB8:
 100:utility.c     **** 
 101:utility.c     **** uint32_t ind(uint16_t port)
 102:utility.c     **** {
 305              		.loc 1 102 0
 306              		.cfi_startproc
 307 0100 55       		push	ebp
 308              		.cfi_def_cfa_offset 8
 309              		.cfi_offset 5, -8
 310 0101 89E5     		mov	ebp, esp
 311              		.cfi_def_cfa_register 5
 312 0103 83EC14   		sub	esp, 20
 313 0106 8B4508   		mov	eax, DWORD PTR [ebp+8]
 314 0109 668945EC 		mov	WORD PTR [ebp-20], ax
 103:utility.c     ****    uint32_t ret;
 104:utility.c     ****    asm volatile ("ind %0, %1" : "=a" (ret) : "dN" (port));
 315              		.loc 1 104 0
 316 010d 0FB745EC 		movzx	eax, WORD PTR [ebp-20]
 317 0111 89C2     		mov	edx, eax
 318              	#APP
 319              	# 104 "utility.c" 1
 105              	   return ret;
 320              		ind eax, dx
 321              	# 0 "" 2
 322              	#NO_APP
 323 0114 8945FC   		mov	DWORD PTR [ebp-4], eax
 324              		.loc 1 105 0
 325 0117 8B45FC   		mov	eax, DWORD PTR [ebp-4]
 106:utility.c     **** } 
 326              		.loc 1 106 0
 327 011a C9       		leave
 328              		.cfi_restore 5
 329              		.cfi_def_cfa 4, 4
 330 011b C3       		ret
 331              		.cfi_endproc
 332              	.LFE8:
 334              		.globl	rdmsr
 336              	rdmsr:
 337              	.LFB9:
 107:utility.c     **** 
 108:utility.c     **** QWORD rdmsr(DWORD msr_id)
 109:utility.c     **** {
 338              		.loc 1 109 0
 339              		.cfi_startproc
 340 011c 55       		push	ebp
 341              		.cfi_def_cfa_offset 8
 342              		.cfi_offset 5, -8
 343 011d 89E5     		mov	ebp, esp
 344              		.cfi_def_cfa_register 5
 345 011f 83EC10   		sub	esp, 16
 110:utility.c     **** 		QWORD msr_value;
 111:utility.c     **** 		__asm__ __volatile__ ("   rdmsr"
 346              		.loc 1 111 0
 347 0122 8B4508   		mov	eax, DWORD PTR [ebp+8]
 348 0125 89C1     		mov	ecx, eax
 349              	#APP
 350              	# 111 "utility.c" 1
 112              									: "=A" (msr_value)
 351              		   rdmsr
 352              	# 0 "" 2
 353              	#NO_APP
 354 0129 8945F8   		mov	DWORD PTR [ebp-8], eax
 355 012c 8955FC   		mov	DWORD PTR [ebp-4], edx
 113:utility.c     **** 								: "c" (msr_id) );
 114:utility.c     **** 		return msr_value;
 356              		.loc 1 114 0
 357 012f 8B45F8   		mov	eax, DWORD PTR [ebp-8]
 358 0132 8B55FC   		mov	edx, DWORD PTR [ebp-4]
 115:utility.c     **** }
 359              		.loc 1 115 0
 360 0135 C9       		leave
 361              		.cfi_restore 5
 362              		.cfi_def_cfa 4, 4
 363 0136 C3       		ret
 364              		.cfi_endproc
 365              	.LFE9:
 367              		.globl	SVMCanBeEnabled
 369              	SVMCanBeEnabled:
 370              	.LFB10:
 116:utility.c     **** 
 117:utility.c     **** WORD SVMCanBeEnabled()
 118:utility.c     **** {
 371              		.loc 1 118 0
 372              		.cfi_startproc
 373 0137 55       		push	ebp
 374              		.cfi_def_cfa_offset 8
 375              		.cfi_offset 5, -8
 376 0138 89E5     		mov	ebp, esp
 377              		.cfi_def_cfa_register 5
 378 013a 57       		push	edi
 379 013b 56       		push	esi
 380 013c 53       		push	ebx
 381 013d 83EC14   		sub	esp, 20
 382              		.cfi_offset 7, -12
 383              		.cfi_offset 6, -16
 384              		.cfi_offset 3, -20
 119:utility.c     **** 	DWORD eax, ebx, ecx, edx;
 120:utility.c     **** 	cpuid(0x80000001, eax, ebx, ecx, edx);
 385              		.loc 1 120 0
 386 0140 B8010000 		mov	eax, -2147483647
 386      80
 387              	#APP
 388              	# 120 "utility.c" 1
 121              		
 389              		cpuid
 390              	# 0 "" 2
 391              	#NO_APP
 392 0147 8945EC   		mov	DWORD PTR [ebp-20], eax
 393 014a 895DE8   		mov	DWORD PTR [ebp-24], ebx
 394 014d 894DE4   		mov	DWORD PTR [ebp-28], ecx
 395 0150 8955E0   		mov	DWORD PTR [ebp-32], edx
 122:utility.c     **** 	if ( (ecx & 0x04) == 0)
 396              		.loc 1 122 0
 397 0153 8B45E4   		mov	eax, DWORD PTR [ebp-28]
 398 0156 83E004   		and	eax, 4
 399 0159 85C0     		test	eax, eax
 400 015b 7507     		jne	.L16
 123:utility.c     **** 		return SVM_NOT_AVAIL;
 401              		.loc 1 123 0
 402 015d B8010000 		mov	eax, 1
 402      00
 403 0162 EB56     		jmp	.L17
 404              	.L16:
 124:utility.c     **** 	
 125:utility.c     ****         if ( (rdmsr(MSR_VM_CR) & 0x10) == 0x0)
 405              		.loc 1 125 0
 406 0164 83EC04   		sub	esp, 4
 407 0167 68140101 		push	-1073676012
 407      C0
 408 016c E8FCFFFF 		call	rdmsr
 408      FF
 409 0171 83C408   		add	esp, 8
 410 0174 89C1     		mov	ecx, eax
 411 0176 83E110   		and	ecx, 16
 412 0179 89CE     		mov	esi, ecx
 413 017b 89D0     		mov	eax, edx
 414 017d 83E000   		and	eax, 0
 415 0180 89C7     		mov	edi, eax
 416 0182 89F8     		mov	eax, edi
 417 0184 09F0     		or	eax, esi
 418 0186 85C0     		test	eax, eax
 419 0188 7507     		jne	.L18
 126:utility.c     **** 		return SVM_ALLOWED;
 420              		.loc 1 126 0
 421 018a B8000000 		mov	eax, 0
 421      00
 422 018f EB29     		jmp	.L17
 423              	.L18:
 127:utility.c     **** 
 128:utility.c     **** 	cpuid(0x8000000A, eax, ebx, ecx, edx);
 424              		.loc 1 128 0
 425 0191 B80A0000 		mov	eax, -2147483638
 425      80
 426              	#APP
 427              	# 128 "utility.c" 1
 129              		
 428              		cpuid
 429              	# 0 "" 2
 430              	#NO_APP
 431 0198 8945EC   		mov	DWORD PTR [ebp-20], eax
 432 019b 895DE8   		mov	DWORD PTR [ebp-24], ebx
 433 019e 894DE4   		mov	DWORD PTR [ebp-28], ecx
 434 01a1 8955E0   		mov	DWORD PTR [ebp-32], edx
 130:utility.c     **** 	if ((edx & CPUID_8000_000A_EDX_SVML )==0)
 435              		.loc 1 130 0
 436 01a4 8B45E0   		mov	eax, DWORD PTR [ebp-32]
 437 01a7 83E004   		and	eax, 4
 438 01aa 85C0     		test	eax, eax
 439 01ac 7507     		jne	.L19
 131:utility.c     **** 	return SVM_DISABLED_AT_BIOS_NOT_UNLOCKABLE;
 440              		.loc 1 131 0
 441 01ae B8020000 		mov	eax, 2
 441      00
 442 01b3 EB05     		jmp	.L17
 443              	.L19:
 132:utility.c     **** 	// the user must change a BIOS setting to enable SVM
 133:utility.c     **** 	else return SVM_DISABLED_WITH_KEY;
 444              		.loc 1 133 0
 445 01b5 B8030000 		mov	eax, 3
 445      00
 446              	.L17:
 134:utility.c     **** 	// SVMLock may be unlockable; consult the BIOS or TPM to obtain the key.
 135:utility.c     **** }
 447              		.loc 1 135 0
 448 01ba 8D65F4   		lea	esp, [ebp-12]
 449 01bd 5B       		pop	ebx
 450              		.cfi_restore 3
 451 01be 5E       		pop	esi
 452              		.cfi_restore 6
 453 01bf 5F       		pop	edi
 454              		.cfi_restore 7
 455 01c0 5D       		pop	ebp
 456              		.cfi_restore 5
 457              		.cfi_def_cfa 4, 4
 458 01c1 C3       		ret
 459              		.cfi_endproc
 460              	.LFE10:
 462              		.globl	FatalError
 464              	FatalError:
 465              	.LFB11:
 136:utility.c     **** 
 137:utility.c     **** void FatalError(DWORD ErrorNum)
 138:utility.c     **** {
 466              		.loc 1 138 0
 467              		.cfi_startproc
 468 01c2 55       		push	ebp
 469              		.cfi_def_cfa_offset 8
 470              		.cfi_offset 5, -8
 471 01c3 89E5     		mov	ebp, esp
 472              		.cfi_def_cfa_register 5
 139:utility.c     ****     fatalErrorNum = ErrorNum;
 473              		.loc 1 139 0
 474 01c5 8B4508   		mov	eax, DWORD PTR [ebp+8]
 475 01c8 A3000000 		mov	DWORD PTR fatalErrorNum, eax
 475      00
 476              	.L21:
 140:utility.c     **** FatalErrorLoop:
 141:utility.c     ****     goto FatalErrorLoop;
 477              		.loc 1 141 0 discriminator 1
 478 01cd EBFE     		jmp	.L21
 479              		.cfi_endproc
 480              	.LFE11:
 482              		.globl	GetMemB
 484              	GetMemB:
 485              	.LFB12:
 142:utility.c     **** }
 143:utility.c     **** 
 144:utility.c     **** BYTE GetMemB(DWORD Location, _Bool GuestMemory)
 145:utility.c     **** {
 486              		.loc 1 145 0
 487              		.cfi_startproc
 488 01cf 55       		push	ebp
 489              		.cfi_def_cfa_offset 8
 490              		.cfi_offset 5, -8
 491 01d0 89E5     		mov	ebp, esp
 492              		.cfi_def_cfa_register 5
 493 01d2 83EC28   		sub	esp, 40
 494 01d5 8B450C   		mov	eax, DWORD PTR [ebp+12]
 495 01d8 8845E4   		mov	BYTE PTR [ebp-28], al
 146:utility.c     **** 	BYTE lRetVal = 0;
 496              		.loc 1 146 0
 497 01db C645F700 		mov	BYTE PTR [ebp-9], 0
 147:utility.c     **** 	if (GuestMemory==true)
 498              		.loc 1 147 0
 499 01df 807DE400 		cmp	BYTE PTR [ebp-28], 0
 500 01e3 7415     		je	.L23
 148:utility.c     **** 		GuestMemOffset = DoNestedPageLookup(Location);
 501              		.loc 1 148 0
 502 01e5 83EC0C   		sub	esp, 12
 503 01e8 FF7508   		push	DWORD PTR [ebp+8]
 504 01eb E8FCFFFF 		call	DoNestedPageLookup
 504      FF
 505 01f0 83C410   		add	esp, 16
 506 01f3 A3000000 		mov	DWORD PTR GuestMemOffset, eax
 506      00
 507 01f8 EB08     		jmp	.L24
 508              	.L23:
 149:utility.c     **** 	else
 150:utility.c     **** 		GuestMemOffset = Location; 
 509              		.loc 1 150 0
 510 01fa 8B4508   		mov	eax, DWORD PTR [ebp+8]
 511 01fd A3000000 		mov	DWORD PTR GuestMemOffset, eax
 511      00
 512              	.L24:
 151:utility.c     **** 
 152:utility.c     **** 	__asm__(""	//Don't push EAX as our return value will be in it
 513              		.loc 1 152 0
 514 0202 8B150000 		mov	edx, DWORD PTR GuestMemOffset
 514      0000
 515              	#APP
 516              	# 152 "utility.c" 1
 153 020a 648A10   				"	mov  eax,%[location]\n"		//Move Location to EAX
 154              				"	mov  %[result], byte ptr FS:[eax]\n"	//Move byte Value to EAX
 155              				: [result] "=r" (lRetVal)
 517              			mov  eax,edx
 518              		mov  dl, byte ptr FS:[eax]
 519              	
 520              	# 0 "" 2
 521              	#NO_APP
 522 020d 8855F7   		mov	BYTE PTR [ebp-9], dl
 156:utility.c     **** 			: [location] "r" (GuestMemOffset)
 157:utility.c     **** 			:"eax"	);	
 158:utility.c     **** 	return lRetVal;
 523              		.loc 1 158 0
 524 0210 0FB645F7 		movzx	eax, BYTE PTR [ebp-9]
 159:utility.c     **** }
 525              		.loc 1 159 0
 526 0214 C9       		leave
 527              		.cfi_restore 5
 528              		.cfi_def_cfa 4, 4
 529 0215 C3       		ret
 530              		.cfi_endproc
 531              	.LFE12:
 533              		.globl	GetMemW
 535              	GetMemW:
 536              	.LFB13:
 160:utility.c     **** 
 161:utility.c     **** WORD GetMemW(DWORD Location, _Bool GuestMemory) 
 162:utility.c     **** {
 537              		.loc 1 162 0
 538              		.cfi_startproc
 539 0216 55       		push	ebp
 540              		.cfi_def_cfa_offset 8
 541              		.cfi_offset 5, -8
 542 0217 89E5     		mov	ebp, esp
 543              		.cfi_def_cfa_register 5
 544 0219 83EC28   		sub	esp, 40
 545 021c 8B450C   		mov	eax, DWORD PTR [ebp+12]
 546 021f 8845E4   		mov	BYTE PTR [ebp-28], al
 163:utility.c     **** 	WORD lRetVal = 0;
 547              		.loc 1 163 0
 548 0222 66C745F6 		mov	WORD PTR [ebp-10], 0
 548      0000
 164:utility.c     **** 	if (GuestMemory==true)
 549              		.loc 1 164 0
 550 0228 807DE400 		cmp	BYTE PTR [ebp-28], 0
 551 022c 7415     		je	.L27
 165:utility.c     **** 		GuestMemOffset = DoNestedPageLookup(Location);
 552              		.loc 1 165 0
 553 022e 83EC0C   		sub	esp, 12
 554 0231 FF7508   		push	DWORD PTR [ebp+8]
 555 0234 E8FCFFFF 		call	DoNestedPageLookup
 555      FF
 556 0239 83C410   		add	esp, 16
 557 023c A3000000 		mov	DWORD PTR GuestMemOffset, eax
 557      00
 558 0241 EB08     		jmp	.L28
 559              	.L27:
 166:utility.c     **** 	else
 167:utility.c     **** 		GuestMemOffset = Location; 
 560              		.loc 1 167 0
 561 0243 8B4508   		mov	eax, DWORD PTR [ebp+8]
 562 0246 A3000000 		mov	DWORD PTR GuestMemOffset, eax
 562      00
 563              	.L28:
 168:utility.c     **** 
 169:utility.c     **** 	__asm__(""	//Don't push EAX as our return value will be in it
 564              		.loc 1 169 0
 565 024b 8B150000 		mov	edx, DWORD PTR GuestMemOffset
 565      0000
 566              	#APP
 567              	# 169 "utility.c" 1
 170 0253 64668B10 				"	mov  eax,%[location]\n"		//Move Location to EAX
 171              				"	mov  %[result], word ptr FS:[eax]\n"	//Move byte Value to EAX
 172              				: [result] "=r" (lRetVal)
 568              			mov  eax,edx
 569              		mov  dx, word ptr FS:[eax]
 570              	
 571              	# 0 "" 2
 572              	#NO_APP
 573 0257 668955F6 		mov	WORD PTR [ebp-10], dx
 173:utility.c     **** 			: [location] "r" (GuestMemOffset)	
 174:utility.c     **** 			:"eax"	);	
 175:utility.c     **** 	return lRetVal;
 574              		.loc 1 175 0
 575 025b 0FB745F6 		movzx	eax, WORD PTR [ebp-10]
 176:utility.c     **** }
 576              		.loc 1 176 0
 577 025f C9       		leave
 578              		.cfi_restore 5
 579              		.cfi_def_cfa 4, 4
 580 0260 C3       		ret
 581              		.cfi_endproc
 582              	.LFE13:
 584              		.globl	GetMemD
 586              	GetMemD:
 587              	.LFB14:
 177:utility.c     **** 
 178:utility.c     **** DWORD GetMemD(DWORD Location, _Bool GuestMemory)
 179:utility.c     **** {
 588              		.loc 1 179 0
 589              		.cfi_startproc
 590 0261 55       		push	ebp
 591              		.cfi_def_cfa_offset 8
 592              		.cfi_offset 5, -8
 593 0262 89E5     		mov	ebp, esp
 594              		.cfi_def_cfa_register 5
 595 0264 83EC28   		sub	esp, 40
 596 0267 8B450C   		mov	eax, DWORD PTR [ebp+12]
 597 026a 8845E4   		mov	BYTE PTR [ebp-28], al
 180:utility.c     **** 	DWORD lRetVal = 0;
 598              		.loc 1 180 0
 599 026d C745F400 		mov	DWORD PTR [ebp-12], 0
 599      000000
 181:utility.c     **** 	if (GuestMemory==true)
 600              		.loc 1 181 0
 601 0274 807DE400 		cmp	BYTE PTR [ebp-28], 0
 602 0278 7415     		je	.L31
 182:utility.c     **** 		GuestMemOffset = DoNestedPageLookup(Location);
 603              		.loc 1 182 0
 604 027a 83EC0C   		sub	esp, 12
 605 027d FF7508   		push	DWORD PTR [ebp+8]
 606 0280 E8FCFFFF 		call	DoNestedPageLookup
 606      FF
 607 0285 83C410   		add	esp, 16
 608 0288 A3000000 		mov	DWORD PTR GuestMemOffset, eax
 608      00
 609 028d EB08     		jmp	.L32
 610              	.L31:
 183:utility.c     **** 	else
 184:utility.c     **** 		GuestMemOffset = Location; 
 611              		.loc 1 184 0
 612 028f 8B4508   		mov	eax, DWORD PTR [ebp+8]
 613 0292 A3000000 		mov	DWORD PTR GuestMemOffset, eax
 613      00
 614              	.L32:
 185:utility.c     **** 
 186:utility.c     **** 	__asm__(""	//Don't push EAX as our return value will be in it
 615              		.loc 1 186 0
 616 0297 8B150000 		mov	edx, DWORD PTR GuestMemOffset
 616      0000
 617              	#APP
 618              	# 186 "utility.c" 1
 187 029f 648B10   				"	mov  eax,%[location]\n"		//Move Location to EAX
 188              				"	mov  %[result], dword ptr FS:[eax]\n"	//Move byte Value to EAX
 189              				: [result] "=r" (lRetVal)
 619              			mov  eax,edx
 620              		mov  edx, dword ptr FS:[eax]
 621              	
 622              	# 0 "" 2
 623              	#NO_APP
 624 02a2 8955F4   		mov	DWORD PTR [ebp-12], edx
 190:utility.c     **** 			: [location] "r" (GuestMemOffset)	
 191:utility.c     **** 			:"eax"	);	
 192:utility.c     **** 	return lRetVal;
 625              		.loc 1 192 0
 626 02a5 8B45F4   		mov	eax, DWORD PTR [ebp-12]
 193:utility.c     **** }
 627              		.loc 1 193 0
 628 02a8 C9       		leave
 629              		.cfi_restore 5
 630              		.cfi_def_cfa 4, 4
 631 02a9 C3       		ret
 632              		.cfi_endproc
 633              	.LFE14:
 635              		.globl	SetMemB
 637              	SetMemB:
 638              	.LFB15:
 194:utility.c     **** 
 195:utility.c     **** void SetMemB(DWORD Location, BYTE Value, _Bool GuestMemory)
 196:utility.c     **** {
 639              		.loc 1 196 0
 640              		.cfi_startproc
 641 02aa 55       		push	ebp
 642              		.cfi_def_cfa_offset 8
 643              		.cfi_offset 5, -8
 644 02ab 89E5     		mov	ebp, esp
 645              		.cfi_def_cfa_register 5
 646 02ad 83EC18   		sub	esp, 24
 647 02b0 8B550C   		mov	edx, DWORD PTR [ebp+12]
 648 02b3 8B4510   		mov	eax, DWORD PTR [ebp+16]
 649 02b6 8855F4   		mov	BYTE PTR [ebp-12], dl
 650 02b9 8845F0   		mov	BYTE PTR [ebp-16], al
 197:utility.c     **** 	if (GuestMemory==true)
 651              		.loc 1 197 0
 652 02bc 807DF000 		cmp	BYTE PTR [ebp-16], 0
 653 02c0 7415     		je	.L35
 198:utility.c     **** 		GuestMemOffset = DoNestedPageLookup(Location);
 654              		.loc 1 198 0
 655 02c2 83EC0C   		sub	esp, 12
 656 02c5 FF7508   		push	DWORD PTR [ebp+8]
 657 02c8 E8FCFFFF 		call	DoNestedPageLookup
 657      FF
 658 02cd 83C410   		add	esp, 16
 659 02d0 A3000000 		mov	DWORD PTR GuestMemOffset, eax
 659      00
 660 02d5 EB08     		jmp	.L36
 661              	.L35:
 199:utility.c     **** 	else
 200:utility.c     **** 		GuestMemOffset = Location; 
 662              		.loc 1 200 0
 663 02d7 8B4508   		mov	eax, DWORD PTR [ebp+8]
 664 02da A3000000 		mov	DWORD PTR GuestMemOffset, eax
 664      00
 665              	.L36:
 201:utility.c     **** 	
 202:utility.c     **** 	__asm__("	mov  eax,%[location]\n"		//Move Location to EAX
 666              		.loc 1 202 0
 667 02df 8B150000 		mov	edx, DWORD PTR GuestMemOffset
 667      0000
 668 02e5 0FB64DF4 		movzx	ecx, BYTE PTR [ebp-12]
 669              	#APP
 670              	# 202 "utility.c" 1
 203 02eb 88CB     				"	mov  bl,%[value]\n"		//Move byte Value to EL
 204 02ed 648818   				"	mov	FS:[eax],bl\n"
 205              				: : [location] "r" (GuestMemOffset), 
 206              				    [value] "r" (Value) 
 207:utility.c     **** 			:"eax"	);	
 208:utility.c     **** }
 671              			mov  eax,edx
 672              		mov  bl,cl
 673              		mov	FS:[eax],bl
 674              	
 675              	# 0 "" 2
 676              		.loc 1 208 0
 677              	#NO_APP
 678 02f0 90       		nop
 679 02f1 C9       		leave
 680              		.cfi_restore 5
 681              		.cfi_def_cfa 4, 4
 682 02f2 C3       		ret
 683              		.cfi_endproc
 684              	.LFE15:
 686              		.globl	SetMemW
 688              	SetMemW:
 689              	.LFB16:
 209:utility.c     **** 
 210:utility.c     **** void SetMemW(DWORD Location, WORD Value, _Bool GuestMemory)
 211:utility.c     **** {
 690              		.loc 1 211 0
 691              		.cfi_startproc
 692 02f3 55       		push	ebp
 693              		.cfi_def_cfa_offset 8
 694              		.cfi_offset 5, -8
 695 02f4 89E5     		mov	ebp, esp
 696              		.cfi_def_cfa_register 5
 697 02f6 83EC18   		sub	esp, 24
 698 02f9 8B550C   		mov	edx, DWORD PTR [ebp+12]
 699 02fc 8B4510   		mov	eax, DWORD PTR [ebp+16]
 700 02ff 668955F4 		mov	WORD PTR [ebp-12], dx
 701 0303 8845F0   		mov	BYTE PTR [ebp-16], al
 212:utility.c     **** 	if (GuestMemory==true)
 702              		.loc 1 212 0
 703 0306 807DF000 		cmp	BYTE PTR [ebp-16], 0
 704 030a 7415     		je	.L38
 213:utility.c     **** 		GuestMemOffset = DoNestedPageLookup(Location);
 705              		.loc 1 213 0
 706 030c 83EC0C   		sub	esp, 12
 707 030f FF7508   		push	DWORD PTR [ebp+8]
 708 0312 E8FCFFFF 		call	DoNestedPageLookup
 708      FF
 709 0317 83C410   		add	esp, 16
 710 031a A3000000 		mov	DWORD PTR GuestMemOffset, eax
 710      00
 711 031f EB08     		jmp	.L39
 712              	.L38:
 214:utility.c     **** 	else
 215:utility.c     **** 		GuestMemOffset = Location; 
 713              		.loc 1 215 0
 714 0321 8B4508   		mov	eax, DWORD PTR [ebp+8]
 715 0324 A3000000 		mov	DWORD PTR GuestMemOffset, eax
 715      00
 716              	.L39:
 216:utility.c     **** 
 217:utility.c     **** 	__asm__("	mov  eax,%[location]\n"		//Move Location to EAX
 717              		.loc 1 217 0
 718 0329 8B150000 		mov	edx, DWORD PTR GuestMemOffset
 718      0000
 719 032f 0FB74DF4 		movzx	ecx, WORD PTR [ebp-12]
 720              	#APP
 721              	# 217 "utility.c" 1
 218 0335 6689CB   				"	mov  bx,%[value]\n"		//Move byte Value to EL
 219 0338 64668918 				"	mov	FS:[eax],bx\n"
 220              				: : [location] "r" (GuestMemOffset), 
 221              				    [value] "r" (Value) 
 222:utility.c     **** 			:"eax"	);	
 223:utility.c     **** }
 722              			mov  eax,edx
 723              		mov  bx,cx
 724              		mov	FS:[eax],bx
 725              	
 726              	# 0 "" 2
 727              		.loc 1 223 0
 728              	#NO_APP
 729 033c 90       		nop
 730 033d C9       		leave
 731              		.cfi_restore 5
 732              		.cfi_def_cfa 4, 4
 733 033e C3       		ret
 734              		.cfi_endproc
 735              	.LFE16:
 737              		.globl	SetMemD
 739              	SetMemD:
 740              	.LFB17:
 224:utility.c     **** 
 225:utility.c     **** void SetMemD(DWORD Location, DWORD Value, _Bool GuestMemory)
 226:utility.c     **** {
 741              		.loc 1 226 0
 742              		.cfi_startproc
 743 033f 55       		push	ebp
 744              		.cfi_def_cfa_offset 8
 745              		.cfi_offset 5, -8
 746 0340 89E5     		mov	ebp, esp
 747              		.cfi_def_cfa_register 5
 748 0342 83EC18   		sub	esp, 24
 749 0345 8B4510   		mov	eax, DWORD PTR [ebp+16]
 750 0348 8845F4   		mov	BYTE PTR [ebp-12], al
 227:utility.c     **** 	if (GuestMemory==true)
 751              		.loc 1 227 0
 752 034b 807DF400 		cmp	BYTE PTR [ebp-12], 0
 753 034f 7415     		je	.L41
 228:utility.c     **** 		GuestMemOffset = DoNestedPageLookup(Location);
 754              		.loc 1 228 0
 755 0351 83EC0C   		sub	esp, 12
 756 0354 FF7508   		push	DWORD PTR [ebp+8]
 757 0357 E8FCFFFF 		call	DoNestedPageLookup
 757      FF
 758 035c 83C410   		add	esp, 16
 759 035f A3000000 		mov	DWORD PTR GuestMemOffset, eax
 759      00
 760 0364 EB08     		jmp	.L42
 761              	.L41:
 229:utility.c     **** 	else
 230:utility.c     **** 		GuestMemOffset = Location; 
 762              		.loc 1 230 0
 763 0366 8B4508   		mov	eax, DWORD PTR [ebp+8]
 764 0369 A3000000 		mov	DWORD PTR GuestMemOffset, eax
 764      00
 765              	.L42:
 231:utility.c     **** 
 232:utility.c     **** 	__asm__("	mov  eax,%[location]\n"		//Move Location to EAX
 766              		.loc 1 232 0
 767 036e 8B150000 		mov	edx, DWORD PTR GuestMemOffset
 767      0000
 768 0374 8B4D0C   		mov	ecx, DWORD PTR [ebp+12]
 769              	#APP
 770              	# 232 "utility.c" 1
 233 0379 89CB     				"	mov  ebx,%[value]\n"		//Move byte Value to EL
 234 037b 648918   				"	mov	FS:[eax],ebx\n"
 235              				: : [location] "r" (GuestMemOffset), 
 236              				    [value] "r" (Value) 
 237:utility.c     **** 			:"eax"	);	
 238:utility.c     **** }
 771              			mov  eax,edx
 772              		mov  ebx,ecx
 773              		mov	FS:[eax],ebx
 774              	
 775              	# 0 "" 2
 776              		.loc 1 238 0
 777              	#NO_APP
 778 037e 90       		nop
 779 037f C9       		leave
 780              		.cfi_restore 5
 781              		.cfi_def_cfa 4, 4
 782 0380 C3       		ret
 783              		.cfi_endproc
 784              	.LFE17:
 786              		.globl	Itoa
 788              	Itoa:
 789              	.LFB18:
 239:utility.c     **** 
 240:utility.c     ****     /* The Itoa code is in the public domain */
 241:utility.c     **** char* Itoa(int value, char* str, int radix) 
 242:utility.c     **** {
 790              		.loc 1 242 0
 791              		.cfi_startproc
 792 0381 55       		push	ebp
 793              		.cfi_def_cfa_offset 8
 794              		.cfi_offset 5, -8
 795 0382 89E5     		mov	ebp, esp
 796              		.cfi_def_cfa_register 5
 797 0384 53       		push	ebx
 798 0385 83EC20   		sub	esp, 32
 799              		.cfi_offset 3, -12
 243:utility.c     ****     static char dig[] =
 244:utility.c     ****     "0123456789"
 245:utility.c     ****     "abcdefghijklmnopqrstuvwxyz";
 246:utility.c     ****     int n = 0, neg = 0;
 800              		.loc 1 246 0
 801 0388 C745F800 		mov	DWORD PTR [ebp-8], 0
 801      000000
 802 038f C745F400 		mov	DWORD PTR [ebp-12], 0
 802      000000
 247:utility.c     ****     unsigned int v;
 248:utility.c     ****     char* p, *q;
 249:utility.c     ****     char c;
 250:utility.c     **** 
 251:utility.c     ****     if (radix == 10 && value < 0) {
 803              		.loc 1 251 0
 804 0396 837D100A 		cmp	DWORD PTR [ebp+16], 10
 805 039a 7510     		jne	.L44
 806              		.loc 1 251 0 is_stmt 0 discriminator 1
 807 039c 837D0800 		cmp	DWORD PTR [ebp+8], 0
 808 03a0 790A     		jns	.L44
 252:utility.c     ****         value = -value;
 809              		.loc 1 252 0 is_stmt 1
 810 03a2 F75D08   		neg	DWORD PTR [ebp+8]
 253:utility.c     ****         neg = 1;
 811              		.loc 1 253 0
 812 03a5 C745F401 		mov	DWORD PTR [ebp-12], 1
 812      000000
 813              	.L44:
 254:utility.c     ****     }
 255:utility.c     ****     v = value;
 814              		.loc 1 255 0
 815 03ac 8B4508   		mov	eax, DWORD PTR [ebp+8]
 816 03af 8945F0   		mov	DWORD PTR [ebp-16], eax
 817              	.L45:
 256:utility.c     ****     do {
 257:utility.c     ****         str[n++] = dig[v%radix];
 818              		.loc 1 257 0 discriminator 1
 819 03b2 8B45F8   		mov	eax, DWORD PTR [ebp-8]
 820 03b5 8D5001   		lea	edx, [eax+1]
 821 03b8 8955F8   		mov	DWORD PTR [ebp-8], edx
 822 03bb 89C2     		mov	edx, eax
 823 03bd 8B450C   		mov	eax, DWORD PTR [ebp+12]
 824 03c0 8D0C02   		lea	ecx, [edx+eax]
 825 03c3 8B5D10   		mov	ebx, DWORD PTR [ebp+16]
 826 03c6 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 827 03c9 BA000000 		mov	edx, 0
 827      00
 828 03ce F7F3     		div	ebx
 829 03d0 89D0     		mov	eax, edx
 830 03d2 0FB68000 		movzx	eax, BYTE PTR dig.2035[eax]
 830      000000
 831 03d9 8801     		mov	BYTE PTR [ecx], al
 258:utility.c     ****         v /= radix;
 832              		.loc 1 258 0 discriminator 1
 833 03db 8B4D10   		mov	ecx, DWORD PTR [ebp+16]
 834 03de 8B45F0   		mov	eax, DWORD PTR [ebp-16]
 835 03e1 BA000000 		mov	edx, 0
 835      00
 836 03e6 F7F1     		div	ecx
 837 03e8 8945F0   		mov	DWORD PTR [ebp-16], eax
 259:utility.c     ****     } while (v);
 838              		.loc 1 259 0 discriminator 1
 839 03eb 837DF000 		cmp	DWORD PTR [ebp-16], 0
 840 03ef 75C1     		jne	.L45
 260:utility.c     ****     if (neg)
 841              		.loc 1 260 0
 842 03f1 837DF400 		cmp	DWORD PTR [ebp-12], 0
 843 03f5 7413     		je	.L46
 261:utility.c     ****         str[n++] = '-';
 844              		.loc 1 261 0
 845 03f7 8B45F8   		mov	eax, DWORD PTR [ebp-8]
 846 03fa 8D5001   		lea	edx, [eax+1]
 847 03fd 8955F8   		mov	DWORD PTR [ebp-8], edx
 848 0400 89C2     		mov	edx, eax
 849 0402 8B450C   		mov	eax, DWORD PTR [ebp+12]
 850 0405 01D0     		add	eax, edx
 851 0407 C6002D   		mov	BYTE PTR [eax], 45
 852              	.L46:
 262:utility.c     ****     str[n] = '\0';
 853              		.loc 1 262 0
 854 040a 8B55F8   		mov	edx, DWORD PTR [ebp-8]
 855 040d 8B450C   		mov	eax, DWORD PTR [ebp+12]
 856 0410 01D0     		add	eax, edx
 857 0412 C60000   		mov	BYTE PTR [eax], 0
 263:utility.c     ****     for (p = str, q = p + (n-1); p < q; ++p, --q)
 858              		.loc 1 263 0
 859 0415 8B450C   		mov	eax, DWORD PTR [ebp+12]
 860 0418 8945EC   		mov	DWORD PTR [ebp-20], eax
 861 041b 8B45F8   		mov	eax, DWORD PTR [ebp-8]
 862 041e 8D50FF   		lea	edx, [eax-1]
 863 0421 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 864 0424 01D0     		add	eax, edx
 865 0426 8945E8   		mov	DWORD PTR [ebp-24], eax
 866 0429 EB25     		jmp	.L47
 867              	.L48:
 264:utility.c     ****         c = *p, *p = *q, *q = c;
 868              		.loc 1 264 0 discriminator 3
 869 042b 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 870 042e 0FB600   		movzx	eax, BYTE PTR [eax]
 871 0431 8845E7   		mov	BYTE PTR [ebp-25], al
 872 0434 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 873 0437 0FB610   		movzx	edx, BYTE PTR [eax]
 874 043a 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 875 043d 8810     		mov	BYTE PTR [eax], dl
 876 043f 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 877 0442 0FB655E7 		movzx	edx, BYTE PTR [ebp-25]
 878 0446 8810     		mov	BYTE PTR [eax], dl
 263:utility.c     ****     for (p = str, q = p + (n-1); p < q; ++p, --q)
 879              		.loc 1 263 0 discriminator 3
 880 0448 8345EC01 		add	DWORD PTR [ebp-20], 1
 881 044c 836DE801 		sub	DWORD PTR [ebp-24], 1
 882              	.L47:
 263:utility.c     ****     for (p = str, q = p + (n-1); p < q; ++p, --q)
 883              		.loc 1 263 0 is_stmt 0 discriminator 1
 884 0450 8B45EC   		mov	eax, DWORD PTR [ebp-20]
 885 0453 3B45E8   		cmp	eax, DWORD PTR [ebp-24]
 886 0456 72D3     		jb	.L48
 265:utility.c     ****     return str;
 887              		.loc 1 265 0 is_stmt 1
 888 0458 8B450C   		mov	eax, DWORD PTR [ebp+12]
 266:utility.c     **** }
 889              		.loc 1 266 0
 890 045b 83C420   		add	esp, 32
 891 045e 5B       		pop	ebx
 892              		.cfi_restore 3
 893 045f 5D       		pop	ebp
 894              		.cfi_restore 5
 895              		.cfi_def_cfa 4, 4
 896 0460 C3       		ret
 897              		.cfi_endproc
 898              	.LFE18:
 900              		.globl	setup_pit_channel_0
 902              	setup_pit_channel_0:
 903              	.LFB19:
 267:utility.c     **** 
 268:utility.c     **** void setup_pit_channel_0( WORD frequency )
 269:utility.c     **** {
 904              		.loc 1 269 0
 905              		.cfi_startproc
 906 0461 55       		push	ebp
 907              		.cfi_def_cfa_offset 8
 908              		.cfi_offset 5, -8
 909 0462 89E5     		mov	ebp, esp
 910              		.cfi_def_cfa_register 5
 911 0464 83EC14   		sub	esp, 20
 912 0467 8B4508   		mov	eax, DWORD PTR [ebp+8]
 913 046a 668945EC 		mov	WORD PTR [ebp-20], ax
 270:utility.c     ****    // Variables
 271:utility.c     ****    unsigned short counter;
 272:utility.c     **** 
 273:utility.c     ****    // Calculate Counter
 274:utility.c     ****    counter = 0x1234DD / frequency;
 914              		.loc 1 274 0
 915 046e 0FB74DEC 		movzx	ecx, WORD PTR [ebp-20]
 916 0472 B8DD3412 		mov	eax, 1193181
 916      00
 917 0477 99       		cdq
 918 0478 F7F9     		idiv	ecx
 919 047a 668945FE 		mov	WORD PTR [ebp-2], ax
 275:utility.c     **** 
 276:utility.c     ****    // Setup Mode
 277:utility.c     ****    outb( 0x43, 0x34 );
 920              		.loc 1 277 0
 921 047e 6A34     		push	52
 922 0480 6A43     		push	67
 923 0482 E8FCFFFF 		call	outb
 923      FF
 924 0487 83C408   		add	esp, 8
 278:utility.c     **** 
 279:utility.c     ****    // Send Low Count
 280:utility.c     ****    outb( 0x40, (counter % 256) );
 925              		.loc 1 280 0
 926 048a 0FB745FE 		movzx	eax, WORD PTR [ebp-2]
 927 048e 0FB6C0   		movzx	eax, al
 928 0491 50       		push	eax
 929 0492 6A40     		push	64
 930 0494 E8FCFFFF 		call	outb
 930      FF
 931 0499 83C408   		add	esp, 8
 281:utility.c     **** 
 282:utility.c     ****    // Send High Count
 283:utility.c     ****    outb( 0x40, (counter / 256) );
 932              		.loc 1 283 0
 933 049c 0FB745FE 		movzx	eax, WORD PTR [ebp-2]
 934 04a0 66C1E808 		shr	ax, 8
 935 04a4 0FB6C0   		movzx	eax, al
 936 04a7 50       		push	eax
 937 04a8 6A40     		push	64
 938 04aa E8FCFFFF 		call	outb
 938      FF
 939 04af 83C408   		add	esp, 8
 284:utility.c     **** }
 940              		.loc 1 284 0
 941 04b2 90       		nop
 942 04b3 C9       		leave
 943              		.cfi_restore 5
 944              		.cfi_def_cfa 4, 4
 945 04b4 C3       		ret
 946              		.cfi_endproc
 947              	.LFE19:
 949              		.globl	cpu_write_msr
 951              	cpu_write_msr:
 952              	.LFB20:
 285:utility.c     **** 
 286:utility.c     **** void cpu_write_msr(DWORD msr, QWORD value)
 287:utility.c     **** {
 953              		.loc 1 287 0
 954              		.cfi_startproc
 955 04b5 55       		push	ebp
 956              		.cfi_def_cfa_offset 8
 957              		.cfi_offset 5, -8
 958 04b6 89E5     		mov	ebp, esp
 959              		.cfi_def_cfa_register 5
 960 04b8 83EC18   		sub	esp, 24
 961 04bb 8B450C   		mov	eax, DWORD PTR [ebp+12]
 962 04be 8945E8   		mov	DWORD PTR [ebp-24], eax
 963 04c1 8B4510   		mov	eax, DWORD PTR [ebp+16]
 964 04c4 8945EC   		mov	DWORD PTR [ebp-20], eax
 288:utility.c     ****         DWORD a, d;
 289:utility.c     **** 
 290:utility.c     ****         /* RDX contains the high order 32-bits */
 291:utility.c     ****         d = value >> 32;
 965              		.loc 1 291 0
 966 04c7 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 967 04ca 8B55EC   		mov	edx, DWORD PTR [ebp-20]
 968 04cd 89D0     		mov	eax, edx
 969 04cf 31D2     		xor	edx, edx
 970 04d1 8945FC   		mov	DWORD PTR [ebp-4], eax
 292:utility.c     **** 
 293:utility.c     ****         /* RAX contains low order */
 294:utility.c     ****         a = value & 0xFFFFFFFFUL;
 971              		.loc 1 294 0
 972 04d4 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 973 04d7 8945F8   		mov	DWORD PTR [ebp-8], eax
 295:utility.c     **** 
 296:utility.c     ****         asm volatile ("wrmsr\n\t"
 974              		.loc 1 296 0
 975 04da 8B45F8   		mov	eax, DWORD PTR [ebp-8]
 976 04dd 8B55FC   		mov	edx, DWORD PTR [ebp-4]
 977 04e0 8B4D08   		mov	ecx, DWORD PTR [ebp+8]
 978              	#APP
 979              	# 296 "utility.c" 1
 297              	                      ::"a"(a),"d"(d),"c"(msr));
 298              	}
 980              		wrmsr
 981              		
 982              	# 0 "" 2
 983              		.loc 1 298 0
 984              	#NO_APP
 985 04e5 90       		nop
 986 04e6 C9       		leave
 987              		.cfi_restore 5
 988              		.cfi_def_cfa 4, 4
 989 04e7 C3       		ret
 990              		.cfi_endproc
 991              	.LFE20:
 993              		.globl	cpu_read_msr
 995              	cpu_read_msr:
 996              	.LFB21:
 299:utility.c     **** 
 300:utility.c     **** QWORD cpu_read_msr(DWORD msr)
 301:utility.c     **** {
 997              		.loc 1 301 0
 998              		.cfi_startproc
 999 04e8 55       		push	ebp
 1000              		.cfi_def_cfa_offset 8
 1001              		.cfi_offset 5, -8
 1002 04e9 89E5     		mov	ebp, esp
 1003              		.cfi_def_cfa_register 5
 1004 04eb 57       		push	edi
 1005 04ec 56       		push	esi
 1006 04ed 53       		push	ebx
 1007 04ee 83EC1C   		sub	esp, 28
 1008              		.cfi_offset 7, -12
 1009              		.cfi_offset 6, -16
 1010              		.cfi_offset 3, -20
 302:utility.c     ****         DWORD a, d;
 303:utility.c     **** 
 304:utility.c     ****         asm volatile ("rdmsr\n\t"
 1011              		.loc 1 304 0
 1012 04f1 8B4508   		mov	eax, DWORD PTR [ebp+8]
 1013 04f4 89C1     		mov	ecx, eax
 1014              	#APP
 1015              	# 304 "utility.c" 1
 305              	                      :"=a"(a),"=d"(d)
 306              	                      :"c"(msr)
 1016              		rdmsr
 1017              		
 1018              	# 0 "" 2
 1019              	#NO_APP
 1020 04f8 8945EC   		mov	DWORD PTR [ebp-20], eax
 1021 04fb 8955E8   		mov	DWORD PTR [ebp-24], edx
 307:utility.c     ****                       :"rbx");
 308:utility.c     **** 
 309:utility.c     ****         return (QWORD)(((QWORD)d << 32)
 1022              		.loc 1 309 0
 1023 04fe 8B45E8   		mov	eax, DWORD PTR [ebp-24]
 1024 0501 BA000000 		mov	edx, 0
 1024      00
 1025 0506 89C2     		mov	edx, eax
 1026 0508 B8000000 		mov	eax, 0
 1026      00
 1027 050d 8B4DEC   		mov	ecx, DWORD PTR [ebp-20]
 1028 0510 BB000000 		mov	ebx, 0
 1028      00
 1029 0515 8945D8   		mov	DWORD PTR [ebp-40], eax
 1030 0518 8955DC   		mov	DWORD PTR [ebp-36], edx
 1031 051b 09C8     		or	eax, ecx
 1032 051d 89C6     		mov	esi, eax
 1033 051f 8B45DC   		mov	eax, DWORD PTR [ebp-36]
 1034 0522 09D8     		or	eax, ebx
 1035 0524 89C7     		mov	edi, eax
 1036 0526 89F0     		mov	eax, esi
 1037 0528 89FA     		mov	edx, edi
 310:utility.c     ****                      | (a & 0xFFFFFFFFUL));
 311:utility.c     **** }
 1038              		.loc 1 311 0
 1039 052a 83C41C   		add	esp, 28
 1040 052d 5B       		pop	ebx
 1041              		.cfi_restore 3
 1042 052e 5E       		pop	esi
 1043              		.cfi_restore 6
 1044 052f 5F       		pop	edi
 1045              		.cfi_restore 7
 1046 0530 5D       		pop	ebp
 1047              		.cfi_restore 5
 1048              		.cfi_def_cfa 4, 4
 1049 0531 C3       		ret
 1050              		.cfi_endproc
 1051              	.LFE21:
 1053              		.data
 1054              		.align 32
 1057              	dig.2035:
 1058 0000 30313233 		.string	"0123456789abcdefghijklmnopqrstuvwxyz"
 1058      34353637 
 1058      38396162 
 1058      63646566 
 1058      6768696A 
 1059              		.text
 1060              	.Letext0:
 1061              		.file 2 "types.h"
 1062              		.file 3 "xen_types.h"
 1063              		.file 4 "x86_architecture.h"
 1064              		.file 5 "vmcb.h"
 1065              		.file 6 "host.h"
 1066              		.file 7 "guest.h"
 1067              		.file 8 "visor_main.h"
 1068              		.file 9 "isr_wrapper.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 utility.c
     /tmp/ccb2vt7W.s:4      .text:0000000000000000 .Ltext0
                            *COM*:0000000000000002 _exception_number
                            *COM*:0000000000000002 _exc_CS
                            *COM*:0000000000000002 _exc_IP
                            *COM*:0000000000000044 vhost
                            *COM*:000000000000001c guest
                            *COM*:0000000000000038 GuestRegisters
                            *COM*:0000000000000008 host
     /tmp/ccb2vt7W.s:17     .bss:0000000000000000 GuestMemOffset
     /tmp/ccb2vt7W.s:22     .text:0000000000000000 RetrieveStartModuleDiskCHSValues
     /tmp/ccb2vt7W.s:23     .text:0000000000000000 .LFB0
     /tmp/ccb2vt7W.s:69     .text:000000000000003b .LFE0
     /tmp/ccb2vt7W.s:73     .text:000000000000003b CopyMemory
     /tmp/ccb2vt7W.s:74     .text:000000000000003b .LFB1
     /tmp/ccb2vt7W.s:103    .text:0000000000000054 .LFE1
     /tmp/ccb2vt7W.s:107    .text:0000000000000054 ZeroMemory
     /tmp/ccb2vt7W.s:108    .text:0000000000000054 .LFB2
     /tmp/ccb2vt7W.s:136    .text:000000000000006c .LFE2
     /tmp/ccb2vt7W.s:140    .text:000000000000006c outb
     /tmp/ccb2vt7W.s:141    .text:000000000000006c .LFB3
     /tmp/ccb2vt7W.s:169    .text:000000000000008b .LFE3
     /tmp/ccb2vt7W.s:173    .text:000000000000008b outw
     /tmp/ccb2vt7W.s:174    .text:000000000000008b .LFB4
     /tmp/ccb2vt7W.s:202    .text:00000000000000ac .LFE4
     /tmp/ccb2vt7W.s:206    .text:00000000000000ac outd
     /tmp/ccb2vt7W.s:207    .text:00000000000000ac .LFB5
     /tmp/ccb2vt7W.s:233    .text:00000000000000c4 .LFE5
     /tmp/ccb2vt7W.s:237    .text:00000000000000c4 inb
     /tmp/ccb2vt7W.s:238    .text:00000000000000c4 .LFB6
     /tmp/ccb2vt7W.s:266    .text:00000000000000e1 .LFE6
     /tmp/ccb2vt7W.s:270    .text:00000000000000e1 inw
     /tmp/ccb2vt7W.s:271    .text:00000000000000e1 .LFB7
     /tmp/ccb2vt7W.s:299    .text:0000000000000100 .LFE7
     /tmp/ccb2vt7W.s:303    .text:0000000000000100 ind
     /tmp/ccb2vt7W.s:304    .text:0000000000000100 .LFB8
     /tmp/ccb2vt7W.s:332    .text:000000000000011c .LFE8
     /tmp/ccb2vt7W.s:336    .text:000000000000011c rdmsr
     /tmp/ccb2vt7W.s:337    .text:000000000000011c .LFB9
     /tmp/ccb2vt7W.s:365    .text:0000000000000137 .LFE9
     /tmp/ccb2vt7W.s:369    .text:0000000000000137 SVMCanBeEnabled
     /tmp/ccb2vt7W.s:370    .text:0000000000000137 .LFB10
     /tmp/ccb2vt7W.s:404    .text:0000000000000164 .L16
     /tmp/ccb2vt7W.s:446    .text:00000000000001ba .L17
     /tmp/ccb2vt7W.s:423    .text:0000000000000191 .L18
     /tmp/ccb2vt7W.s:443    .text:00000000000001b5 .L19
     /tmp/ccb2vt7W.s:460    .text:00000000000001c2 .LFE10
     /tmp/ccb2vt7W.s:464    .text:00000000000001c2 FatalError
     /tmp/ccb2vt7W.s:465    .text:00000000000001c2 .LFB11
     /tmp/ccb2vt7W.s:476    .text:00000000000001cd .L21
     /tmp/ccb2vt7W.s:480    .text:00000000000001cf .LFE11
     /tmp/ccb2vt7W.s:484    .text:00000000000001cf GetMemB
     /tmp/ccb2vt7W.s:485    .text:00000000000001cf .LFB12
     /tmp/ccb2vt7W.s:508    .text:00000000000001fa .L23
     /tmp/ccb2vt7W.s:512    .text:0000000000000202 .L24
     /tmp/ccb2vt7W.s:531    .text:0000000000000216 .LFE12
     /tmp/ccb2vt7W.s:535    .text:0000000000000216 GetMemW
     /tmp/ccb2vt7W.s:536    .text:0000000000000216 .LFB13
     /tmp/ccb2vt7W.s:559    .text:0000000000000243 .L27
     /tmp/ccb2vt7W.s:563    .text:000000000000024b .L28
     /tmp/ccb2vt7W.s:582    .text:0000000000000261 .LFE13
     /tmp/ccb2vt7W.s:586    .text:0000000000000261 GetMemD
     /tmp/ccb2vt7W.s:587    .text:0000000000000261 .LFB14
     /tmp/ccb2vt7W.s:610    .text:000000000000028f .L31
     /tmp/ccb2vt7W.s:614    .text:0000000000000297 .L32
     /tmp/ccb2vt7W.s:633    .text:00000000000002aa .LFE14
     /tmp/ccb2vt7W.s:637    .text:00000000000002aa SetMemB
     /tmp/ccb2vt7W.s:638    .text:00000000000002aa .LFB15
     /tmp/ccb2vt7W.s:661    .text:00000000000002d7 .L35
     /tmp/ccb2vt7W.s:665    .text:00000000000002df .L36
     /tmp/ccb2vt7W.s:684    .text:00000000000002f3 .LFE15
     /tmp/ccb2vt7W.s:688    .text:00000000000002f3 SetMemW
     /tmp/ccb2vt7W.s:689    .text:00000000000002f3 .LFB16
     /tmp/ccb2vt7W.s:712    .text:0000000000000321 .L38
     /tmp/ccb2vt7W.s:716    .text:0000000000000329 .L39
     /tmp/ccb2vt7W.s:735    .text:000000000000033f .LFE16
     /tmp/ccb2vt7W.s:739    .text:000000000000033f SetMemD
     /tmp/ccb2vt7W.s:740    .text:000000000000033f .LFB17
     /tmp/ccb2vt7W.s:761    .text:0000000000000366 .L41
     /tmp/ccb2vt7W.s:765    .text:000000000000036e .L42
     /tmp/ccb2vt7W.s:784    .text:0000000000000381 .LFE17
     /tmp/ccb2vt7W.s:788    .text:0000000000000381 Itoa
     /tmp/ccb2vt7W.s:789    .text:0000000000000381 .LFB18
     /tmp/ccb2vt7W.s:813    .text:00000000000003ac .L44
     /tmp/ccb2vt7W.s:817    .text:00000000000003b2 .L45
     /tmp/ccb2vt7W.s:1057   .data:0000000000000000 dig.2035
     /tmp/ccb2vt7W.s:852    .text:000000000000040a .L46
     /tmp/ccb2vt7W.s:882    .text:0000000000000450 .L47
     /tmp/ccb2vt7W.s:867    .text:000000000000042b .L48
     /tmp/ccb2vt7W.s:898    .text:0000000000000461 .LFE18
     /tmp/ccb2vt7W.s:902    .text:0000000000000461 setup_pit_channel_0
     /tmp/ccb2vt7W.s:903    .text:0000000000000461 .LFB19
     /tmp/ccb2vt7W.s:947    .text:00000000000004b5 .LFE19
     /tmp/ccb2vt7W.s:951    .text:00000000000004b5 cpu_write_msr
     /tmp/ccb2vt7W.s:952    .text:00000000000004b5 .LFB20
     /tmp/ccb2vt7W.s:991    .text:00000000000004e8 .LFE20
     /tmp/ccb2vt7W.s:995    .text:00000000000004e8 cpu_read_msr
     /tmp/ccb2vt7W.s:996    .text:00000000000004e8 .LFB21
     /tmp/ccb2vt7W.s:1051   .text:0000000000000532 .LFE21
     /tmp/ccb2vt7W.s:1060   .text:0000000000000532 .Letext0
     /tmp/ccb2vt7W.s:1070   .debug_info:0000000000000000 .Ldebug_info0
     /tmp/ccb2vt7W.s:3149   .debug_abbrev:0000000000000000 .Ldebug_abbrev0
     /tmp/ccb2vt7W.s:4108   .debug_str:000000000000047d .LASF182
     /tmp/ccb2vt7W.s:3884   .debug_str:0000000000000043 .LASF183
     /tmp/ccb2vt7W.s:4010   .debug_str:0000000000000277 .LASF184
     /tmp/ccb2vt7W.s:3868   .debug_line:0000000000000000 .Ldebug_line0
     /tmp/ccb2vt7W.s:4070   .debug_str:00000000000003ba .LASF0
     /tmp/ccb2vt7W.s:4188   .debug_str:0000000000000641 .LASF2
     /tmp/ccb2vt7W.s:4076   .debug_str:00000000000003cf .LASF1
     /tmp/ccb2vt7W.s:4218   .debug_str:00000000000006e6 .LASF3
     /tmp/ccb2vt7W.s:3962   .debug_str:00000000000001a9 .LASF4
     /tmp/ccb2vt7W.s:4172   .debug_str:00000000000005ea .LASF5
     /tmp/ccb2vt7W.s:4134   .debug_str:0000000000000540 .LASF6
     /tmp/ccb2vt7W.s:3966   .debug_str:00000000000001b9 .LASF7
     /tmp/ccb2vt7W.s:4216   .debug_str:00000000000006da .LASF8
     /tmp/ccb2vt7W.s:4174   .debug_str:00000000000005fc .LASF9
     /tmp/ccb2vt7W.s:4116   .debug_str:00000000000004ef .LASF10
     /tmp/ccb2vt7W.s:4012   .debug_str:000000000000029b .LASF11
     /tmp/ccb2vt7W.s:4050   .debug_str:0000000000000343 .LASF12
     /tmp/ccb2vt7W.s:3890   .debug_str:000000000000005e .LASF13
     /tmp/ccb2vt7W.s:4054   .debug_str:0000000000000358 .LASF14
     /tmp/ccb2vt7W.s:4112   .debug_str:00000000000004df .LASF15
     /tmp/ccb2vt7W.s:4044   .debug_str:000000000000032f .LASF16
     /tmp/ccb2vt7W.s:4048   .debug_str:000000000000033b .LASF17
     /tmp/ccb2vt7W.s:4096   .debug_str:0000000000000437 .LASF18
     /tmp/ccb2vt7W.s:3936   .debug_str:000000000000014c .LASF19
     /tmp/ccb2vt7W.s:4144   .debug_str:000000000000055e .LASF20
     /tmp/ccb2vt7W.s:4186   .debug_str:000000000000063c .LASF21
     /tmp/ccb2vt7W.s:3912   .debug_str:00000000000000d9 .LASF22
     /tmp/ccb2vt7W.s:4122   .debug_str:0000000000000509 .LASF23
     /tmp/ccb2vt7W.s:4026   .debug_str:00000000000002d6 .LASF24
     /tmp/ccb2vt7W.s:4046   .debug_str:0000000000000334 .LASF25
     /tmp/ccb2vt7W.s:4062   .debug_str:0000000000000381 .LASF26
     /tmp/ccb2vt7W.s:4036   .debug_str:000000000000030b .LASF44
     /tmp/ccb2vt7W.s:3980   .debug_str:00000000000001f4 .LASF27
     /tmp/ccb2vt7W.s:3908   .debug_str:00000000000000c9 .LASF28
     /tmp/ccb2vt7W.s:3956   .debug_str:0000000000000191 .LASF29
     /tmp/ccb2vt7W.s:3968   .debug_str:00000000000001d0 .LASF30
     /tmp/ccb2vt7W.s:3880   .debug_str:000000000000002e .LASF31
     /tmp/ccb2vt7W.s:3964   .debug_str:00000000000001af .LASF32
     /tmp/ccb2vt7W.s:4074   .debug_str:00000000000003c4 .LASF33
     /tmp/ccb2vt7W.s:4198   .debug_str:0000000000000683 .LASF34
     /tmp/ccb2vt7W.s:4038   .debug_str:0000000000000317 .LASF35
     /tmp/ccb2vt7W.s:4004   .debug_str:000000000000025d .LASF36
     /tmp/ccb2vt7W.s:4200   .debug_str:0000000000000689 .LASF37
     /tmp/ccb2vt7W.s:4150   .debug_str:0000000000000571 .LASF38
     /tmp/ccb2vt7W.s:4202   .debug_str:000000000000068f .LASF39
     /tmp/ccb2vt7W.s:4204   .debug_str:0000000000000695 .LASF40
     /tmp/ccb2vt7W.s:3876   .debug_str:0000000000000021 .LASF41
     /tmp/ccb2vt7W.s:3994   .debug_str:000000000000023e .LASF42
     /tmp/ccb2vt7W.s:4114   .debug_str:00000000000004e5 .LASF43
     /tmp/ccb2vt7W.s:3924   .debug_str:0000000000000111 .LASF45
     /tmp/ccb2vt7W.s:4126   .debug_str:000000000000051b .LASF46
     /tmp/ccb2vt7W.s:3904   .debug_str:00000000000000af .LASF47
     /tmp/ccb2vt7W.s:4030   .debug_str:00000000000002e1 .LASF48
     /tmp/ccb2vt7W.s:4080   .debug_str:00000000000003e0 .LASF49
     /tmp/ccb2vt7W.s:3872   .debug_str:0000000000000008 .LASF50
     /tmp/ccb2vt7W.s:3932   .debug_str:0000000000000140 .LASF51
     /tmp/ccb2vt7W.s:3934   .debug_str:0000000000000146 .LASF52
     /tmp/ccb2vt7W.s:3946   .debug_str:000000000000016d .LASF53
     /tmp/ccb2vt7W.s:3938   .debug_str:0000000000000155 .LASF54
     /tmp/ccb2vt7W.s:3940   .debug_str:000000000000015b .LASF55
     /tmp/ccb2vt7W.s:3942   .debug_str:0000000000000161 .LASF56
     /tmp/ccb2vt7W.s:4154   .debug_str:000000000000058a .LASF57
     /tmp/ccb2vt7W.s:4184   .debug_str:000000000000062e .LASF58
     /tmp/ccb2vt7W.s:3894   .debug_str:0000000000000078 .LASF59
     /tmp/ccb2vt7W.s:4104   .debug_str:0000000000000466 .LASF60
     /tmp/ccb2vt7W.s:4078   .debug_str:00000000000003d4 .LASF61
     /tmp/ccb2vt7W.s:3944   .debug_str:0000000000000167 .LASF62
     /tmp/ccb2vt7W.s:4110   .debug_str:00000000000004d9 .LASF63
     /tmp/ccb2vt7W.s:3896   .debug_str:0000000000000083 .LASF64
     /tmp/ccb2vt7W.s:4238   .debug_str:0000000000000758 .LASF65
     /tmp/ccb2vt7W.s:4236   .debug_str:000000000000074e .LASF66
     /tmp/ccb2vt7W.s:4022   .debug_str:00000000000002c1 .LASF67
     /tmp/ccb2vt7W.s:4156   .debug_str:0000000000000597 .LASF68
     /tmp/ccb2vt7W.s:3900   .debug_str:000000000000009c .LASF69
     /tmp/ccb2vt7W.s:3950   .debug_str:0000000000000179 .LASF70
     /tmp/ccb2vt7W.s:4084   .debug_str:00000000000003fb .LASF71
     /tmp/ccb2vt7W.s:4120   .debug_str:00000000000004fe .LASF72
     /tmp/ccb2vt7W.s:3906   .debug_str:00000000000000bd .LASF73
     /tmp/ccb2vt7W.s:4212   .debug_str:00000000000006c1 .LASF74
     /tmp/ccb2vt7W.s:3948   .debug_str:0000000000000173 .LASF75
     /tmp/ccb2vt7W.s:3958   .debug_str:0000000000000196 .LASF76
     /tmp/ccb2vt7W.s:4002   .debug_str:0000000000000256 .LASF77
     /tmp/ccb2vt7W.s:4032   .debug_str:00000000000002f6 .LASF78
     /tmp/ccb2vt7W.s:3978   .debug_str:00000000000001ef .LASF79
     /tmp/ccb2vt7W.s:4072   .debug_str:00000000000003bf .LASF80
     /tmp/ccb2vt7W.s:3970   .debug_str:00000000000001d7 .LASF81
     /tmp/ccb2vt7W.s:3972   .debug_str:00000000000001dd .LASF82
     /tmp/ccb2vt7W.s:3974   .debug_str:00000000000001e3 .LASF83
     /tmp/ccb2vt7W.s:3878   .debug_str:0000000000000029 .LASF84
     /tmp/ccb2vt7W.s:3976   .debug_str:00000000000001e9 .LASF85
     /tmp/ccb2vt7W.s:4086   .debug_str:0000000000000404 .LASF86
     /tmp/ccb2vt7W.s:4016   .debug_str:00000000000002af .LASF87
     /tmp/ccb2vt7W.s:4018   .debug_str:00000000000002b5 .LASF88
     /tmp/ccb2vt7W.s:3998   .debug_str:000000000000024b .LASF89
     /tmp/ccb2vt7W.s:3914   .debug_str:00000000000000de .LASF90
     /tmp/ccb2vt7W.s:3992   .debug_str:0000000000000238 .LASF91
     /tmp/ccb2vt7W.s:4082   .debug_str:00000000000003f4 .LASF92
     /tmp/ccb2vt7W.s:3960   .debug_str:000000000000019e .LASF93
     /tmp/ccb2vt7W.s:4102   .debug_str:000000000000045a .LASF94
     /tmp/ccb2vt7W.s:4040   .debug_str:000000000000031c .LASF95
     /tmp/ccb2vt7W.s:3920   .debug_str:00000000000000fc .LASF96
     /tmp/ccb2vt7W.s:4136   .debug_str:0000000000000546 .LASF97
     /tmp/ccb2vt7W.s:4138   .debug_str:000000000000054c .LASF98
     /tmp/ccb2vt7W.s:4140   .debug_str:0000000000000552 .LASF99
     /tmp/ccb2vt7W.s:4142   .debug_str:0000000000000558 .LASF100
     /tmp/ccb2vt7W.s:4162   .debug_str:00000000000005ae .LASF101
     /tmp/ccb2vt7W.s:3928   .debug_str:000000000000012c .LASF102
     /tmp/ccb2vt7W.s:4166   .debug_str:00000000000005c3 .LASF103
     /tmp/ccb2vt7W.s:4176   .debug_str:0000000000000601 .LASF104
     /tmp/ccb2vt7W.s:4014   .debug_str:00000000000002a1 .LASF105
     /tmp/ccb2vt7W.s:4152   .debug_str:000000000000057e .LASF106
     /tmp/ccb2vt7W.s:3982   .debug_str:00000000000001f9 .LASF107
     /tmp/ccb2vt7W.s:4170   .debug_str:00000000000005e1 .LASF108
     /tmp/ccb2vt7W.s:4098   .debug_str:0000000000000440 .LASF109
     /tmp/ccb2vt7W.s:3952   .debug_str:000000000000017f .LASF110
     /tmp/ccb2vt7W.s:4222   .debug_str:0000000000000701 .LASF111
     /tmp/ccb2vt7W.s:4024   .debug_str:00000000000002cb .LASF112
     /tmp/ccb2vt7W.s:4100   .debug_str:000000000000044b .LASF113
     /tmp/ccb2vt7W.s:4234   .debug_str:0000000000000744 .LASF114
     /tmp/ccb2vt7W.s:4006   .debug_str:0000000000000265 .LASF115
     /tmp/ccb2vt7W.s:4124   .debug_str:000000000000050e .LASF116
     /tmp/ccb2vt7W.s:3954   .debug_str:0000000000000188 .LASF117
     /tmp/ccb2vt7W.s:4092   .debug_str:0000000000000422 .LASF118
     /tmp/ccb2vt7W.s:4226   .debug_str:0000000000000715 .LASF119
     /tmp/ccb2vt7W.s:3916   .debug_str:00000000000000e4 .LASF120
     /tmp/ccb2vt7W.s:4164   .debug_str:00000000000005b4 .LASF121
     /tmp/ccb2vt7W.s:3898   .debug_str:0000000000000094 .LASF122
     /tmp/ccb2vt7W.s:4056   .debug_str:0000000000000366 .LASF123
     /tmp/ccb2vt7W.s:4230   .debug_str:0000000000000729 .LASF124
     /tmp/ccb2vt7W.s:4028   .debug_str:00000000000002dc .LASF125
     /tmp/ccb2vt7W.s:4192   .debug_str:000000000000065a .LASF126
     /tmp/ccb2vt7W.s:4088   .debug_str:000000000000040b .LASF127
     /tmp/ccb2vt7W.s:4194   .debug_str:000000000000066f .LASF128
     /tmp/ccb2vt7W.s:3892   .debug_str:000000000000006b .LASF129
     /tmp/ccb2vt7W.s:4208   .debug_str:00000000000006a4 .LASF130
     /tmp/ccb2vt7W.s:3984   .debug_str:00000000000001ff .LASF131
     /tmp/ccb2vt7W.s:4020   .debug_str:00000000000002bb .LASF132
     /tmp/ccb2vt7W.s:4240   .debug_str:0000000000000761 .LASF133
     /tmp/ccb2vt7W.s:3886   .debug_str:000000000000004d .LASF134
     /tmp/ccb2vt7W.s:4228   .debug_str:000000000000071f .LASF135
     /tmp/ccb2vt7W.s:3882   .debug_str:0000000000000035 .LASF136
     /tmp/ccb2vt7W.s:3986   .debug_str:000000000000020b .LASF140
     /tmp/ccb2vt7W.s:4220   .debug_str:00000000000006f9 .LASF137
     /tmp/ccb2vt7W.s:3990   .debug_str:0000000000000232 .LASF138
     /tmp/ccb2vt7W.s:4224   .debug_str:000000000000070b .LASF139
     /tmp/ccb2vt7W.s:4190   .debug_str:000000000000064f .LASF141
     /tmp/ccb2vt7W.s:3874   .debug_str:000000000000001c .LASF142
     /tmp/ccb2vt7W.s:4180   .debug_str:000000000000061e .LASF143
     /tmp/ccb2vt7W.s:4128   .debug_str:0000000000000529 .LASF144
     /tmp/ccb2vt7W.s:4146   .debug_str:0000000000000567 .LASF145
     /tmp/ccb2vt7W.s:4182   .debug_str:0000000000000629 .LASF146
     /tmp/ccb2vt7W.s:3996   .debug_str:0000000000000245 .LASF147
     /tmp/ccb2vt7W.s:4160   .debug_str:00000000000005a9 .LASF148
     /tmp/ccb2vt7W.s:4148   .debug_str:000000000000056c .LASF149
     /tmp/ccb2vt7W.s:4132   .debug_str:000000000000053a .LASF150
     /tmp/ccb2vt7W.s:4196   .debug_str:000000000000067c .LASF151
     /tmp/ccb2vt7W.s:4090   .debug_str:0000000000000418 .LASF152
     /tmp/ccb2vt7W.s:4034   .debug_str:00000000000002fb .LASF153
     /tmp/ccb2vt7W.s:4094   .debug_str:000000000000042c .LASF154
     /tmp/ccb2vt7W.s:4206   .debug_str:000000000000069b .LASF155
     /tmp/ccb2vt7W.s:4232   .debug_str:0000000000000735 .LASF185
     /tmp/ccb2vt7W.s:4060   .debug_str:0000000000000379 .LASF156
     /tmp/ccb2vt7W.s:3902   .debug_str:00000000000000a6 .LASF157
     /tmp/ccb2vt7W.s:4106   .debug_str:0000000000000471 .LASF158
     /tmp/ccb2vt7W.s:4130   .debug_str:0000000000000532 .LASF159
     /tmp/ccb2vt7W.s:4068   .debug_str:00000000000003b2 .LASF160
     /tmp/ccb2vt7W.s:4064   .debug_str:0000000000000396 .LASF161
     /tmp/ccb2vt7W.s:3918   .debug_str:00000000000000f4 .LASF162
     /tmp/ccb2vt7W.s:4000   .debug_str:0000000000000250 .LASF163
     /tmp/ccb2vt7W.s:3930   .debug_str:0000000000000138 .LASF164
     /tmp/ccb2vt7W.s:3922   .debug_str:0000000000000109 .LASF165
     /tmp/ccb2vt7W.s:3888   .debug_str:0000000000000059 .LASF166
     /tmp/ccb2vt7W.s:4158   .debug_str:00000000000005a3 .LASF167
     /tmp/ccb2vt7W.s:4066   .debug_str:000000000000039e .LASF168
     /tmp/ccb2vt7W.s:3910   .debug_str:00000000000000cf .LASF169
     /tmp/ccb2vt7W.s:4008   .debug_str:000000000000026f .LASF170
     /tmp/ccb2vt7W.s:4214   .debug_str:00000000000006cc .LASF171
     /tmp/ccb2vt7W.s:4168   .debug_str:00000000000005d4 .LASF172
     /tmp/ccb2vt7W.s:4210   .debug_str:00000000000006af .LASF173
     /tmp/ccb2vt7W.s:3870   .debug_str:0000000000000000 .LASF174
     /tmp/ccb2vt7W.s:4058   .debug_str:0000000000000371 .LASF175
     /tmp/ccb2vt7W.s:4042   .debug_str:0000000000000329 .LASF176
     /tmp/ccb2vt7W.s:3988   .debug_str:000000000000022c .LASF177
     /tmp/ccb2vt7W.s:4052   .debug_str:0000000000000349 .LASF178
     /tmp/ccb2vt7W.s:4118   .debug_str:00000000000004f9 .LASF179
     /tmp/ccb2vt7W.s:3926   .debug_str:000000000000011d .LASF180
     /tmp/ccb2vt7W.s:4178   .debug_str:0000000000000610 .LASF181

UNDEFINED SYMBOLS
fatalErrorNum
DoNestedPageLookup
   1              		.file	"x86.c"
   2              		.intel_syntax noprefix
   3              		.text
   4              	.Ltext0:
   5              		.comm	_exception_number,2,2
   6              		.comm	_exc_CS,2,2
   7              		.comm	_exc_IP,2,2
   8              		.comm	vhost,68,32
   9              		.comm	guest,28,4
  10              		.comm	GuestRegisters,56,32
  11              		.globl	setHostSegReg
  13              	setHostSegReg:
  14              	.LFB0:
  15              		.file 1 "x86.c"
   1:x86.c         **** #include "x86_architecture.h"
   2:x86.c         **** #include "BMVisor.h"
   3:x86.c         **** 
   4:x86.c         **** void setHostSegReg( int sr, WORD Selector )
   5:x86.c         **** {
  16              		.loc 1 5 0
  17              		.cfi_startproc
  18 0000 55       		push	ebp
  19              		.cfi_def_cfa_offset 8
  20              		.cfi_offset 5, -8
  21 0001 89E5     		mov	ebp, esp
  22              		.cfi_def_cfa_register 5
  23 0003 83EC04   		sub	esp, 4
  24 0006 8B450C   		mov	eax, DWORD PTR [ebp+12]
  25 0009 668945FC 		mov	WORD PTR [ebp-4], ax
   6:x86.c         ****     if (sr == DS)
  26              		.loc 1 6 0
  27 000d 837D0809 		cmp	DWORD PTR [ebp+8], 9
  28 0011 750C     		jne	.L2
   7:x86.c         ****         asm("mov ax,%[sel]\n push ax\n pop DS" ::[sel] "r" (Selector) );
  29              		.loc 1 7 0
  30 0013 0FB745FC 		movzx	eax, WORD PTR [ebp-4]
  31              	#APP
  32              	# 7 "x86.c" 1
   8 001a 6650     	    else if (sr == ES)
   9 001c 1F       	        asm("mov ax,%[sel]\n push ax\n pop ES" ::[sel] "r" (Selector) );    
  10              	    else if (sr == FS)
  11:x86.c         ****         asm("mov ax,%[sel]\n push ax\n pop FS" ::[sel] "r" (Selector) );    
  12:x86.c         ****     else if (sr == GS)
  13:x86.c         ****         asm("mov ax,%[sel]\n push ax\n pop GS" ::[sel] "r" (Selector) );    
  14:x86.c         ****     else if (sr == SS)
  15:x86.c         ****         asm("mov ax,%[sel]\n push ax\n pop SS" ::[sel] "r" (Selector) );    
  16:x86.c         **** }
  33              		mov ax,ax
  34              	 push ax
  35              	 pop DS
  36              	# 0 "" 2
  37              		.loc 1 16 0
  38              	#NO_APP
  39 001d EB48     		jmp	.L7
  40              	.L2:
   8:x86.c         ****         asm("mov ax,%[sel]\n push ax\n pop ES" ::[sel] "r" (Selector) );    
  41              		.loc 1 8 0
  42 001f 837D080A 		cmp	DWORD PTR [ebp+8], 10
  43 0023 750C     		jne	.L4
   9:x86.c         ****     else if (sr == FS)
  44              		.loc 1 9 0
  45 0025 0FB745FC 		movzx	eax, WORD PTR [ebp-4]
  46              	#APP
  47              	# 9 "x86.c" 1
  48              		mov ax,ax
  49              	 push ax
  50              	 pop ES
  51              	# 0 "" 2
  52              		.loc 1 16 0
  53              	#NO_APP
  54 002f EB36     		jmp	.L7
  55              	.L4:
  10:x86.c         ****         asm("mov ax,%[sel]\n push ax\n pop FS" ::[sel] "r" (Selector) );    
  56              		.loc 1 10 0
  57 0031 837D080B 		cmp	DWORD PTR [ebp+8], 11
  58 0035 750D     		jne	.L5
  11:x86.c         ****     else if (sr == GS)
  59              		.loc 1 11 0
  60 0037 0FB745FC 		movzx	eax, WORD PTR [ebp-4]
  61              	#APP
  62              	# 11 "x86.c" 1
  63              		mov ax,ax
  64              	 push ax
  65              	 pop FS
  66              	# 0 "" 2
  67              		.loc 1 16 0
  68              	#NO_APP
  69 0042 EB23     		jmp	.L7
  70              	.L5:
  12:x86.c         ****         asm("mov ax,%[sel]\n push ax\n pop GS" ::[sel] "r" (Selector) );    
  71              		.loc 1 12 0
  72 0044 837D080C 		cmp	DWORD PTR [ebp+8], 12
  73 0048 750D     		jne	.L6
  13:x86.c         ****     else if (sr == SS)
  74              		.loc 1 13 0
  75 004a 0FB745FC 		movzx	eax, WORD PTR [ebp-4]
  76              	#APP
  77              	# 13 "x86.c" 1
  78              		mov ax,ax
  79              	 push ax
  80              	 pop GS
  81              	# 0 "" 2
  82              		.loc 1 16 0
  83              	#NO_APP
  84 0055 EB10     		jmp	.L7
  85              	.L6:
  14:x86.c         ****         asm("mov ax,%[sel]\n push ax\n pop SS" ::[sel] "r" (Selector) );    
  86              		.loc 1 14 0
  87 0057 837D080D 		cmp	DWORD PTR [ebp+8], 13
  88 005b 750A     		jne	.L7
  15:x86.c         **** }
  89              		.loc 1 15 0
  90 005d 0FB745FC 		movzx	eax, WORD PTR [ebp-4]
  91              	#APP
  92              	# 15 "x86.c" 1
  17 0066 17       	...
  93              		mov ax,ax
  94              	 push ax
  95              	 pop SS
  96              	# 0 "" 2
  97              	#NO_APP
  98              	.L7:
  16:x86.c         **** }
  99              		.loc 1 16 0
 100 0067 90       		nop
 101 0068 C9       		leave
 102              		.cfi_restore 5
 103              		.cfi_def_cfa 4, 4
 104 0069 C3       		ret
 105              		.cfi_endproc
 106              	.LFE0:
 108              	.Letext0:
 109              		.file 2 "types.h"
 110              		.file 3 "xen_types.h"
 111              		.file 4 "x86_architecture.h"
 112              		.file 5 "vmcb.h"
 113              		.file 6 "host.h"
 114              		.file 7 "guest.h"
 115              		.file 8 "isr_wrapper.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 x86.c
     /tmp/ccb2vt7W.s:4      .text:0000000000000000 .Ltext0
                            *COM*:0000000000000002 _exception_number
                            *COM*:0000000000000002 _exc_CS
                            *COM*:0000000000000002 _exc_IP
                            *COM*:0000000000000044 vhost
                            *COM*:000000000000001c guest
                            *COM*:0000000000000038 GuestRegisters
     /tmp/ccb2vt7W.s:13     .text:0000000000000000 setHostSegReg
     /tmp/ccb2vt7W.s:14     .text:0000000000000000 .LFB0
     /tmp/ccb2vt7W.s:40     .text:000000000000001f .L2
     /tmp/ccb2vt7W.s:98     .text:0000000000000067 .L7
     /tmp/ccb2vt7W.s:55     .text:0000000000000031 .L4
     /tmp/ccb2vt7W.s:70     .text:0000000000000044 .L5
     /tmp/ccb2vt7W.s:85     .text:0000000000000057 .L6
     /tmp/ccb2vt7W.s:106    .text:000000000000006a .LFE0
     /tmp/ccb2vt7W.s:108    .text:000000000000006a .Letext0
     /tmp/ccb2vt7W.s:117    .debug_info:0000000000000000 .Ldebug_info0
     /tmp/ccb2vt7W.s:1456   .debug_abbrev:0000000000000000 .Ldebug_abbrev0
     /tmp/ccb2vt7W.s:2067   .debug_str:0000000000000392 .LASF137
     /tmp/ccb2vt7W.s:2125   .debug_str:000000000000052b .LASF138
     /tmp/ccb2vt7W.s:1983   .debug_str:00000000000001da .LASF139
     /tmp/ccb2vt7W.s:1871   .debug_line:0000000000000000 .Ldebug_line0
     /tmp/ccb2vt7W.s:2031   .debug_str:00000000000002d9 .LASF0
     /tmp/ccb2vt7W.s:2119   .debug_str:00000000000004fb .LASF2
     /tmp/ccb2vt7W.s:2037   .debug_str:00000000000002ee .LASF1
     /tmp/ccb2vt7W.s:2141   .debug_str:000000000000056b .LASF3
     /tmp/ccb2vt7W.s:1947   .debug_str:000000000000014e .LASF4
     /tmp/ccb2vt7W.s:2109   .debug_str:00000000000004b5 .LASF5
     /tmp/ccb2vt7W.s:1951   .debug_str:000000000000015e .LASF6
     /tmp/ccb2vt7W.s:2139   .debug_str:000000000000055f .LASF7
     /tmp/ccb2vt7W.s:2075   .debug_str:0000000000000404 .LASF8
     /tmp/ccb2vt7W.s:1985   .debug_str:00000000000001fe .LASF9
     /tmp/ccb2vt7W.s:2019   .debug_str:000000000000028e .LASF10
     /tmp/ccb2vt7W.s:1883   .debug_str:0000000000000030 .LASF11
     /tmp/ccb2vt7W.s:2023   .debug_str:00000000000002a3 .LASF12
     /tmp/ccb2vt7W.s:2071   .debug_str:00000000000003f4 .LASF13
     /tmp/ccb2vt7W.s:2015   .debug_str:0000000000000282 .LASF14
     /tmp/ccb2vt7W.s:2057   .debug_str:0000000000000358 .LASF15
     /tmp/ccb2vt7W.s:1919   .debug_str:00000000000000ea .LASF16
     /tmp/ccb2vt7W.s:2093   .debug_str:0000000000000451 .LASF17
     /tmp/ccb2vt7W.s:2117   .debug_str:00000000000004f6 .LASF18
     /tmp/ccb2vt7W.s:1903   .debug_str:000000000000009e .LASF19
     /tmp/ccb2vt7W.s:2079   .debug_str:0000000000000419 .LASF20
     /tmp/ccb2vt7W.s:1999   .debug_str:0000000000000239 .LASF21
     /tmp/ccb2vt7W.s:2017   .debug_str:0000000000000287 .LASF22
     /tmp/ccb2vt7W.s:2029   .debug_str:00000000000002c4 .LASF23
     /tmp/ccb2vt7W.s:2007   .debug_str:000000000000025e .LASF41
     /tmp/ccb2vt7W.s:1963   .debug_str:0000000000000192 .LASF24
     /tmp/ccb2vt7W.s:1901   .debug_str:0000000000000098 .LASF25
     /tmp/ccb2vt7W.s:1941   .debug_str:0000000000000136 .LASF26
     /tmp/ccb2vt7W.s:1929   .debug_str:000000000000010b .LASF27
     /tmp/ccb2vt7W.s:1881   .debug_str:0000000000000029 .LASF28
     /tmp/ccb2vt7W.s:1949   .debug_str:0000000000000154 .LASF29
     /tmp/ccb2vt7W.s:2035   .debug_str:00000000000002e3 .LASF30
     /tmp/ccb2vt7W.s:2127   .debug_str:0000000000000531 .LASF31
     /tmp/ccb2vt7W.s:2009   .debug_str:000000000000026a .LASF32
     /tmp/ccb2vt7W.s:1979   .debug_str:00000000000001c8 .LASF33
     /tmp/ccb2vt7W.s:2129   .debug_str:0000000000000537 .LASF34
     /tmp/ccb2vt7W.s:2095   .debug_str:000000000000045a .LASF35
     /tmp/ccb2vt7W.s:2131   .debug_str:000000000000053d .LASF36
     /tmp/ccb2vt7W.s:2133   .debug_str:0000000000000543 .LASF37
     /tmp/ccb2vt7W.s:1877   .debug_str:000000000000001c .LASF38
     /tmp/ccb2vt7W.s:1973   .debug_str:00000000000001b5 .LASF39
     /tmp/ccb2vt7W.s:2073   .debug_str:00000000000003fa .LASF40
     /tmp/ccb2vt7W.s:1911   .debug_str:00000000000000c6 .LASF42
     /tmp/ccb2vt7W.s:2083   .debug_str:000000000000042b .LASF43
     /tmp/ccb2vt7W.s:1895   .debug_str:0000000000000078 .LASF44
     /tmp/ccb2vt7W.s:2003   .debug_str:0000000000000244 .LASF45
     /tmp/ccb2vt7W.s:2041   .debug_str:00000000000002ff .LASF46
     /tmp/ccb2vt7W.s:1875   .debug_str:0000000000000008 .LASF47
     /tmp/ccb2vt7W.s:1915   .debug_str:00000000000000de .LASF48
     /tmp/ccb2vt7W.s:1917   .debug_str:00000000000000e4 .LASF49
     /tmp/ccb2vt7W.s:1933   .debug_str:0000000000000118 .LASF50
     /tmp/ccb2vt7W.s:1921   .debug_str:00000000000000f3 .LASF51
     /tmp/ccb2vt7W.s:1923   .debug_str:00000000000000f9 .LASF52
     /tmp/ccb2vt7W.s:1925   .debug_str:00000000000000ff .LASF53
     /tmp/ccb2vt7W.s:2099   .debug_str:0000000000000473 .LASF54
     /tmp/ccb2vt7W.s:2115   .debug_str:00000000000004e8 .LASF55
     /tmp/ccb2vt7W.s:1887   .debug_str:000000000000004a .LASF56
     /tmp/ccb2vt7W.s:2065   .debug_str:0000000000000387 .LASF57
     /tmp/ccb2vt7W.s:2039   .debug_str:00000000000002f3 .LASF58
     /tmp/ccb2vt7W.s:1927   .debug_str:0000000000000105 .LASF59
     /tmp/ccb2vt7W.s:2069   .debug_str:00000000000003ee .LASF60
     /tmp/ccb2vt7W.s:1889   .debug_str:0000000000000055 .LASF61
     /tmp/ccb2vt7W.s:2153   .debug_str:00000000000005b2 .LASF62
     /tmp/ccb2vt7W.s:2151   .debug_str:00000000000005a8 .LASF63
     /tmp/ccb2vt7W.s:1995   .debug_str:0000000000000224 .LASF64
     /tmp/ccb2vt7W.s:2101   .debug_str:0000000000000480 .LASF65
     /tmp/ccb2vt7W.s:1893   .debug_str:000000000000006e .LASF66
     /tmp/ccb2vt7W.s:1935   .debug_str:000000000000011e .LASF67
     /tmp/ccb2vt7W.s:2045   .debug_str:000000000000031a .LASF68
     /tmp/ccb2vt7W.s:2077   .debug_str:000000000000040e .LASF69
     /tmp/ccb2vt7W.s:1897   .debug_str:0000000000000086 .LASF70
     /tmp/ccb2vt7W.s:2137   .debug_str:0000000000000554 .LASF71
     /tmp/ccb2vt7W.s:1931   .debug_str:0000000000000112 .LASF72
     /tmp/ccb2vt7W.s:1943   .debug_str:000000000000013b .LASF73
     /tmp/ccb2vt7W.s:1977   .debug_str:00000000000001c1 .LASF74
     /tmp/ccb2vt7W.s:2005   .debug_str:0000000000000259 .LASF75
     /tmp/ccb2vt7W.s:1961   .debug_str:000000000000018d .LASF76
     /tmp/ccb2vt7W.s:2033   .debug_str:00000000000002de .LASF77
     /tmp/ccb2vt7W.s:1953   .debug_str:0000000000000175 .LASF78
     /tmp/ccb2vt7W.s:1955   .debug_str:000000000000017b .LASF79
     /tmp/ccb2vt7W.s:1957   .debug_str:0000000000000181 .LASF80
     /tmp/ccb2vt7W.s:1879   .debug_str:0000000000000024 .LASF81
     /tmp/ccb2vt7W.s:1959   .debug_str:0000000000000187 .LASF82
     /tmp/ccb2vt7W.s:2049   .debug_str:000000000000032c .LASF83
     /tmp/ccb2vt7W.s:1989   .debug_str:0000000000000212 .LASF84
     /tmp/ccb2vt7W.s:1991   .debug_str:0000000000000218 .LASF85
     /tmp/ccb2vt7W.s:1975   .debug_str:00000000000001bc .LASF86
     /tmp/ccb2vt7W.s:1905   .debug_str:00000000000000a3 .LASF87
     /tmp/ccb2vt7W.s:1971   .debug_str:00000000000001af .LASF88
     /tmp/ccb2vt7W.s:2043   .debug_str:0000000000000313 .LASF89
     /tmp/ccb2vt7W.s:1945   .debug_str:0000000000000143 .LASF90
     /tmp/ccb2vt7W.s:2063   .debug_str:000000000000037b .LASF91
     /tmp/ccb2vt7W.s:2011   .debug_str:000000000000026f .LASF92
     /tmp/ccb2vt7W.s:1909   .debug_str:00000000000000b9 .LASF93
     /tmp/ccb2vt7W.s:2085   .debug_str:0000000000000439 .LASF94
     /tmp/ccb2vt7W.s:2087   .debug_str:000000000000043f .LASF95
     /tmp/ccb2vt7W.s:2089   .debug_str:0000000000000445 .LASF96
     /tmp/ccb2vt7W.s:2091   .debug_str:000000000000044b .LASF97
     /tmp/ccb2vt7W.s:1899   .debug_str:0000000000000092 .LASF98
     /tmp/ccb2vt7W.s:1913   .debug_str:00000000000000d2 .LASF99
     /tmp/ccb2vt7W.s:2105   .debug_str:000000000000049b .LASF100
     /tmp/ccb2vt7W.s:2111   .debug_str:00000000000004c7 .LASF101
     /tmp/ccb2vt7W.s:1987   .debug_str:0000000000000204 .LASF102
     /tmp/ccb2vt7W.s:2097   .debug_str:0000000000000467 .LASF103
     /tmp/ccb2vt7W.s:1965   .debug_str:0000000000000197 .LASF104
     /tmp/ccb2vt7W.s:2107   .debug_str:00000000000004ac .LASF105
     /tmp/ccb2vt7W.s:2059   .debug_str:0000000000000361 .LASF106
     /tmp/ccb2vt7W.s:1937   .debug_str:0000000000000124 .LASF107
     /tmp/ccb2vt7W.s:2143   .debug_str:000000000000057e .LASF108
     /tmp/ccb2vt7W.s:1997   .debug_str:000000000000022e .LASF109
     /tmp/ccb2vt7W.s:2061   .debug_str:000000000000036c .LASF110
     /tmp/ccb2vt7W.s:2149   .debug_str:000000000000059e .LASF111
     /tmp/ccb2vt7W.s:1981   .debug_str:00000000000001d0 .LASF112
     /tmp/ccb2vt7W.s:2081   .debug_str:000000000000041e .LASF113
     /tmp/ccb2vt7W.s:1939   .debug_str:000000000000012d .LASF114
     /tmp/ccb2vt7W.s:2053   .debug_str:0000000000000340 .LASF115
     /tmp/ccb2vt7W.s:2145   .debug_str:0000000000000588 .LASF116
     /tmp/ccb2vt7W.s:1907   .debug_str:00000000000000a9 .LASF117
     /tmp/ccb2vt7W.s:2103   .debug_str:000000000000048c .LASF118
     /tmp/ccb2vt7W.s:1891   .debug_str:0000000000000066 .LASF119
     /tmp/ccb2vt7W.s:2025   .debug_str:00000000000002b1 .LASF120
     /tmp/ccb2vt7W.s:2147   .debug_str:0000000000000592 .LASF121
     /tmp/ccb2vt7W.s:2001   .debug_str:000000000000023f .LASF122
     /tmp/ccb2vt7W.s:2121   .debug_str:0000000000000509 .LASF123
     /tmp/ccb2vt7W.s:2051   .debug_str:0000000000000333 .LASF124
     /tmp/ccb2vt7W.s:2123   .debug_str:000000000000051e .LASF125
     /tmp/ccb2vt7W.s:1885   .debug_str:000000000000003d .LASF126
     /tmp/ccb2vt7W.s:2135   .debug_str:0000000000000549 .LASF127
     /tmp/ccb2vt7W.s:1967   .debug_str:000000000000019d .LASF128
     /tmp/ccb2vt7W.s:1993   .debug_str:000000000000021e .LASF129
     /tmp/ccb2vt7W.s:2055   .debug_str:000000000000034a .LASF140
     /tmp/ccb2vt7W.s:2047   .debug_str:0000000000000323 .LASF130
     /tmp/ccb2vt7W.s:2113   .debug_str:00000000000004d6 .LASF131
     /tmp/ccb2vt7W.s:1873   .debug_str:0000000000000000 .LASF132
     /tmp/ccb2vt7W.s:2027   .debug_str:00000000000002bc .LASF133
     /tmp/ccb2vt7W.s:2013   .debug_str:000000000000027c .LASF134
     /tmp/ccb2vt7W.s:1969   .debug_str:00000000000001a9 .LASF135
     /tmp/ccb2vt7W.s:2021   .debug_str:0000000000000294 .LASF136

NO UNDEFINED SYMBOLS
